/*  The Galerkin Ship Simulator
 *  Copyright (C) 2014 MetOcean Solutions Limited
 *
 *  This file is part of the Galerkin Ship Simulator.        
 *
 *  The Galerkin Ship Simulator is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  The Galerkin Ship Simulator is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with the Galerkin Ship Simulator.  If not, see <http://www.gnu.org/licenses/>.
*/

/* Libraries for Gnu Triangulated Surfaces */
//#include <gts.h>
#include <locale.h>

//#include <netpbm/pgm.h>
//#include <pgm.h>

#include "structures.h"
#include "patch.h"
#include "linearproblem.h"
#include "boundaries.h"
#include "surface.h"
#include "hull.h"
#include "motion.h"
#include "ncinput.h"
#include "ship.h"

//#include "mpi.h"

Simulation * simulation_new ()
{
  Simulation * new = g_malloc (sizeof(Simulation));
  new->hull = hull_new ();
  new->fs = freesurface_new ();
  new->bathy = bathymetry_new ();
  new->sub_problems = NULL;
  new->neumann_problem = NULL;
  new->dirichlet_problem = NULL;
  new->mixed_problem = NULL;
  new->nospeed_problem = NULL;
  new->neumann_lu = NULL;
  new->dirichlet_lu = NULL;
  new->mixed_lu = NULL;
  new->nospeed_lu;
  new->forces = NULL;
  new->mass_lu = NULL;
  new->verbose = FALSE;
  new->continuity = FALSE;
  new->ncdf = NULL;
  new->force_coeff = 1.;
  new->fseu_rhs1 = NULL;
  new->fseu_rhs2 = NULL;
  new->fseu_rhs3 = NULL;
  new->fseu_rhs4 = NULL;
  new->fspu_rhs1 = NULL;
  new->fspu_rhs2 = NULL;
  new->fspu_rhs3 = NULL;
  new->fspu_rhs4 = NULL;
  new->forcing_scaling_factor = 1.;
  return new;
}

static void simulation_destroy_problems (Simulation * sim)
{
  if (sim->sub_problems) {
    gint i;
    for ( i = 0; i < sim->sub_problems->len; i++) {
      BoundaryProblem * bp = g_ptr_array_index (sim->sub_problems, i);
      boundary_problem_destroy (bp);
    }
  }
  g_ptr_array_free (sim->sub_problems, TRUE);
  sim->sub_problems = NULL;

  boundary_problem_destroy (sim->neumann_problem);
  boundary_problem_destroy (sim->mixed_problem);
  boundary_problem_destroy (sim->dirichlet_problem);
  sim->neumann_problem = sim->mixed_problem = sim->dirichlet_problem = NULL;
  sim->lu_destroy (sim->neumann_lu);
  sim->lu_destroy (sim->dirichlet_lu);
  sim->lu_destroy (sim->mixed_lu);
}

void simulation_destroy (Simulation * sim)
{
  g_assert (sim != NULL);
  hull_destroy (sim->hull);
  freesurface_destroy (sim->fs);
  bathymetry_destroy (sim->bathy);
  
  simulation_destroy_problems (sim);

  netcdf_forcing_destroy (sim->ncdf);

  g_free (sim);
}

static gdouble zero_flux (Spline2D * sp,
			  gdouble u, gdouble v,
			  gpointer data)
{
  return 0.;
}

static gdouble analytical_potential (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  Point P = spline2d_eval_point (sp, u, v);
  gdouble r0 = 1;
  gdouble r = sqrt (P.x*P.x + P.y*P.y + P.z*P.z);

  return -pow(r0,3)*P.x/(2.*pow(r,3));
}

/**
 * Returns a list that contains all the patches of the simulation
 **/
GSList * simulation_all_patches_list (Simulation * sim)
{
  // List of patches to work with
  GSList * patches = NULL;

  // NB: It is important that the free-surface comes first
  // this allows to use the modulo operator for easier
  // construction of the boundary problem for periodic 
  // free-surfaces
  // Add the patches of the free-surface
  GSList * tmp = sim->fs->s->patches;
  while (tmp) {
    patches = g_slist_append (patches, tmp->data);
    tmp = tmp->next;
  }

  // Add the patches that make the hull
  tmp = sim->hull->wet_patches;
  while (tmp) {
    patches = g_slist_append (patches, tmp->data);
    tmp = tmp->next;
  }

  // Add the patches of the bathymetry
  tmp = sim->bathy->s->patches;
  while (tmp) {
    patches = g_slist_append (patches, tmp->data);
    tmp = tmp->next;
  }

  return patches;
}

void simulation_set_to_zero (Simulation * sim)
{
  GSList * all_patches = simulation_all_patches_list (sim);
  gint i;

  for ( i = 3; i < 40; i++) { 
    GSList * patches = all_patches;
    while (patches) {
      Spline2D * sp = patches->data;
      while (sp) {
	coeff_set_var_to_zero (sp, i);
	sp = sp->next;
      }
      patches = patches->next; 
    }
  }
}

/**
 * Checks whether the patch sp belongs to the free surface
 **/
static gboolean belongs_to_free_surface (Spline2D * sp, FreeSurface * fs)
{
  GSList * patches = fs->s->patches;

  while (patches) {
    if (sp == patches->data)
      return TRUE;
    patches = patches->next;
  }
  return FALSE;
}

/**
 * Computes and stores the self-influence coefficients of all panels
 * if they are not already there.
 **/
/* static void simulation_compute_self_influence_coefficients (Simulation * sim) */
/* { */

/*   GSList * l1 = simulation_all_patches_list (sim); */

/*   while (l1) { */
/*     compute_self_influence_coefficients (l1->data); */
/*     l1 = l1->next; */
/*   } */
/* } */

void add_continuity_conditions_neumann (Simulation * sim, BoundaryProblem * bp)
{
  GSList * patches = simulation_all_patches_list (sim);
  gint size = problem_size (patches);

  Spline2D * sp1 = sim->fs->s->patches->data;
  gint istart = sp1->istart;
  gint NUT = sp1->NUT;

  gint i, j, m, n;
  // Set to zero the part of the boundary problem where the conditions
  // will be imposed
  for ( i = 0; i < sp1->NUT; i++) {
    for ( j = 0; j < size; j++) {
      gsl_matrix_set (bp->A, j, istart + i, 0.);
    }
  }

  while (sp1) {
    Spline2D * sp2 = sp1->hull_patch;
    
    GrevillePoints * gr = sp1->gr;
    gsl_vector * Bu = gsl_vector_alloc (sp1->k);
    gsl_vector * Bv = gsl_vector_alloc (sp1->k);
    gsl_vector * Bu2 = gsl_vector_alloc (sp2->k);
    gsl_vector * Bv2 = gsl_vector_alloc (sp2->k);
    size_t ustart, uend, vstart, vend;

    for ( i = 0; i < sp1->NU; i++) {
      gint index1 = sp1->fs_index + i;
      gdouble u = g_array_index (gr->ui, gdouble, i);

      // Contribution of free-surface patch
      gdouble v = 0.;
  
      gsl_bspline_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,1.-u)), Bu, &ustart, &uend, sp1->w_u);
      gsl_bspline_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,v)), Bv, &vstart, &vend, sp1->w_v);

      ustart -= (sp1->k-1); // periodic patch

      for ( m = 0; m < sp1->k; m++) {
	gdouble cu = gsl_vector_get (Bu, m);
	for ( n = 0; n < sp1->k; n++) {
	  gdouble cv = gsl_vector_get (Bv, n);
	  gsl_matrix_set (bp->A, istart + (sp1->fs_index + ustart + m)%NUT + (vstart+n)*NUT, istart + index1, cu*cv);
	}
      }

      // Contribution of the hull
      v = 0.;
      gsl_bspline_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,u)), Bu2, &ustart, &uend, sp2->w_u);
      gsl_bspline_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,v)), Bv2, &vstart, &vend, sp2->w_v);

      for ( m = 0; m < sp2->k; m++) {
	gdouble cu = gsl_vector_get (Bu2, m);
	for ( n = 0; n < sp2->k; n++) {
	  gdouble cv = gsl_vector_get (Bv2, n);
	  gsl_matrix_set (bp->A, sp2->istart + (ustart+m) + (vstart+n)*sp2->NU, istart + index1, -cu*cv);
	}
      }

    }
    gsl_vector_free (Bu);
    gsl_vector_free (Bv);
    gsl_vector_free (Bu2);
    gsl_vector_free (Bv2);
    
    sp1 = sp1->next;
  }

#if 0
  sp1 = sim->fs->s->patches->data;
  for ( i = 0; i < NUT; i++) {
    for ( j = 0; j < size; j++) {
      gsl_matrix_set (bp->A, j, istart + i + NUT, 0.);
    }
  }

  while (sp1) {
    Spline2D * sp2 = sp1->hull_patch;
    
    GrevillePoints * gr = sp1->gr;
    gsl_matrix * Bu = gsl_matrix_alloc (sp1->k, sp1->k);
    gsl_matrix * Bv = gsl_matrix_alloc (sp1->k, sp1->k);
    gsl_matrix * Bu2 = gsl_matrix_alloc (sp2->k, sp2->k);
    gsl_matrix * Bv2 = gsl_matrix_alloc (sp2->k, sp2->k);
    size_t ustart, uend, vstart, vend;

    for ( i = 0; i < sp1->NU; i++) {
      gint index1 = sp1->fs_index + i + NUT;
      gdouble u = g_array_index (gr->ui, gdouble, i);


      // Contribution of free-surface patch
      gdouble v = 0.;
      Vector xv_fs;

      xv_fs.x = spline2d_derivative_eval (sp1, u, v, 0, 1, 0);
      xv_fs.y = spline2d_derivative_eval (sp1, u, v, 0, 1, 1);
      xv_fs.z = spline2d_derivative_eval (sp1, u, v, 0, 1, 2);

      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,1.-u)), sp1->k-1, Bu, &ustart, &uend, sp1->w_u, sp1->wd_u);
      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,v)), sp1->k-1, Bv, &vstart, &vend, sp1->w_v, sp1->wd_v);

      ustart -= (sp1->k-1); // periodic patch

      for ( m = 0; m < sp1->k; m++) {
	gdouble cu = gsl_matrix_get (Bu, m, 0);
	for ( n = 0; n < sp1->k; n++) {
	  gdouble cdv = gsl_matrix_get (Bv, n, 1);
	  gsl_matrix_set (bp->A, istart + (sp1->fs_index + ustart + m)%NUT + (vstart+n)*NUT, istart + index1, cu*cdv);
	}
      }

      // Contribution of the hull
      v = 0.;

      Vector xu, xv;
      xu.x = spline2d_derivative_eval (sp2, u, v, 1, 0, 0);
      xu.y = spline2d_derivative_eval (sp2, u, v, 1, 0, 1);
      xu.z = spline2d_derivative_eval (sp2, u, v, 1, 0, 2);
      xv.x = spline2d_derivative_eval (sp2, u, v, 0, 1, 0);
      xv.y = spline2d_derivative_eval (sp2, u, v, 0, 1, 1);
      xv.z = spline2d_derivative_eval (sp2, u, v, 0, 1, 2);

      Vector N = vector_normalise (vector_vector_product (&xu, &xv));

      gdouble det = xu.x*(xv.y*N.z-xv.z*N.y)
	- xu.y*(N.z*xv.x-xv.z*N.x)
	+ xu.z*(xv.x*N.y-xv.y*N.x);

      det = 1./det;
      gdouble c1 = (xv.y*N.z-xv.z*N.y)*det;
      gdouble c2 = (xu.z*N.y-xu.y*N.z)*det;
      gdouble c3 = (xv.z*N.x-xv.x*N.z)*det;
      gdouble c4 = (xu.x*N.z-xu.z*N.x)*det;
      gdouble c5 = (xv.x*N.y-xv.y*N.x)*det;
      gdouble c6 = (N.x*xu.y-xu.x*N.y)*det;

      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,u)), sp2->k-1, Bu2, &ustart, &uend, sp2->w_u, sp2->wd_u);
      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,v)), sp2->k-1, Bv2, &vstart, &vend, sp2->w_v, sp2->wd_v);

      for ( m = 0; m < sp2->k; m++) {
	gdouble cu = gsl_matrix_get (Bu2, m, 0);
	gdouble cdu = gsl_matrix_get (Bu2, m, 1);
	for ( n = 0; n < sp2->k; n++) {
	  gdouble cv = gsl_matrix_get (Bv2, n, 0);
	   gdouble cdv = gsl_matrix_get (Bv2, n, 0);
	   gsl_matrix_set (bp->A, sp2->istart + (ustart+m) + (vstart+n)*sp2->NU, istart + index1, -cdu*cv*(c1*xv_fs.x+c3*xv_fs.y+c5*xv_fs.z)
			   -cu*cdv*(c2*xv_fs.x+c4*xv_fs.y+c6*xv_fs.z));
	}
      }

    }
    gsl_matrix_free (Bu);
    gsl_matrix_free (Bv);
    gsl_matrix_free (Bu2);
    gsl_matrix_free (Bv2);
    
    sp1 = sp1->next;
  }

#endif

#if DEBUG
    FILE * fp = fopen ("system2.tmp","w");
    for ( i = 0; i < bp->A->size1; i++) {
      for ( j = 0; j < bp->A->size2; j++)
  	fprintf(fp, "%i %i %e  \n", i, j, gsl_matrix_get (bp->A, i, j));
      fprintf(fp,"\n");
    }
    fclose (fp);
#endif
}

void add_continuity_conditions_mixed (Simulation * sim, BoundaryProblem * bp)
{
  GSList * patches = simulation_all_patches_list (sim);
  gint size = problem_size (patches);

  Spline2D * sp1 = sim->fs->s->patches->data;
  gint istart = sp1->istart;
  gint NUT = sp1->NUT;

  gint i, j, m, n;
  // Set to zero the part of the boundary problem where the conditions
  // will be imposed

#if 0
  // On the free-surface
  for ( i = 0; i < sp1->NUT; i++) {
    for ( j = 0; j < size; j++) {
      gsl_matrix_set (bp->A, j, istart + i, 0.);
    }
  }
#endif

  // On the hull
  while (sp1) {
    Spline2D * sp2 = sp1->hull_patch;

    for ( i = 0; i < sp2->NU; i++) {
      //fprintf ("ii: %i \n", sp2->istart + i);
      for ( j = 0; j < size; j++) {
	gsl_matrix_set (bp->A, j, sp2->istart + i, 0.);
      }
    }

    sp1 = sp1->next;
  }

  // Continuity of potential on hull border (hull patch).
  // Potential of free-surface is known (rhs)
  sp1 = sim->fs->s->patches->data;
  while (sp1) {
    Spline2D * sp2 = sp1->hull_patch;
    
    GrevillePoints * gr = sp2->gr;

    gsl_vector * Bu2 = gsl_vector_alloc (sp2->k);
    gsl_vector * Bv2 = gsl_vector_alloc (sp2->k);
    size_t ustart, uend, vstart, vend;

    for ( i = 0; i < sp2->NU; i++ ) {
      gint index1 = sp2->istart + i;

      gdouble u = g_array_index (gr->ui, gdouble, i);
      gdouble v = 0.;

      gsl_bspline_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,u)), Bu2, &ustart, &uend, sp2->w_u);
      gsl_bspline_eval_nonzero (v, Bv2, &vstart, &vend, sp2->w_v);

      if (sp2->periodic) {
      	ustart -= (sp2->k-1); // periodic patch */
      	/* g_assert_not_reached (); */
      }

      for ( m = 0; m < sp2->k; m++) {
      	gdouble cu = gsl_vector_get (Bu2, m);
      	for ( n = 0; n < sp2->k; n++) {
      	  gdouble cv = gsl_vector_get (Bv2, n);
      	  gsl_matrix_set (bp->A, sp2->istart + (ustart+m) + (vstart+n)*sp2->NU, index1, cu*cv);
      	}
      }
    }

    gsl_vector_free (Bu2);
    gsl_vector_free (Bv2);
    
    sp1 = sp1->next;
  }

#if 0
  // Continuity of potential gradient on hull border (free-surface patch)
  sp1 = sim->fs->s->patches->data;
  while (sp1) {
    Spline2D * sp2 = sp1->hull_patch;
    
    GrevillePoints * gr = sp1->gr;
    gsl_matrix * Bu = gsl_matrix_alloc (sp1->k, 2);
    gsl_matrix * Bv = gsl_matrix_alloc (sp1->k, 2);
    gsl_matrix * Bu2 = gsl_matrix_alloc (sp2->k, 2);
    gsl_matrix * Bv2 = gsl_matrix_alloc (sp2->k, 2);
    size_t ustart, uend, vstart, vend;

    for ( i = 0; i < sp1->NU; i++) {
      gint index1 = sp1->fs_index + i;
      gdouble u = g_array_index (gr->ui, gdouble, i);

      // Contribution of free-surface patch
      gdouble v = 0.;

      // Normal on FS
      Vector NFS = spline2d_normal (sp1, 1.-u, 0);

      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,1.-u)), 1, Bu, &ustart, &uend, sp1->w_u, sp1->wd_u);
      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,v)), 1, Bv, &vstart, &vend, sp1->w_v, sp1->wd_v);

      ustart -= (sp1->k-1); // periodic patch

      for ( m = 0; m < sp1->k; m++) {
  	gdouble cu = gsl_matrix_get (Bu, m, 0);
  	for ( n = 0; n < sp1->k; n++) {
  	  gdouble cv = gsl_matrix_get (Bv, n, 0);
  	  gsl_matrix_set (bp->A, istart + (sp1->fs_index + ustart + m)%NUT + (vstart+n)*NUT, istart + index1, cu*cv);
  	}
      }

    

      // Contribution of the hull
      v = 0.;
      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,u)), 1, Bu2, &ustart, &uend, sp2->w_u, sp2->wd_u);
      gsl_bspline_deriv_eval_nonzero (MAX(1e-12,MIN(1.-1e-12,v)), 1, Bv2, &vstart, &vend, sp2->w_v, sp2->wd_v);

      // Gradient on hull
      Vector xu, xv;
      /* xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.; */
      
      /* gint ii = ustart; */
      /* for ( m = 0; m < sp2->k; m++) { */
      /* 	gdouble cu = gsl_matrix_get (Bu2, m, 0); */
      /* 	gdouble cdu = gsl_matrix_get (Bu2, m, 1); */
      /* 	for ( n = 0; n < sp2->k; n++) { */
      /* 	  gint jj = (vstart+n); */
      /* 	  gdouble cv = gsl_matrix_get (Bv, n, 0); */
      /* 	  gdouble cudv = cu*gsl_matrix_get (Bv, n, 1); */
      /* 	  gdouble cvdu = cv*cdu; */
	
      /* 	  gdouble v0 = coeff (sp2,ii,jj,0); */
      /* 	  gdouble v1 = coeff (sp2,ii,jj,1); */
      /* 	  gdouble v2 = coeff (sp2,ii,jj,2); */
      
      /* 	  xu.x += v0*cvdu; */
      /* 	  xu.y += v1*cvdu; */
      /* 	  xu.z += v2*cvdu; */
      /* 	  xv.x += v0*cudv; */
      /* 	  xv.y += v1*cudv; */
      /* 	  xv.z += v2*cudv; */
      /* 	} */
      /* 	ii++; */
      /* } */

      xu.x = spline2d_derivative_eval (sp2, u, v, 1, 0, 0);
      xu.y = spline2d_derivative_eval (sp2, u, v, 1, 0, 1);
      xu.z = spline2d_derivative_eval (sp2, u, v, 1, 0, 2);

      xv.x = spline2d_derivative_eval (sp2, u, v, 0, 1, 0);
      xv.y = spline2d_derivative_eval (sp2, u, v, 0, 1, 1);
      xv.z = spline2d_derivative_eval (sp2, u, v, 0, 1, 2);

      /* /\* Generalised Gradient coefficients *\/ */
      /* gdouble det = xu.x*(xv.y*N.z-xv.z*N.y) */
      /* 	- xu.y*(N.z*xv.x-xv.z*N.x) */
      /* 	+ xu.z*(xv.x*N.y-xv.y*N.x); */
      /* det = 1./det; */
      /* gdouble c1 = (xv.y*N.z-xv.z*N.y)*det; */
      /* gdouble c2 = (xu.z*N.y-xu.y*N.z)*det; */
      /* gdouble c3 = (xv.z*N.x-xv.x*N.z)*det; */
      /* gdouble c4 = (xu.x*N.z-xu.z*N.x)*det; */
      /* gdouble c5 = (xv.x*N.y-xv.y*N.x)*det; */
      /* gdouble c6 = (N.x*xu.y-xu.x*N.y)*det; */

      /* Inverse Lame coefficients squared */
      gdouble h1_2 = 1./(xu.x*xu.x + xu.y*xu.y + xu.z*xu.z);
      gdouble h2_2 = 1./(xv.x*xv.x + xv.y*xv.y + xv.z*xv.z);

      /* Normal on hull */
      gdouble alpha1 = h1_2*vector_scalar_product (&xu, &NFS);
      gdouble alpha2 = h2_2*vector_scalar_product (&xv, &NFS);

      for ( m = 0; m < sp2->k; m++) {
  	gdouble cu = gsl_matrix_get (Bu2, m, 0);
  	gdouble cdu = gsl_matrix_get (Bu2, m, 1);
  	for ( n = 0; n < sp2->k; n++) {
  	  gdouble cv = gsl_matrix_get (Bv2, n, 0);
  	  gdouble cdv = gsl_matrix_get (Bv2, n, 1);
	  /* gdouble tmp = gsl_matrix_get (bp->A,  sp2->istart + (ustart+m) + (vstart+n)*sp2->NU, istart + index1); */
  	  gsl_matrix_set (bp->A, sp2->istart + (ustart+m) + (vstart+n)*sp2->NU, istart + index1, -alpha1*cdu*cv - alpha2*cu*cdv);
	  /* gdouble tmp = gsl_matrix_get (bp->A, istart + (sp1->fs_index + ustart + m)%NUT + (vstart+n)*NUT, istart + index1); */
	  /* gsl_matrix_set (bp->A, istart + (sp1->fs_index + ustart + m)%NUT + (vstart+n)*NUT, istart + index1, tmp-alpha1*cdu*cv - alpha2*cu*cdv); */
  	}
      }

    }
    gsl_matrix_free (Bu);
    gsl_matrix_free (Bv);
    gsl_matrix_free (Bu2);
    gsl_matrix_free (Bv2);
    
    sp1 = sp1->next;
  }
#endif

#if DEBUG
  FILE * fp = fopen ("system2.tmp","w");
  for ( i = 0; i < bp->A->size1; i++) {
      for ( j = 0; j < bp->A->size2; j++)
  	fprintf(fp, "%i %i %e  \n", i, j, gsl_matrix_get (bp->A, i, j));
      fprintf(fp,"\n");
  }
  fclose (fp);
#endif
}

void add_neumann_continuity_conditions_rhs (Simulation * sim,
					    BoundaryProblem * bp,
					    gint var)
{
  GSList * patches = simulation_all_patches_list (sim);
  
  GSList * l1 = patches;
  gint i = 0; 
  while (l1) {
    GSList * l2 = patches;
    Spline2D * sp1 = l1->data;

    if (belongs_to_free_surface (sp1, sim->fs)) {
      // Potential continuity
      for ( i = 0; i < sp1->NUT; i++)
	gsl_vector_set (bp->rhs, sp1->istart + i, 0.0);

#if 0
      gint istart = sp1->istart;
      // dv Derivatives continuity
      while (sp1) {
	Spline2D * sp2 = sp1->hull_patch;
	for ( i = 0; i < sp1->NU; i++) {
	  gint index1 = sp1->fs_index + i + sp1->NUT;
	  gdouble u = g_array_index (sp1->gr->ui, gdouble, i);
	  // Contribution of free-surface patch
	  gdouble v = 0.;
	  Vector xv_fs;

	  xv_fs.x = spline2d_derivative_eval (sp1, u, v, 0, 1, 0);
	  xv_fs.y = spline2d_derivative_eval (sp1, u, v, 0, 1, 1);
	  xv_fs.z = spline2d_derivative_eval (sp1, u, v, 0, 1, 2);

	  Vector N_hull = spline2d_normal (sp2, u, v);

	  gdouble phin_hull = spline2d_eval (sp2, u, v, var);

	  gsl_vector_set (bp->rhs, istart + index1,
			  phin_hull*(xv_fs.x*N_hull.x
				     + xv_fs.y*N_hull.y
				     + xv_fs.z*N_hull.z));
	}
	sp1 = sp1->next;
      }
#endif
    }

    l1 = l1->next;
  }
}

void add_mixed_continuity_conditions_rhs (Simulation * sim,
					  BoundaryProblem * bp,
					  gint vard,
					  gint varn)
{
  GSList * patches = simulation_all_patches_list (sim);

  // Potential continuity

  Spline2D * sp1 = sim->fs->s->patches->data;
  gint i;
  while (sp1) {
    Spline2D * sp2 = sp1->hull_patch; 
    GrevillePoints * gr = sp2->gr;

    for ( i = 0; i < sp2->NU; i++ ) {
      gint index1 = sp2->istart + i;
      gdouble u = g_array_index (gr->ui, gdouble, i);
      gdouble v = 0.;

      /* Point p = spline2d_eval_point (sp2, u, v); */
      /* fprintf (stdout, "%f %f %f \n", p.x, p.y, 0.); */

      gsl_vector_set (bp->rhs, index1, spline2d_eval (sp1, 1.-u, v, vard)); 
    }
    sp1 = sp1->next;
  }

#if 0
  // Potential gradient continuity
  GSList * l1 = patches;
  i = 0;
  while (l1) {
    GSList * l2 = patches;
    Spline2D * sp1 = l1->data;

    if (belongs_to_free_surface (sp1, sim->fs)) {

      while (sp1) {
  	Spline2D * sp2 = sp1->hull_patch;
  	GrevillePoints * gr = sp1->gr;

  	for ( i = 0; i < sp1->NU; i++) {
  	  gdouble u = g_array_index (gr->ui, gdouble, i);
  	  gdouble v = 0.;
  	  Vector NFS = spline2d_normal (sp1, 1.-u, v);
  	  Vector NHULL = spline2d_normal (sp2, u, v);
  	  // Might have to be replaced by a BC
  	  gdouble phin = spline2d_eval (sp2, u, v, varn);

	  Point p = spline2d_eval_point (sp2, u, v);
	  Vector grad = sim->wp.wave_potential_gradient (&sim->wp, p, sim->time.t+sim->time.dt); //?????

	  phin = -vector_scalar_product (&grad, &NHULL);

  	  gsl_vector_set (bp->rhs, sp1->istart + i, phin*(vector_scalar_product (&NFS, &NHULL)));
	  
  	}
  	sp1 = sp1->next;
      }
    }
    l1 = l1->next;
  }
#endif
}

void add_dirichlet_continuity_conditions_rhs (Simulation * sim,
					      BoundaryProblem * bp,
					      gint var)
{
  GSList * patches = simulation_all_patches_list (sim);
  gint i;

  // Potential gradient continuity
  GSList * l1 = patches;
  i = 0;
  gint NUT;
  while (l1) {
    GSList * l2 = patches;
    Spline2D * sp1 = l1->data;

    if (belongs_to_free_surface (sp1, sim->fs)) {
      NUT = sp1->istart;
      while (sp1) {
  	Spline2D * sp2 = sp1->hull_patch;
  	GrevillePoints * gr = sp1->gr;

  	for ( i = 0; i < sp1->NU; i++) {
  	  gdouble u = g_array_index (gr->ui, gdouble, i);
  	  gdouble v = 0.;
  	  Vector NFS = spline2d_normal (sp1, 1.-u, v);

	  Vector xu, xv;
	  xu.x = spline2d_derivative_eval (sp2, u, v, 1, 0, 0);
	  xu.y = spline2d_derivative_eval (sp2, u, v, 1, 0, 1);
	  xu.z = spline2d_derivative_eval (sp2, u, v, 1, 0, 2);
	  
	  xv.x = spline2d_derivative_eval (sp2, u, v, 0, 1, 0);
	  xv.y = spline2d_derivative_eval (sp2, u, v, 0, 1, 1);
	  xv.z = spline2d_derivative_eval (sp2, u, v, 0, 1, 2);

	  Vector NHULL = vector_vector_product (&xu, &xv);
	  /* Generalised Gradient coefficients */
	  gdouble det = xu.x*(xv.y*NHULL.z-xv.z*NHULL.y)
	    - xu.y*(NHULL.z*xv.x-xv.z*NHULL.x)
	    + xu.z*(xv.x*NHULL.y-xv.y*NHULL.x);
	  det = 1./det;
	  gdouble c1 = (xv.y*NHULL.z-xv.z*NHULL.y)*det;
	  gdouble c2 = (xu.z*NHULL.y-xu.y*NHULL.z)*det;
	  gdouble c3 = (xv.z*NHULL.x-xv.x*NHULL.z)*det;
	  gdouble c4 = (xu.x*NHULL.z-xu.z*NHULL.x)*det;
	  gdouble c5 = (xv.x*NHULL.y-xv.y*NHULL.x)*det;
	  gdouble c6 = (NHULL.x*xu.y-xu.x*NHULL.y)*det;

	  gdouble dphidu, dphidv;
	  dphidu = spline2d_derivative_eval (sp2, u, v, 1, 0, var);
	  dphidv = spline2d_derivative_eval (sp2, u, v, 0, 1, var);

  	  gsl_vector_set (bp->rhs, /* sp1->istart */NUT + i,
			  /* NFS.x*(c1*dphidu+c2*dphidv) */
			  /* + NFS.y*(c3*dphidu+c4*dphidv) */
			  /* + NFS.z*(c5*dphidu+c5*dphidv) */0.);
	  
  	}
	NUT += sp1->NU;
  	sp1 = sp1->next;
      }
    }
    l1 = l1->next;
  }
}

/**
 * Calculates and stores all the Neumann and dirichlet subproblems
 * representative of the influence of a patch on another.
 * NB: Dirichlet conditions are never applied on the hull, which means
 * that a few of those subproblems are computed for nothing.
 **/
static void simulation_build_boundary_sub_problems (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);
  sim->sub_problems = g_ptr_array_new ();

  GSList * l1 = patches;
  while (l1) {
    GSList * l2 = patches;
    Spline2D * p1 = l1->data;

    while (l2) {
      Spline2D * p2 = l2->data;

      BoundarySubProblem * bsp = sim->build_boundary_subproblem (p1, p2,
								 sim->self_influence_function);
			
      g_ptr_array_add (sim->sub_problems, bsp);
      l2 = l2->next;
    }
    l1 = l1->next;
  }
}

/**
 * Builds and stores the rhs for the 100% Neumann boundary problem
 * the boundary condition has to be stored in var prior to calling this
 * function.
 **/
static void simulation_build_neumann_sub_problems_rhs (Simulation * sim, gint var)
{
  GSList * patches = simulation_all_patches_list (sim);
  
  GSList * l1 = patches;
  gint i = 0; 
  while (l1) {
    GSList * l2 = patches;
    Spline2D * p1 = l1->data;

    while (l2) {
      Spline2D * p2 = l2->data;
      BoundarySubProblem * bsp = g_ptr_array_index (sim->sub_problems, i);

      boundary_subproblem_build_rhs_neumann (p1, p2, bsp, var);
 
      l2 = l2->next; i++;
    }
    l1 = l1->next;
  }
}

/**
 * Puts together and stores the total matrix for the 100% Neumann boundary
 * problem.
 **/
static void simulation_build_neumann_boundary_problem (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);

  g_assert (sim->neumann_problem == NULL);
  
  gint size = problem_size (patches);
  sim->neumann_problem = boundary_problem_new (size, size);

  boundary_problem_assemble_neumann (sim->neumann_problem, sim->sub_problems);

  if (sim->continuity)
    add_continuity_conditions_neumann (sim, sim->neumann_problem);

  sim->neumann_lu = sim->lu_factorise (sim->neumann_problem->A);
}

void boundary_problem_assemble_implicit_no_speed_neumann (BoundaryProblem * bp,
							  GPtrArray * sub_problems,
							  Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);
  GSList * l1 = patches;
  gint i, j;
  gint c = 0;
  //gdouble alpha = 2./(sim->g*sim->time.dt*sim->time.dt); // 2nd order

  /* For numerical beaches */
  /* gdouble nu = 0.; */
  /* Point p; */
  /* p = spline2d_eval_point ( , ); */
  /* if ( sim->numerical_beaches ) */
  /*   nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp); */

  gdouble alpha = 15./(4.*sim->g*sim->time.dt*sim->time.dt); // 4th order

  while (l1) {
    Spline2D * p1 = l1->data;
    GSList * l2 = patches;

    while (l2) {
      Spline2D * p2 = l2->data;
      BoundarySubProblem * sub_problem = g_ptr_array_index (sub_problems, c);      

      if (belongs_to_free_surface (p2, sim->fs)) {
	BoundaryProblem * neumann = sub_problem->neumann;
	BoundaryProblem * dirichlet = sub_problem->dirichlet;

	//*******
	/* gint NU2 = p2->periodic ? p2->NUT:p2->NU; */
	/* Point tmp[NU2*p2->NV]; */
	/* gdouble nu[NU2*p2->NV]; */

  	/* if (!p2->periodic) { */
	/*   for ( i = 0; i < p2->NU; i++) { */
	/*     for ( j = 0; j < p2->NV; j++) { */
	/*       tmp[i + j*p2->NU].x = coeff (p2, i, j, 0); */
	/*       tmp[i + j*p2->NU].y = coeff (p2, i, j, 1); */
	/*       // tmp[i + j*p2->NU].z = coeff (sp2, i, j, 0); */
	/*     } */
	/*   } */
	/* } */
	/* else { */
	/*   Spline2D * sp22 = p2; */
	/*   gint NUT = sp22->NUT; */
	/*   while (sp22) { */
	/*     for ( i = 0; i < sp22->NU; i++) { */
	/*       gint indexi = (sp22->fs_index + i)%NUT; */
	/*       for ( j = 0; j < sp22->NV; j++) { */
	/* 	tmp[indexi+j*NUT].x = coeff (sp22, i, j, 0); */
	/* 	tmp[indexi+j*NUT].y = coeff (sp22, i, j, 1); */
	/*       } */
	/*     } */
	/*     sp22 = sp22->next; */
	/*   } */
	/* } */
	
	/* for ( j = 0; j < dirichlet->A->size2; j++) { */
	/*   if ( sim->numerical_beaches ) */
	/*     nu[j] = sim->numerical_beaches (tmp1[j].x, tmp[j].y, 0., &sim->wp); */
	/* } */

	//*******

	for ( i = 0; i < dirichlet->A->size1; i++)
	  for ( j = 0; j < dirichlet->A->size2; j++)
	    gsl_matrix_set (bp->A, dirichlet->istart + j, dirichlet->jstart + i,
			    gsl_matrix_get (neumann->A, i, j)
			    + alpha*gsl_matrix_get (dirichlet->A, i, j));
      }
      else {
	// Neumann
	BoundaryProblem * neumann = sub_problem->neumann;

	for ( i = 0; i < neumann->A->size1; i++)
	  for ( j = 0; j < neumann->A->size2; j++)
	    gsl_matrix_set (bp->A, neumann->istart + j, neumann->jstart + i,
			    gsl_matrix_get (neumann->A, i, j));
      }

      l2 = l2->next; c++;
    }
    l1 = l1->next;
  }

#if DEBUG
    FILE * fp = fopen ("no_speed_bp.tmp","w");
    for ( i = 0; i < bp->A->size1; i++) {
      for ( j = 0; j < bp->A->size2; j++)
  	fprintf(fp, "%i %i %e  \n", i, j, gsl_matrix_get (bp->A, i, j));
      fprintf(fp,"\n");
    }
    fclose (fp);
#endif
}

static void simulation_build_implicit_no_speed_boundary_problem (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);

  g_assert (sim->nospeed_problem == NULL);
  
  gint size = problem_size (patches);
  sim->nospeed_problem = boundary_problem_new (size, size);

  boundary_problem_assemble_implicit_no_speed_neumann (sim->nospeed_problem,
						       sim->sub_problems,
						       sim);

  sim->nospeed_lu = sim->lu_factorise (sim->nospeed_problem->A);
}

/**
 * Builds and stores the rhs for the 100% Dirichlet boundary problem
 * the boundary condition has to be stored in var prior to calling this
 * function.
 **/
static void simulation_build_dirichlet_sub_problems_rhs (Simulation * sim, gint var)
{
  GSList * patches = simulation_all_patches_list (sim);
  
  GSList * l1 = patches;
  gint i = 0; 
  while (l1) {
    GSList * l2 = patches;
    Spline2D * p1 = l1->data;

    while (l2) {
      Spline2D * p2 = l2->data;
      BoundarySubProblem * bsp = g_ptr_array_index (sim->sub_problems, i);

      boundary_subproblem_build_rhs_dirichlet (p1, p2, bsp, var);

      l2 = l2->next; i++;
    }
    l1 = l1->next;
  }
}

/**
 * Puts together and stores the total matrix for the 100% Dirichlet boundary
 * problem.
 **/
static void simulation_build_dirichlet_boundary_problem (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);

  g_assert (sim->dirichlet_problem == NULL);
  
  gint size = problem_size (patches);
  sim->dirichlet_problem = boundary_problem_new (size, size);

  boundary_problem_assemble_dirichlet (sim->dirichlet_problem, sim->sub_problems);

  /* if (sim->continuity) */
  /*   add_continuity_conditions_dirichlet (sim, sim->dirichlet_problem); */

  sim->dirichlet_lu = sim->lu_factorise (sim->dirichlet_problem->A);
}

/**
 * Builds and stores the rhs for the 100% Neumann boundary problem
 * the boundary condition has to be stored in var prior to calling this
 * function.
 **/
void boundary_subproblem_build_minus_rhs_neumann (Spline2D * sp1, Spline2D * sp2,
						  BoundarySubProblem * bsp,
						  gint var)
{
  gint i, j;
  BoundaryProblem * dirichlet = bsp->dirichlet;
  BoundaryProblem * neumann = bsp->neumann;

  gint NU1 = sp1->periodic ? sp1->NUT:sp1->NU;
  gint NU2 = sp2->periodic ? sp2->NUT:sp2->NU;

  gdouble tmp[NU2*sp2->NV];
  gdouble rhs[NU1*sp1->NV];

  gsl_vector_set_zero (neumann->rhs);

  for ( i = 0; i < NU1*sp1->NV; i++)
    rhs[i] = 0.;

  // Loop over the b-splines
  if (!sp2->periodic) {
    for ( i = 0; i < sp2->NU; i++) {
      for ( j = 0; j < sp2->NV; j++) {
	tmp[i + j*sp2->NU] = coeff (sp2, i, j, var);
      }
    }
  }
  else {
    Spline2D * sp22 = sp2;
    gint NUT = sp22->NUT;
    while (sp22) {
      for ( i = 0; i < sp22->NU; i++) {
	gint indexi = (sp22->fs_index + i)%NUT;
      	for ( j = 0; j < sp22->NV; j++) {
      	  tmp[indexi+j*NUT] = coeff (sp22, i, j, var);
      	}
      }
      sp22 = sp22->next;
    }
  }

  for ( i = 0; i < dirichlet->A->size1; i++) {
    for (j = 0; j < dirichlet->A->size2; j++) {
      rhs[i] -= gsl_matrix_get (dirichlet->A, i, j)*tmp[j];
    }
  }

  for ( i = 0; i < NU1*sp1->NV; i++)
    gsl_vector_set (neumann->rhs, i, rhs[i]);
}

static void simulation_build_mixed_sub_problems_rhs (Simulation * sim, gint var_d, gint var_n)
{
  GSList * patches = simulation_all_patches_list (sim);
  
  GSList * l1 = patches;
  gint i = 0; 
  while (l1) {
    GSList * l2 = patches;
    Spline2D * p1 = l1->data;

    while (l2) {
      Spline2D * p2 = l2->data;
      BoundarySubProblem * bsp = g_ptr_array_index (sim->sub_problems, i);

      if (belongs_to_free_surface (p2, sim->fs))
      	boundary_subproblem_build_rhs_dirichlet (p1, p2, bsp, var_d);
      else
	boundary_subproblem_build_minus_rhs_neumann (p1, p2, bsp, var_n);

      l2 = l2->next; i++;
    }
    l1 = l1->next;
  }
}

static void boundary_problem_assemble_mixed_rhs (BoundaryProblem * bp,
						 GPtrArray * sub_problems,
						 Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);
  GSList * l1 = patches;
  gint i;

  gsl_vector_set_zero (bp->rhs);

  gint c = 0; 
  while (l1) {
    Spline2D * p1 = l1->data;
    GSList * l2 = patches;

    while (l2) {
      Spline2D * p2 = l2->data;
      BoundarySubProblem * bsp = g_ptr_array_index (sub_problems, c);
      BoundaryProblem * sub_problem;

      if (belongs_to_free_surface (p2, sim->fs))
      	sub_problem = bsp->dirichlet;
      else
	sub_problem = bsp->neumann;

      for ( i = 0; i < sub_problem->rhs->size; i++) {
      	//gdouble tmp = gsl_vector_get (bp->rhs, sub_problem->jstart + i) + gsl_vector_get (sub_problem->rhs, i);
	//gsl_vector_set (bp->rhs, sub_problem->jstart + i, tmp);
	gsl_vector_set (bp->rhs, sub_problem->jstart + i, gsl_vector_get (bp->rhs, sub_problem->jstart + i)
			+ gsl_vector_get (sub_problem->rhs, i));
      }
      
      l2 = l2->next; c++;
    }
    l1 = l1->next;
  }

  /* FILE * fp = fopen ("mixed-rhs.tmp","w"); */
  /* for ( i = 0; i < bp->rhs->size; i++) */
  /*   fprintf (fp, "%i %e\n", i, gsl_vector_get (bp->rhs, i)); */
  /* fclose (fp); */
}

static void boundary_problem_assemble_mixed (BoundaryProblem * bp,
					      GPtrArray * sub_problems,
					      Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);
  GSList * l1 = patches;
  gint i, j;
  gint c = 0;
  while (l1) {
    Spline2D * p1 = l1->data;
    GSList * l2 = patches;

    while (l2) {
      Spline2D * p2 = l2->data;
      BoundarySubProblem * sub_problem = g_ptr_array_index (sub_problems, c);      

      if (belongs_to_free_surface (p2, sim->fs)) {
	BoundaryProblem * dirichlet = sub_problem->dirichlet;

	for ( i = 0; i < dirichlet->A->size1; i++)
	  for ( j = 0; j < dirichlet->A->size2; j++)
	    gsl_matrix_set (bp->A, dirichlet->istart + j, dirichlet->jstart + i,
			    gsl_matrix_get (dirichlet->A, i, j));
      }
      else {
	// Neumann
	BoundaryProblem * neumann = sub_problem->neumann;

	for ( i = 0; i < neumann->A->size1; i++)
	  for ( j = 0; j < neumann->A->size2; j++)
	    gsl_matrix_set (bp->A, neumann->istart + j, neumann->jstart + i,
			    -gsl_matrix_get (neumann->A, i, j));
      }

      l2 = l2->next; c++;
    }
    l1 = l1->next;
  }

#if DEBUG
  FILE * fp = fopen ("mixed-bp.tmp","w");
  for ( i = 0; i < bp->A->size1; i++) {
    for ( j = 0; j < bp->A->size2; j++)
      fprintf(fp, "%i %i %e  \n", i, j, gsl_matrix_get (bp->A, i, j));
    fprintf(fp,"\n");
  }
  fclose (fp);
#endif
}

static void simulation_build_mixed_boundary_problem (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);

  g_assert (sim->mixed_problem == NULL);

  gint size = problem_size (patches);
  sim->mixed_problem = boundary_problem_new (size, size);

  boundary_problem_assemble_mixed (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_continuity_conditions_mixed (sim, sim->mixed_problem);

  sim->mixed_lu = sim->lu_factorise (sim->mixed_problem->A);
}

void simulation_build_problems (Simulation * sim)
{
  g_assert (sim != NULL);
  
  // Build the Dirichlet and Neumann sub-problems 
  // each subproblem corresponds to the influence of a patch
  // over another one
  g_test_timer_start ();
  simulation_build_boundary_sub_problems (sim);
  fprintf (stdout, "simulation_build_boundary_sub_problems: %f \n", g_test_timer_elapsed());

  g_test_timer_start ();
  // Assemble the total Neumann boundary problem
  simulation_build_neumann_boundary_problem (sim);

  // Assemble the total mixed boundary problem
  simulation_build_mixed_boundary_problem (sim);

  // Assemble the total Dirichlet boundary problem
  simulation_build_dirichlet_boundary_problem (sim);

  // Assemble the total boundary problem for the implicit no speed code
  //  simulation_build_implicit_no_speed_boundary_problem (sim);
  
  fprintf (stdout, "simulation_build_boundary_problem: %f \n", g_test_timer_elapsed());
}

void simulation_build_problems_nospeed_implicit (Simulation * sim)
{
  g_assert (sim != NULL);
  
  // Build the Dirichlet and Neumann sub-problems 
  // each subproblem corresponds to the influence of a patch
  // over another one
  g_test_timer_start ();
  simulation_build_boundary_sub_problems (sim);
  fprintf (stdout, "simulation_build_boundary_sub_problems: %f \n", g_test_timer_elapsed());

  g_test_timer_start ();
  // Assemble the total Neumann boundary problem
  simulation_build_neumann_boundary_problem (sim);

  // Assemble the total mixed boundary problem
  simulation_build_mixed_boundary_problem (sim);

  // Assemble the total Dirichlet boundary problem
  //simulation_build_dirichlet_boundary_problem (sim);

  // Assemble the total boundary problem for the implicit no speed code
  simulation_build_implicit_no_speed_boundary_problem (sim);
  
  fprintf (stdout, "simulation_build_boundary_problem: %f \n", g_test_timer_elapsed());
}

void cuda_mixed_boundary_problem_copy_solution_to_patches (GSList * list,
							   BoundaryProblem * bp,
							   Simulation * sim,
							   gint vard,
							   gint varn)
{
  gint i, j;
  gint istart = 0;
  GSList * plist = list;

  /*  FILE * fp = fopen ("sol.tmp","w"); */
  /* for ( i = 0; i < bp->rhs->size; i++) { */
  /*   fprintf (fp, "%i %f\n", i, gsl_vector_get (bp->rhs , i)); */
  /* } */
  /* fclose (fp); */

  // Go over the list of patches
  while (plist != NULL) {
    Spline2D * sp = plist->data;
    g_assert (sp != NULL);
    
    if (belongs_to_free_surface (sp, sim->fs)) {
      // Loop over the b-splines
      if (sp->periodic) {
	Spline2D * splines = sp;
	gint NUT = splines->NUT;
	gint k = splines->k;
	while (splines) {
	  gint fs_index = splines->fs_index;
	  gint M = splines->M+k-1;
	  for ( i = 0; i < M; i++) {
	    gint ii = istart + (fs_index + i)%NUT;
	    for ( j = 0; j < splines->NV; j++ ) {
	      SplineCoeffs * sc = g_ptr_array_index (splines->coeffs, i + j*M);
	      sc->v[varn] = gsl_vector_get (bp->rhs, ii + j*NUT);
	    }
	  }
	  splines = splines->next;
	}
      }
      else {
	for ( i = 0; i < sp->NU; i++) {
	  for ( j = 0; j < sp->NV; j++) {
	    coeff_assign (sp, i, j, varn, gsl_vector_get (bp->rhs, istart + i + j*sp->NU));
	  }
	}
      }
    }
    else {

      if (!sp->periodic) {
	// Loop over the b-splines
	for ( i = 0; i < sp->NU; i++) {
	  for ( j = 0; j < sp->NV; j++) {
	    coeff_assign (sp, i, j, vard,
			  gsl_vector_get (bp->rhs, istart + i + j*sp->NU));
	  
	  }
	}
      }
      else {
	Spline2D * splines = sp;
	gint NUT = splines->NUT;
	gint k = splines->k;
	while (splines) {
	  gint fs_index = splines->fs_index;
	  gint M = splines->M+k-1;
	  for ( i = 0; i < M; i++) {
	    gint ii = istart + (fs_index + i)%NUT;
	    for ( j = 0; j < splines->NV; j++ ) {
	      SplineCoeffs * sc = g_ptr_array_index (splines->coeffs, i + j*M);
	      sc->v[vard] = gsl_vector_get (bp->rhs, ii + j*NUT);
	    }
	  }
	  splines = splines->next;
	}
      }
    }
    
    // shift index for next patch
    if (sp->periodic)
      istart += sp->NUT*sp->NV;
    else
      istart += sp->NU*sp->NV;
    plist = plist->next;
  }
}

/**
 * Advect the surface disturbance potential according to the free-surface kinematic and
 * dynamic conditions.
 **/
static void implicit_free_surface_disturbance_potential_update (gpointer data)
{
  /* Start timer */
  g_test_timer_start ();
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = sim->fs->s->patches->data;
  gint size = gsl_bspline_ncoeffs (sp->w_u)*gsl_bspline_ncoeffs (sp->w_v);
  gdouble A0[size][size];
  gdouble RHS[size];
  gint i, j, m, n, ii, a, b;

  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
    for ( j = 0; j < size; j++) {
      A0[i][j] = 0.;
    }
  }

  // Loop over the panels of the patch
  for ( ii = 0; ii < sp->M*sp->N; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    for ( m = 0; m < ng; m++) {
      gdouble um = g_array_index (gp->ui, gdouble, m);
      gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
      gsl_matrix * Bux = g_ptr_array_index (gp->Bux, m);
      gint ustart_x = gp->istart_x;/* g_array_index (gp->ustart, gint, m); */
      gint ustart = sp->periodic ? gp->istart - sp->k + 1 : gp->istart;

      for ( n = 0; n < ng; n++) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);
	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
	gint vstart = gp->jstart;/* g_array_index (gp->vstart, gint, n); */

	FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);

  	// Calculate W at point (um, vn)
  	Vector W = sim->U;
  	gint  i, j;
  	Vector xu, xv;
  	gdouble zeta, Phi2, Phi2n;
  	xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
  	zeta = Phi2 = Phi2n = 0.;

  	for ( i = 0; i < sp->k; i++) {
  	  gdouble cu = gsl_matrix_get (Bu, i, 0);
	  gdouble cux = gsl_matrix_get (Bux, i, 0);
  	  gdouble cdux = gsl_matrix_get (Bux, i, 1);
	  gint ii = (ustart+i);
	  gint iix = (ustart_x+i);
  	  for ( j = 0; j < sp->k; j++) {
	    gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
  	    gdouble cudvx = cux*gsl_matrix_get (Bv, j, 1);
  	    gdouble cvdux = gsl_matrix_get (Bv, j, 0)*cdux;
	    gint jj = (vstart+j);
  	    xu.x += coeff (sp,iix,jj, 0)*cvdux;
  	    xu.y += coeff (sp,iix,jj, 1)*cvdux;
  	    xu.z += coeff (sp,iix,jj, 2)*cvdux;
  	    xv.x += coeff (sp,iix,jj, 0)*cudvx;
  	    xv.y += coeff (sp,iix,jj, 1)*cudvx;
  	    xv.z += coeff (sp,iix,jj, 2)*cudvx;

  	    Phi2 += coeff (sp,ii,jj, 7)*cuv;
  	    Phi2n += coeff (sp,ii,jj, 8)*cuv;
  	    zeta += coeff (sp,ii,jj, 9)*cuv;
  	  }
  	}

  	/* Lame coefficients squared */
  	gdouble h1_2 = xu.x*xu.x + xu.y*xu.y + xu.z*xu.z;
  	gdouble h2_2 = xv.x*xv.x + xv.y*xv.y + xv.z*xv.z;

	/* Normal */
  	Vector N = g_array_index (gp->Ni, Vector, m+n*ng);
	
  	// ?? Not quite implicit because the normal part of the gradient
  	gdouble rhsmn = /* 0.5*vector_scalar_product (&fsd.gradphi0,&fsd.gradphi0) - sim->g*fsd.zeta0 */
  	  /* + 0.5*vector_scalar_product (&fsd.gradphi,&fsd.gradphi) */ - sim->g*zeta
  	  + 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi)
  	  /* - fsd.dtphi0 - fsd.dtPhi - fsd.dtphi */;
	
  	W.x -= fsd.gradPhi.x;
  	W.y -= fsd.gradPhi.y;
  	W.z -= fsd.gradPhi.z;
  	rhsmn += vector_scalar_product (&W,&fsd.gradPhi);

  	/* W.x -= fsd.gradphi.x; */
  	/* W.y -= fsd.gradphi.y; */
  	/* W.z -= fsd.gradphi.z; */
  	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi); */

  	/* W.x -= fsd.gradphi0.x; */
  	/* W.y -= fsd.gradphi0.y; */
  	/* W.z -= fsd.gradphi0.z; */
  	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi0); */

  	/* // Weakly scattered terms */
  	/* /\* rhsmn += zeta * ( vector_scalar_product (&W,&fsd.graddzPhi) *\/ */
  	/* /\* 		  + vector_scalar_product (&W,&fsd.graddzphi) *\/ */
  	/* /\* 		  + vector_scalar_product (&W,&fsd.graddzphi0) *\/ */
  	/* /\* 		  - fsd.dtdzPhi - fsd.dtdzphi - fsd.dtdzphi0); *\/ */

  	rhsmn *= sim->time.dt;

  	rhsmn = 0.;

	Point p = g_array_index (gp->Pi, Point, m+n*ng);

	W.x = -p.y;
	W.y = p.x;
	W.z = 0.;

  	xu.x /= h1_2; xu.y /= h1_2; xu.z /= h1_2;
  	xv.x /= h2_2; xv.y /= h2_2; xv.z /= h2_2;

	gdouble term1 = sim->time.dt*vector_scalar_product (&W,&xu);
	gdouble term2 = sim->time.dt*vector_scalar_product (&W,&xv);
	// Phi2n = -Phi0n
  	gdouble term3 = -sim->time.dt*Phi2n*vector_scalar_product (&W,&N);

	//	rhsmn += sim->time.dt*0.5*vector_scalar_product(&W,&fsd.gradPhi2) + term3;
	rhsmn += term3;

	// Loop over the splines whose support is included in the panel
	for ( i = ustart; i < ustart + sp->k; i++) {
	  gdouble wmni = wmn*gsl_matrix_get(Bu, i-ustart, 0);
	  for ( j = vstart; j < vstart + sp->k; j++) {
	    gdouble wmnij = wmni*gsl_matrix_get(Bv, j-vstart, 0);
	    gint indexi = i + j*gsl_bspline_ncoeffs (sp->w_u);

	    for ( a = 0; a < sp->k; a++) {
	      gdouble wmnija = wmnij*gsl_matrix_get(Bu, a, 0);
	      for ( b = 0; b < sp->k; b++) {
		A0[indexi][(ustart+a) + (vstart+b)*gsl_bspline_ncoeffs (sp->w_u)]
		  +=  wmnij*(gsl_matrix_get(Bu, a, 0)*gsl_matrix_get(Bv, b, 0) + term1*gsl_matrix_get(Bu, a, 1)*gsl_matrix_get(Bv, b, 0)
			     + term2*gsl_matrix_get(Bu, a, 0)*gsl_matrix_get(Bv, b, 1));
		
	      }
	    }

	    
	    RHS[indexi] += wmnij*(Phi2 + rhsmn);
	  }
	}
	
      }
    }
    
  }

  /* // Loop over the panels of the patch */
  /* for ( ii = 0; ii < sp->M*sp->N; ii++) { */
  /*   SPPanel * spp = g_ptr_array_index (sp->panels, ii); */
  /*   g_assert (spp != NULL); */
     	
  /*   // Gauss outer-integration */
  /*   GaussPoints * gp = spp->outer; */
  /*   gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule */
  /*   gint ustart = gp->istart; */
  /*   gint vstart = gp->jstart; */

  /*   for ( m = 0; m < ng; m++) { */
  /*     gdouble um = g_array_index (gp->ui, gdouble, m); */
  /*     gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m); */
	  
  /*     for ( n = 0; n < ng; n++) { */
  /* 	gdouble vn = g_array_index (gp->vj, gdouble, n);	     */
  /* 	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng); */
  /* 	Point p = g_array_index (gp->Pi, Point, m+n*ng); */
  /* 	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n); */
  	/* FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng); */

  	/* // Calculate W at point (um, vn) */
  	/* Vector W = sim->U; */
  	/* gint  i, j; */
  	/* Vector xu, xv; */
  	/* gdouble zeta, Phi2, Phi2n; */
  	/* xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.; */
  	/* zeta = Phi2 = Phi2n = 0.; */

  	/* for ( i = 0; i < sp->k; i++) { */
  	/*   gdouble cu = gsl_matrix_get (Bu, i, 0); */
  	/*   gdouble cdu = gsl_matrix_get (Bu, i, 1); */
  	/*   for ( j = 0; j < sp->k; j++) { */
  	/*     gdouble cv = gsl_matrix_get (Bv, j, 0); */
  	/*     gdouble cudv = cu*gsl_matrix_get (Bv, j, 1); */
  	/*     gdouble cvdu = cv*cdu; */
  	/*     gdouble cuv = cu*cv; */
  	/*     xu.x += coeff (sp,ustart+i,vstart+j, 0)*cvdu; */
  	/*     xu.y += coeff (sp,ustart+i,vstart+j, 1)*cvdu; */
  	/*     xu.z += coeff (sp,ustart+i,vstart+j, 2)*cvdu; */
  	/*     xv.x += coeff (sp,ustart+i,vstart+j, 0)*cudv; */
  	/*     xv.y += coeff (sp,ustart+i,vstart+j, 1)*cudv; */
  	/*     xv.z += coeff (sp,ustart+i,vstart+j, 2)*cudv; */
  	/*     Phi2 += coeff (sp,ustart+i,vstart+j, 7)*cuv; */
  	/*     Phi2n += coeff (sp,ustart+i,vstart+j, 8)*cuv; */
  	/*     zeta += coeff (sp,ustart+i,vstart+j, 9)*cuv; */
  	/*   } */
  	/* } */

  	/* /\* Lame coefficients squared *\/ */
  	/* gdouble h1_2 = xu.x*xu.x + xu.y*xu.y + xu.z*xu.z; */
  	/* gdouble h2_2 = xv.x*xv.x + xv.y*xv.y + xv.z*xv.z; */

  	/* /\* Precalculate coefficients *\/ */
  	/* gdouble c1 = xu.x/h1_2; */
  	/* gdouble c2 = xv.x/h2_2; */
  	/* gdouble c3 = xu.y/h1_2; */
  	/* gdouble c4 = xv.y/h2_2; */
  	/* gdouble c5 = xu.z/h1_2; */
  	/* gdouble c6 = xv.z/h2_2; */

  	/* Vector N = g_array_index (gp->Ni, Vector, m+n*ng); */
	
  	/* // ?? Not quite implicit because the normal part of the gradient */
  	/* gdouble rhsmn = /\* 0.5*vector_scalar_product (&fsd.gradphi0,&fsd.gradphi0) - sim->g*fsd.zeta0 *\/ */
  	/*   /\* + 0.5*vector_scalar_product (&fsd.gradphi,&fsd.gradphi) *\/ - sim->g*zeta */
  	/*   + 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi) */
  	/*   /\* - fsd.dtphi0 - fsd.dtPhi - fsd.dtphi *\/; */
	
  	/* W.x -= fsd.gradPhi.x; */
  	/* W.y -= fsd.gradPhi.y; */
  	/* W.z -= fsd.gradPhi.z; */
  	/* rhsmn += vector_scalar_product (&W,&fsd.gradPhi); */

  	/* /\* W.x -= fsd.gradphi.x; *\/ */
  	/* /\* W.y -= fsd.gradphi.y; *\/ */
  	/* /\* W.z -= fsd.gradphi.z; *\/ */
  	/* /\* rhsmn += vector_scalar_product (&W,&fsd.gradphi); *\/ */

  	/* /\* W.x -= fsd.gradphi0.x; *\/ */
  	/* /\* W.y -= fsd.gradphi0.y; *\/ */
  	/* /\* W.z -= fsd.gradphi0.z; *\/ */
  	/* /\* rhsmn += vector_scalar_product (&W,&fsd.gradphi0); *\/ */

  	/* /\* // Weakly scattered terms *\/ */
  	/* /\* /\\* rhsmn += zeta * ( vector_scalar_product (&W,&fsd.graddzPhi) *\\/ *\/ */
  	/* /\* /\\* 		  + vector_scalar_product (&W,&fsd.graddzphi) *\\/ *\/ */
  	/* /\* /\\* 		  + vector_scalar_product (&W,&fsd.graddzphi0) *\\/ *\/ */
  	/* /\* /\\* 		  - fsd.dtdzPhi - fsd.dtdzphi - fsd.dtdzphi0); *\\/ *\/ */

  	/* rhsmn *= sim->time.dt; */
  	/* rhsmn = 0.; W = sim->U; */
  	/* /\* gdouble sign = -1.; *\/ */
  	/* gdouble term1 = -sim->time.dt*(c1*W.x + c3*W.y + c5*W.z)*wmn; */
  	/* gdouble term2 = -sim->time.dt*(c2*W.x + c4*W.y + c6*W.z)*wmn; */

  	/* // Phi2n = -Phi0n */
  	/* gdouble term3 = sim->time.dt*Phi2n*vector_scalar_product (&W,&N)*wmn; */

  	/* xu.x /= h1_2; xu.y /= h1_2; xu.z /= h1_2; */
  	/* xv.x /= h2_2; xv.y /= h2_2; xv.z /= h2_2; */
	
	
  /* 	// Loop over the splines whose support is included in the panel */
  /* 	for ( i = ustart; i < ustart + sp->k; i++) { */
  /* 	  gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0); */
  /* 	  /\* gdouble term1 = gsl_matrix_get (Bu, i-ustart, 0); *\/ */
  /* 	  /\* gdouble term2 = vector_scalar_product (&W,&xu)*gsl_matrix_get (Bu, i-ustart, 1); *\/ */
  /* 	  /\* gdouble term3 = vector_scalar_product (&W,&xv)*gsl_matrix_get (Bu, i-ustart, 0); *\/ */
  /* 	  gdouble term1i = term1*gsl_matrix_get (Bu, i-ustart, 1); */
  /* 	  gdouble term2i = term2*gsl_matrix_get (Bu, i-ustart, 0); */
  /* 	  gdouble term3i = term3*gsl_matrix_get (Bu, i-ustart, 0); */
	  
  /* 	  //  gdouble term3i = term3*gsl_matrix_get (Bu, i-ustart, 0); */
	  
  /* 	  for ( j = vstart; j < vstart + sp->k; j++) { */
  /* 	    gint indexi = i + j*gsl_bspline_ncoeffs (sp->w_u); */
  /* 	    gdouble wmnij = wmni*gsl_matrix_get(Bv, j-vstart, 0) */
  /* 	      + term1i*gsl_matrix_get(Bv, j-vstart, 0) */
  /* 	      + term2i*gsl_matrix_get(Bv, j-vstart, 1); */
  /* 	    //gdouble wmnij = wmn*(term1*gsl_matrix_get(Bv, j-vstart, 0) + term2*gsl_matrix_get(Bv, j-vstart, 0) + term3*gsl_matrix_get(Bv, j-vstart, 1)); */

  /* 	    for ( a = 0; a < sp->k; a++) { */
  /* 	      gdouble wmnija = wmnij*gsl_matrix_get(Bu, a, 0); */
  /* 	      for ( b = 0; b < sp->k; b++) { */
  /* 		A0[(ustart+a) + (vstart+b)*gsl_bspline_ncoeffs (sp->w_u)][indexi] +=  wmnija*gsl_matrix_get(Bv, b, 0); */
  /* 	      } */
  /* 	    } */

  /* 	    RHS[indexi] += (wmni*(Phi2 + rhsmn) /\* + term3i *\/)*gsl_matrix_get (Bv, j-vstart, 0); */
  /* 	  } */
  /* 	} */


	
  /*     } */
  /*   } */
    
  /* }  */


  /* Storage in Compressed Column Storage (CCS) format for superlu */
  CCSProblem * ccs = ccs_problem_new ();
  gsl_vector * gsl_rhs = gsl_vector_alloc (size);
  gint count = 0;
  for ( i = 0; i < size; i++) {
    g_array_append_val (ccs->index, count);
    for ( j = 0; j < size; j++) {
      if (A0[i][j] != 0.) {
  	g_array_append_val (ccs->matrix, A0[i][j]);
  	g_array_append_val (ccs->column, j);
  	count++;
      }
    }
    gsl_vector_set (gsl_rhs, i, RHS[i]);
  }
  g_array_append_val (ccs->index, count);

  /* Solve the problem using superlu */
  ccs_problem_lu_solve (ccs, gsl_rhs);

  /* Copy the solution to the patch */
  for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) {
    for ( j = 0; j < gsl_bspline_ncoeffs (sp->w_v); j++) {
      coeff_assign (sp, i, j, 7, gsl_vector_get (gsl_rhs, i + j*gsl_bspline_ncoeffs (sp->w_u)));
    }
  }

  ccs_problem_destroy (ccs);
  
  /* Stop timer and print */
  fprintf (stdout, "   Free-surface disturbance potential update: %f \n", g_test_timer_elapsed());
}

// Works for periodical patch
static void semi_implicit_free_surface_disturbance_potential_update (Simulation * sim, gdouble t, gboolean prediction)
{
  /* Start timer */
  //  g_test_timer_start ();
  Spline2D * splines = sim->fs->s->patches->data;
  gint NV = splines->NV; // Should be the same for all the splines of fs
  gint NU = splines->periodic ? splines->NUT : splines->NU;
  gint NUT = splines->periodic ? splines->NUT : splines->NU;

  gint size = NU*NV;
  gdouble A0[size][size];
  gdouble RHS[size];
  gint i, j, m, n, ii, a, b;

  g_assert (splines != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
    for ( j = 0; j < size; j++) {
      A0[i][j] = 0.;
    }
  }

  Spline2D * sp = splines;
  gsl_matrix * Bu, * Bv;
  gint ustart, vstart;
  gint istart, jstart;
  sp = splines;
  while (sp) {// Loop over the spline patches
    // Loop over the panels of the patch
    for ( ii = 0; ii < sp->M*sp->N; ii++) {
      SPPanel * spp = g_ptr_array_index (sp->panels, ii);
      g_assert (spp != NULL);
     	
      // Gauss outer-integration
      GaussPoints * gp = spp->outer;
      gint ng = sp->nouter; // Order of outer Gauss-Legendre rule
      ustart = sp->periodic ? 
	gp->istart + sp->fs_index - sp->k + 1 :
	gp->istart;
      istart = sp->periodic ? 
	gp->istart - sp->k + 1 :
	gp->istart;
      vstart = gp->jstart;

      for ( m = 0; m < ng; m++) {
	Bu = g_ptr_array_index (gp->Bu, m);
	  
	for ( n = 0; n < ng; n++) {
	  Bv = g_ptr_array_index (gp->Bv, n);
	  gint gindex = m+n*ng;
	  gdouble wmn = g_array_index (gp->wJij, gdouble, gindex);
	  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);
	  Point p = g_array_index (gp->Pi, Point, gindex);
	  Vector N = g_array_index (gp->Ni, Vector, gindex);
	  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
	  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
	  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
	  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
	  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
	  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);

	  // Calculate W at point (um, vn)
	  Vector W = sim->U;
	  gint  i, j, i2, j2;
	  gdouble Vn = 0., dvardu = 0., dvardv = 0.;
	  gdouble Phid = 0., zeta1 = 0., zeta0 = 0.;


	  for ( i = 0; i < sp->k; i++) {
	    gdouble cu = gsl_matrix_get (Bu, i, 0);
	    gdouble cdu = gsl_matrix_get (Bu, i, 1);
	    i2 = (istart+i);
	    for ( j = 0; j < sp->k; j++) {
	      gdouble cv = gsl_matrix_get (Bv, j, 0);
	      gdouble cdv = gsl_matrix_get (Bv, j, 1);
	      gdouble cudv = cu*cdv;
	      gdouble cvdu = cv*cdu;
	      gdouble cuv = cu*cv;
	      j2 = (vstart+j);

	      SplineCoeffs * sc;
	      if (sp->periodic)
		sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU+sp->k-1));
	      else
		sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU));

	      /* dvardu += sc->v[7]*cvdu; */
	      /* dvardv += sc->v[7]*cudv; */
	      /* Vn += sc->v[8]*cu*cv; */
	      dvardu += sc->v[23]*cvdu;
	      dvardv += sc->v[23]*cudv;
	      Vn += sc->v[30]*cu*cv;

	      Phid += sc->v[23]*cuv;
	      zeta1 += sc->v[9]*cuv; // Thats zeta at t(n+1)
	      zeta0 += sc->v[18]*cuv;
	    }
	  }

	  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p, sim->time.t+0.5*sim->time.dt);
	  Vector gradphi; /* = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7); */

	  gradphi.x = c1*dvardu + c2*dvardv + Vn*N.x;
	  gradphi.y = c3*dvardu + c4*dvardv + Vn*N.y;
	  gradphi.z = c5*dvardu + c6*dvardv + Vn*N.z;

#if 1	
	  gdouble rhsmn = /* -fsd.dtPhi */ - sim->g*0.5*(zeta1+zeta0) + vector_scalar_product (&W,&fsd.gradPhi)
	    - 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi);

	  W.x -= fsd.gradPhi.x;
	  W.y -= fsd.gradPhi.y;
	  W.z -= fsd.gradPhi.z;

	  rhsmn += vector_scalar_product (&W, &gradphi0);
#endif
	  rhsmn *= sim->time.dt;

	  gdouble term1 = sim->beta*sim->time.dt*(W.x*c1 + W.y*c3);
	  gdouble term2 = sim->beta*sim->time.dt*(W.x*c2 + W.y*c4);
	  // Phi2n = -Phi0n
	  gdouble term3 = 0.;

	  rhsmn += sim->time.dt*(1.-sim->beta)*vector_scalar_product(&W,&gradphi) + term3;

	  // Loop over the splines whose support is included in the panel
	  for ( i = ustart; i < ustart + sp->k; i++) {
	    gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	    gint indexi = i % NUT;
	    for ( j = vstart; j < vstart + sp->k; j++) {
	      gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	      gint indexij = indexi + j*NUT;
	      
	      for ( a = 0; a < sp->k; a++) {
		gdouble wmnija = wmnij*gsl_matrix_get (Bu, a, 0);
		gint indexa = (ustart + a)%NUT;
		for ( b = 0; b < sp->k; b++) {
		  A0[indexij][indexa + (vstart+b)*NUT] +=  wmnija*gsl_matrix_get(Bv, b, 0)
		    + wmnij*term1*gsl_matrix_get(Bu, a, 1)*gsl_matrix_get(Bv, b, 0)
		    + wmnija*term2*gsl_matrix_get(Bv, b, 1);
		}
	      }

	      RHS[indexij] += wmnij*(Phid + rhsmn);
	    }
	  }
	
	}
      }
    }
    sp = sp->next;
  }

/* /\* #ifdef NO_FLUX *\/ */
/*   // On the solid boundary dn phi = - dn phi0 */
/*   // For now, dn phi = 0 i.e. dv phi = 0 */
/*   size_t ustart, uend, vstart, vend; */
/*   gsl_vector * Bu = gsl_vector_alloc (sp->k); */
/*   gsl_matrix * Bv = gsl_matrix_alloc (sp->k, 2); */
/*   for ( i = 0; i < NU; i++) { */
/*     gint index1 = i; */
/*     gdouble u = gsl_bspline_greville_abscissa (i, sp->w_u); */
/*     gdouble v = 0.; */

/*     for ( j = 0; j < size; j++) */
/*       A0[j][index1] = 0.; */

/*     Vector xv; */
/*     xv.x = spline2d_derivative_eval (sp, u, v, 0, 1, 0); */
/*     xv.y = spline2d_derivative_eval (sp, u, v, 0, 1, 1); */
/*     xv.z = spline2d_derivative_eval (sp, u, v, 0, 1, 2); */

/*     xv = vector_normalise (xv); */

/*     gsl_bspline_eval_nonzero (u, Bu, &ustart, &uend, sp->w_u); */
/*     gsl_bspline_deriv_eval_nonzero (v, 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v); */

/*     for ( m = 0; m < sp->k; m++) { */
/*       gdouble cu = gsl_vector_get (Bu, m); */
/*       for ( n = 0; n < sp->k; n++) { */
/*     	gdouble cv = gsl_matrix_get (Bv, n, 1); */
/* 	A0[ustart+m + (vstart+n)*NU][index1] = cu*cv; */
/*       } */
/*     }/\* #ifdef NO_FLUX *\/ */
/*   // On the solid boundary dn phi = - dn phi0 */
/*   // For now, dn phi = 0 i.e. dv phi = 0 */
/*   size_t ustart, uend, vstart, vend; */
/*   gsl_vector * Bu = gsl_vector_alloc (sp->k); */
/*   gsl_matrix * Bv = gsl_matrix_alloc (sp->k, 2); */
/*   for ( i = 0; i < NU; i++) { */
/*     gint index1 = i; */
/*     gdouble u = gsl_bspline_greville_abscissa (i, sp->w_u); */
/*     gdouble v = 0.; */

/*     for ( j = 0; j < size; j++) */
/*       A0[j][index1] = 0.; */

/*     Vector xv; */
/*     xv.x = spline2d_derivative_eval (sp, u, v, 0, 1, 0); */
/*     xv.y = spline2d_derivative_eval (sp, u, v, 0, 1, 1); */
/*     xv.z = spline2d_derivative_eval (sp, u, v, 0, 1, 2); */

/*     xv = vector_normalise (xv); */

/*     gsl_bspline_eval_nonzero (u, Bu, &ustart, &uend, sp->w_u); */
/*     gsl_bspline_deriv_eval_nonzero (v, 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v); */

/*     for ( m = 0; m < sp->k; m++) { */
/*       gdouble cu = gsl_vector_get (Bu, m); */
/*       for ( n = 0; n < sp->k; n++) { */
/*     	gdouble cv = gsl_matrix_get (Bv, n, 1); */
/* 	A0[ustart+m + (vstart+n)*NU][index1] = cu*cv; */
/*       } */
/*     } */
    
/*     RHS[index1] = 0.; */
/*   } */
/*   gsl_vector_free (Bu); */
/*   gsl_matrix_free (Bv); */
/* #endif */

/*   // Continuity of variable on boundary */
/*   for ( i = 0; i < NV; i++) { */
/*     gint index1 = (i+1)*NU - 1; */
/*     gint index2 = i*NU; */
    
/*     for ( j = 0; j < size; j++) */
/*       A0[j][index1] += A0[j][index2]; */

/*     for ( j = 0; j < size; j++) */
/*       A0[j][index2] = 0.; */

/*     A0[index1][index2] = 1.; */
/*     A0[index2][index2] = -1.; */

/*     RHS[index1] += RHS[index2]; */
/*     RHS[index2] = 0.; */
/*   } */
    
/*     RHS[index1] = 0.; */
/*   } */
/*   gsl_vector_free (Bu); */
/*   gsl_matrix_free (Bv); */
/* /\* #endif *\/ */

/*   // Continuity of variable on boundary */
/*   for ( i = 0; i < NV; i++) { */
/*     gint index1 = (i+1)*NU - 1; */
/*     gint index2 = i*NU; */
    
/*     for ( j = 0; j < size; j++) */
/*       A0[j][index1] += A0[j][index2]; */

/*     for ( j = 0; j < size; j++) */
/*       A0[j][index2] = 0.; */

/*     A0[index1][index2] = 1.; */
/*     A0[index2][index2] = -1.; */

/*     RHS[index1] += RHS[index2]; */
/*     RHS[index2] = 0.; */
/*   } */

#if 0
  // On the solid boundary dn phi = - dn phi0
  // For now, dn phi = 0 i.e. dv phi = 0
  sp = splines;
  while (sp) {
    size_t ustart, uend, vstart, vend;
    gsl_vector * Bu2 = gsl_vector_alloc (sp->k);
    Bv = gsl_matrix_alloc (sp->k, 2);
    GrevillePoints * gr = sp->gr;
    for ( i = 0; i < sp->NU; i++) {
      gint index1 = sp->fs_index + i;
      gdouble u = g_array_index (gr->ui, gdouble, i);
      gdouble v = 0.;
      
      RHS[index1] = 0.;

      for ( j = 0; j < size; j++)
	A0[j][index1] = 0.;

      gsl_bspline_eval_nonzero (MIN(1.-1e-12,u), Bu2, &ustart, &uend, sp->w_u);
      gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,v), 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v);

      for ( m = 0; m < sp->k; m++) {
	gdouble cu = gsl_vector_get (Bu2, m);
	for ( n = 0; n < sp->k; n++) {
	  gdouble cv = gsl_matrix_get (Bv, n, 1);
	  A0[(sp->fs_index+ustart+m - sp->k +1)%NUT + (vstart+n)*NUT][index1] = cu*cv;
	}
      }
    }
    gsl_vector_free (Bu2);
    gsl_matrix_free (Bv);
    sp = sp->next;
  }
#endif

  /* Storage in Compressed Column Storage (CCS) format for superlu */
  CCSProblem * ccs = ccs_problem_new ();
  splines->rhs = splines->rhs_vector (splines, splines->rhs);
  gint count = 0;
  for ( i = 0; i < size; i++) {
    g_array_append_val (ccs->index, count);
    for ( j = 0; j < size; j++) {
      if (A0[i][j] != 0.) {
  	g_array_append_val (ccs->matrix, A0[i][j]);
  	g_array_append_val (ccs->column, j);
  	count++;
      }
    }
    gsl_vector_set (splines->rhs, i, RHS[i]);
  }
  g_array_append_val (ccs->index, count);

  /* Solve the problem using superlu */
  ccs_problem_lu_solve (ccs, splines->rhs);
  splines->copy_fit_solution (splines, splines->rhs, 7);

  ccs_problem_destroy (ccs);
  
  /* Stop timer and print */
  //fprintf (stdout, "   Free-surface disturbance potential update: %f \n", g_test_timer_elapsed());
}

void semi_test (Simulation * sim)
{
  gint i, j, m, n, ii, a, b;

  Spline2D * splines = sim->fs->s->patches->data;

  gint NV = splines->NV; // Should be the same for all the splines

  Spline2D * sp = splines;
  // Find the total number of coeffs in direction u
  // and number the spline patches
  gint NUT = 0;
  while (sp) {
    sp->fs_index = NUT;
    NUT += sp->NU;
    sp = sp->next;
  }
  
  gint size = NUT*NV;
  gdouble A0[size][size];
  gdouble RHS[size];

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    for ( j = 0; j < size; j++) {
      A0[i][j] = 0.;
    }
    RHS[i] = 0.;
  }

  gsl_matrix * Bu, * Bv, * Bux;
  gint ustart, vstart, ustart_x;
  gint istart, jstart, istart_x;
  sp = splines;
  while (sp) {// Loop over the spline patches
    // Loop over the panels of the patch
    for ( ii = 0; ii < sp->M*sp->N; ii++) {
      SPPanel * spp = g_ptr_array_index (sp->panels, ii);
      g_assert (spp != NULL);
     	
      // Gauss outer-integration
      GaussPoints * gp = spp->outer;
      gint ng = sp->nouter; // Order of outer Gauss-Legendre rule
      ustart = sp->periodic ? 
	gp->istart + sp->fs_index - sp->k + 1 :
	gp->istart;
      vstart = gp->jstart;
      istart = sp->periodic ? 
	gp->istart - sp->k + 1 :
	gp->istart;
      ustart_x = gp->istart_x;
      jstart = gp->jstart;
      for ( m = 0; m < ng; m++) {
	Bu = g_ptr_array_index (gp->Bu, m);
	Bux = g_ptr_array_index (gp->Bux, m);
	  
	for ( n = 0; n < ng; n++) {
	  Bv = g_ptr_array_index (gp->Bv, n);
	  gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	  FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);

	  Vector W = sim->U;
	  gint  i, j, i2, j2, ix, jx;
	  Vector xu, xv;
	  gdouble zeta, Phi2, Phi2n, dvardu, dvardv;
	  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
	  zeta = Phi2 = Phi2n = dvardu = dvardv = 0.;

	  gdouble Phid, zeta1, zeta0;
	  Phid = zeta1 = zeta0 = 0.;
	  
	  for ( i = 0; i < sp->k; i++) {
	    gdouble cu = gsl_matrix_get (Bu, i, 0);
	    gdouble cdu = gsl_matrix_get (Bu, i, 1);
	    gdouble cux = gsl_matrix_get (Bux, i, 0);
	    gdouble cdux = gsl_matrix_get (Bux, i, 1);
	    i2 = (istart+i);
	    ix = (ustart_x +i);
	    for ( j = 0; j < sp->k; j++) {
	      gdouble cv = gsl_matrix_get (Bv, j, 0);
	      gdouble cdv = gsl_matrix_get (Bv, j, 1);
	      gdouble cudv = cu*cdv;
	      gdouble cvdu = cv*cdu;
	      gdouble cuv = cu*cv;
	      gdouble cudvx = cux*cdv;
	      gdouble cvdux = cv*cdux;
	      j2 = (jstart+j);

	      SplineCoeffs * sc;
	      /* if (sp->periodic) */
	      /* 	sc = g_ptr_array_index (sp->coeffs, ix+ j2*(sp->NU+sp->k-1)); */
	      /* else */
	  	sc = g_ptr_array_index (sp->coeffs, ix+ j2*(sp->NXU));

	      xu.x += sc->v[0]*cvdux;
	      xu.y += sc->v[1]*cvdux;
	      xu.z += sc->v[2]*cvdux;
	      xv.x += sc->v[0]*cudvx;
	      xv.y += sc->v[1]*cudvx;
	      xv.z += sc->v[2]*cudvx;

	      if (sp->periodic)
	  	sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU+sp->k-1));
	      else
	  	sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU));

	      dvardu += sc->v[7]*cvdu;
	      dvardv += sc->v[7]*cudv;

	      Phid += sc->v[23]*cuv;
	      zeta1 += sc->v[9]*cuv; // Thats zeta at t(n+1)
	      zeta0 += sc->v[18]*cuv;
	    }
	  }

	   zeta = (zeta1+zeta0)*0.5;

	  gdouble detinv = 1./(xu.x*xv.y-xu.y*xv.x);

#if 1	
	  gdouble rhsmn = -fsd.dtPhi - sim->g*zeta + vector_scalar_product (&W,&fsd.gradPhi)
	    - 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi);

	  W.x -= fsd.gradPhi.x;
	  W.y -= fsd.gradPhi.y;
	  W.z -= fsd.gradPhi.z;

	  rhsmn += vector_scalar_product (&W,&fsd.gradphi0)
	    + vector_scalar_product (&W,&fsd.gradphi);
#endif
	  rhsmn *= sim->time.dt;

	  gdouble term1 = sim->beta*sim->time.dt*(W.x*xv.y - W.y*xv.x)*detinv;
	  gdouble term2 = sim->beta*sim->time.dt*(-W.x*xu.y + W.y*xu.x)*detinv;
	  // Phi2n = -Phi0n
	  gdouble term3 = 0.;

	  rhsmn += sim->time.dt*(1.-sim->beta)*vector_scalar_product(&W,&fsd.gradPhi2) + term3;



	  // Loop over the splines whose support is included in the panel
	  for ( i = ustart; i < ustart + sp->k; i++) {
	    gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	    gint indexi = i % NUT;
	    for ( j = vstart; j < vstart + sp->k; j++) {
	      gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	      gint indexij = indexi + j*NUT;
	      
	      for ( a = 0; a < sp->k; a++) {
		gdouble wmnija = wmnij*gsl_matrix_get (Bu, a, 0);
		gint indexa = (ustart + a)%NUT;
		for ( b = 0; b < sp->k; b++) {
		  /* A0[indexij][indexa + (vstart+b)*NUT] +=  wmnija*gsl_matrix_get(Bv, b, 0); */
		  A0[indexij][indexa + (vstart+b)*NUT] +=  wmnija*gsl_matrix_get(Bv, b, 0)
		    + wmnij*term1*gsl_matrix_get(Bu, a, 1)*gsl_matrix_get(Bv, b, 0)
		    + wmnija*term2*gsl_matrix_get(Bv, b, 1);
		}
	      }
	      RHS[indexij] += wmnij*(Phid + rhsmn);
	    }
	  }
	
	}
      }
    }
    sp = sp->next;
  }

  
  /* FILE * fp = fopen ("fit.tmp","w"); */
  CCSProblem * fit = ccs_problem_new ();
  gsl_vector * gsl_rhs = gsl_vector_alloc (size);
  gint count = 0;
  for ( i = 0; i < size; i++) {
    g_array_append_val (fit->index, count);
    for ( j = 0; j < size; j++) {
      /* fprintf(fp,"%i %i %f\n", i, j, A0[i][j]); */
      if (A0[i][j] != 0.) {
  	g_array_append_val (fit->matrix, A0[i][j]);
  	g_array_append_val (fit->column, j);
  	count++;
      }
      gsl_vector_set (gsl_rhs, i, RHS[i]);
    }
    /* fprintf (fp, "\n"); */
  }
  g_array_append_val (fit->index, count);
  /* fclose (fp); */

  /* Solve the problem using superlu */
  ccs_problem_lu_solve (fit, gsl_rhs);
  splines->copy_fit_solution (splines, gsl_rhs, 7);

  ccs_problem_destroy (fit);
  gsl_vector_free (gsl_rhs);
}

static void semi_implicit_free_surface_disturbance_potential_update_periodic (Simulation * sim, gdouble t, gboolean prediction)
{
  /* Start timer */
  g_test_timer_start ();
  Spline2D * sp = sim->fs->s->patches->data;
  gint NU = sp->NU;
  gint NV = sp->NV;
  gint size = NU*NV;
  gdouble A0[size][size];
  gdouble RHS[size];
  gint i, j, m, n, pp, a, b;

  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
    for ( j = 0; j < size; j++) {
      A0[i][j] = 0.;
    }
  }

  gsl_matrix * Bu, * Bv;
  // Loop over the panels of the patch
  for ( pp = 0; pp < sp->M*sp->N; pp++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, pp);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    gint ustart = gp->istart;
    if (sp->periodic)
      ustart -= sp->k-1;
    gint vstart = gp->jstart;

    for ( m = 0; m < ng; m++) {
      Bu = g_ptr_array_index (gp->Bu, m);
      	  
      for ( n = 0; n < ng; n++) {
	gint gindex = m+n*ng;
	gdouble wmn = g_array_index (gp->wJij, gdouble, gindex);
	Bv = g_ptr_array_index (gp->Bv, n);
	FSData fsd = g_array_index (gp->fsdata, FSData, gindex);
	Vector N = g_array_index (gp->Ni, Vector, gindex);
	gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
	gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
	gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
	gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
	gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
	gdouble c6 = g_array_index (gp->c6, gdouble, gindex);

  	// Calculate W at point (um, vn)
  	Vector W = sim->U;
  	gint  ii, jj;
  	gdouble zeta, Phi2, Phi2n;
  	zeta = Phi2 = Phi2n = 0.;

  	for ( i = 0; i < sp->k; i++) {
  	  gdouble cu = gsl_matrix_get (Bu, i, 0);
  	  gdouble cdu = gsl_matrix_get (Bu, i, 1);
	  ii = (ustart+i);
  	  for ( j = 0; j < sp->k; j++) {
  	    gdouble cv = gsl_matrix_get (Bv, j, 0);
  	    gdouble cudv = cu*gsl_matrix_get (Bv, j, 1);
  	    gdouble cvdu = cv*cdu;
  	    gdouble cuv = cu*cv;
	    jj = (vstart+j);

  	    Phi2 += coeff (sp,ii,jj, 7)*cuv;
  	    Phi2n += coeff (sp,ii,jj, 8)*cuv;
  	    zeta += coeff (sp,ii,jj, 9)*cuv;
  	  }
  	}

	//	gdouble detinv = 1./(xu.x*xv.y-xu.y*xv.x);

	/* Linear */

	gdouble rhsmn = - fsd.dtPhi
	  - sim->g*zeta
	  - 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi)
	  + 0.5*vector_scalar_product (&W,&fsd.gradPhi);

	W.x -= fsd.gradPhi.x;
  	W.y -= fsd.gradPhi.y;
  	W.z -= fsd.gradPhi.z;

	rhsmn += vector_scalar_product (&W,&fsd.gradphi0)
	  + vector_scalar_product (&W,&fsd.gradphi);

	
	  
	  
	/* Weak-scatter */
	
  	// ?? Not quite implicit because the normal part of the gradient
  	/* gdouble rhsmn = */
	/*   /\* 0.5*vector_scalar_product (&fsd.gradphi0,&fsd.gradphi0) *\/ */
	/*   /\* - sim->g*fsd.zeta0 *\/ */
  	/*   /\* + 0.5*vector_scalar_product (&fsd.gradphi,&fsd.gradphi) *\/ */
	/*   - sim->g*zeta */
  	/*   - 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi) */
  	/*   /\* - fsd.dtphi0 - fsd.dtPhi - fsd.dtphi *\/; */
	
  	/* W.x -= fsd.gradPhi.x; */
  	/* W.y -= fsd.gradPhi.y; */
  	/* W.z -= fsd.gradPhi.z; */
  	/* rhsmn += vector_scalar_product (&W,&fsd.gradPhi); */

  	/* W.x -= fsd.gradphi.x; */
  	/* W.y -= fsd.gradphi.y; */
  	/* W.z -= fsd.gradphi.z; */
  	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi); */

  	/* W.x -= fsd.gradphi0.x; */
  	/* W.y -= fsd.gradphi0.y; */
  	/* W.z -= fsd.gradphi0.z; */
  	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi0); */

  	/* // Weakly scattered terms */
  	/* /\* rhsmn += zeta * ( vector_scalar_product (&W,&fsd.graddzPhi) *\/ */
  	/* /\* 		  + vector_scalar_product (&W,&fsd.graddzphi) *\/ */
  	/* /\* 		  + vector_scalar_product (&W,&fsd.graddzphi0) *\/ */
  	/* /\* 		  - fsd.dtdzPhi - fsd.dtdzphi - fsd.dtdzphi0); *\/ */

  	rhsmn *= sim->time.dt;

	/* */ 

	/* rhsmn = 0.; */
	/* Point p = g_array_index (gp->Pi, Point, m + n*ng); */
	/* W.x = -p.y; */
	/* W.y = p.x; */
	/* W.z = 0.; */

  	/* xu.x /= h1_2; xu.y /= h1_2; xu.z /= h1_2; */
  	/* xv.x /= h2_2; xv.y /= h2_2; xv.z /= h2_2; */

	/* gdouble term1 = sim->beta*sim->time.dt*vector_scalar_product (&W,&xu); */
	/* gdouble term2 = sim->beta*sim->time.dt*vector_scalar_product (&W,&xv); */
	/* // Phi2n = -Phi0n */
  	/* gdouble term3 = -sim->beta*sim->time.dt*Phi2n*vector_scalar_product (&W,&N); */


	gdouble term1 = sim->beta*sim->time.dt*(W.x*c1 + W.y*c3);
	gdouble term2 = sim->beta*sim->time.dt*(W.x*c2 + W.y*c4);
	// Phi2n = -Phi0n
  	gdouble term3 = 0.;

	rhsmn += sim->time.dt*(1.-sim->beta)*vector_scalar_product(&W,&fsd.gradPhi2) + term3;

	// Loop over the splines whose support is included in the panel
	for ( i = ustart; i < ustart + sp->k; i++) {
	  gdouble wmni = wmn*gsl_matrix_get(Bu, i-ustart, 0);
	  gint itmp = (i - sp->k + 1 ) % NU;

	  for ( j = vstart; j < vstart + sp->k; j++) {
	    gdouble wmnij = wmni*gsl_matrix_get(Bv, j-vstart, 0);
	    gint indexi = itmp + j*NU;
	    
	    for ( a = 0; a < sp->k; a++) {
	      gdouble wmnija = wmnij*gsl_matrix_get(Bu, a, 0);
	      gint atmp = (ustart + a - sp->k + 1)%NU;
	      for ( b = 0; b < sp->k; b++) {
		A0[indexi][atmp + (vstart+b)*NU]
		+=  wmnija*gsl_matrix_get(Bv, b, 0) + wmnij*term1*gsl_matrix_get(Bu, a, 1)*gsl_matrix_get(Bv, b, 0)
			     + wmnija*term2*gsl_matrix_get(Bv, b, 1);
	      }
	    }

	    
	    RHS[indexi] += wmnij*(Phi2 + rhsmn);
	  }
	}
	
      }
    }
    
  }

  /* Neumann */
  if (sp->noflux) {
    // On the solid boundary dn phi = - dn phi0
    // For now, dn phi = 0 i.e. dv phi = 0
    size_t ustart, uend, vstart, vend;
    gsl_vector * Bu2 = gsl_vector_alloc (sp->k);
    Bv = gsl_matrix_alloc (sp->k, 2);
    GrevillePoints * gr = sp->gr;
    for ( i = 0; i < NU; i++) {
      gint index1 = i;
      gdouble u = g_array_index (gr->ui, gdouble, i);
      gdouble v = 0.;

      for ( j = 0; j < size; j++)
  	A0[j][index1] = 0.;

      gsl_bspline_eval_nonzero (MIN(1.-1e-12,u), Bu2, &ustart, &uend, sp->w_u);
      gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,v), 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v);

      for ( m = 0; m < sp->k; m++) {
  	gdouble cu = gsl_vector_get (Bu2, m);
  	for ( n = 0; n < sp->k; n++) {
  	  gdouble cv = gsl_matrix_get (Bv, n, 1);
  	  A0[(ustart+m-sp->k+1)%NU + (vstart+n)*NU][index1] = cu*cv;
  	}
      }
    
      RHS[index1] = 0.;
    }
    gsl_vector_free (Bu2);
    gsl_matrix_free (Bv);
  }

  /* /\* Dirichlet *\/ */
  /* if (sp->noflux) { */
  /*   // On the solid boundary dn phi = - dn phi0 */
  /*   // For now, dn phi = 0 i.e. dv phi = 0 */
  /*   size_t ustart, uend, vstart, vend; */
  /*   Bu = gsl_matrix_alloc (sp->k, 2); */
  /*   Bv = gsl_matrix_alloc (sp->k, 2); */
  /*   GrevillePoints * gr = sp->gr; */
  /*   for ( i = 0; i < NU; i++) { */
  /*     gint index1 = i; */
  /*     gdouble u = g_array_index (gr->ui, gdouble, i); */
  /*     gdouble v = 0.; */

  /*     for ( j = 0; j < size; j++) */
  /* 	A0[j][index1] = 0.; */

  /*     Vector W = sim->U; */

  /*     gsl_bspline_deriv_eval_nonzero (u, 1, Bu, &ustart, &uend, sp->w_u, sp->wd_u); */
  /*     gsl_bspline_deriv_eval_nonzero (v, 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v); */

  /*     Vector xv, xu, gradPhi2, gradPhi, gradphi; */
  /*     xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.; */
  /*     Point p; */
  /*     p.x = p.y = p.z = 0.; */
  /*     gdouble zeta = 0., Phi2 = 0., Phi2n = 0., Phin = 0., phin = 0.; */
  /*     gdouble dPhi2du = 0., dPhi2dv = 0.; */
  /*     gdouble dPhidu = 0., dPhidv = 0.; */
  /*     gdouble dphidu = 0., dphidv = 0.; */
  /*     gdouble dtPhi = 0.; */

  /*     for ( m = 0; m < sp->k; m++) { */
  /* 	gdouble cu = gsl_matrix_get (Bu, m, 0); */
  /* 	gdouble cdu = gsl_matrix_get (Bu, m, 1); */
  /* 	gint ii = (ustart+m) % (sp->M+sp->k-1); */
  /* 	for ( n = 0; n < sp->k; n++) { */
  /* 	  gdouble cv = gsl_matrix_get (Bv, n, 0); */
  /* 	  gdouble cudv = cu*gsl_matrix_get (Bv, n, 1); */
  /* 	  gdouble cvdu = cv*cdu; */
  /* 	  gdouble cuv = cu*cv; */
  /* 	  gint jj = (vstart+n); */
  /* 	  xu.x += coeff (sp,ii,jj, 0)*cvdu; */
  /* 	  xu.y += coeff (sp,ii,jj, 1)*cvdu; */
  /* 	  xu.z += coeff (sp,ii,jj, 2)*cvdu; */
  /* 	  xv.x += coeff (sp,ii,jj, 0)*cudv; */
  /* 	  xv.y += coeff (sp,ii,jj, 1)*cudv; */
  /* 	  xv.z += coeff (sp,ii,jj, 2)*cudv; */
  /* 	  p.x += coeff (sp,ii,jj, 0)*cuv; */
  /* 	  p.y += coeff (sp,ii,jj, 1)*cuv; */
  /* 	  Phi2 += coeff (sp,ii,jj, 7)*cuv; */
  /* 	  Phi2n += coeff (sp,ii,jj, 8)*cuv; */
  /* 	  Phin += coeff (sp,ii,jj, 4)*cuv; */
  /* 	  phin += coeff (sp,ii,jj, 6)*cuv; */
  /* 	  zeta += coeff (sp,ii,jj, 9)*cuv; */
  /* 	  dPhi2du += coeff (sp,ii,jj, 7)*cvdu; */
  /* 	  dPhi2dv += coeff (sp,ii,jj, 7)*cudv; */
  /* 	  dPhidu += coeff (sp,ii,jj, 3)*cvdu; */
  /* 	  dPhidv += coeff (sp,ii,jj, 3)*cudv; */
  /* 	  dphidu += coeff (sp,ii,jj, 5)*cvdu; */
  /* 	  dphidv += coeff (sp,ii,jj, 5)*cudv; */
  /* 	  dtPhi += coeff (sp,ii,jj, 11)*cuv; */
  /* 	} */
  /*     } */

      /* Vector N; */
      /* N = vector_normalise (vector_vector_product (&xu, &xv)); */

      /* gdouble h1_2 = 1./(xu.x*xu.x + xu.y*xu.y + xu.z*xu.z); */
      /* gdouble h2_2 = 1./(xv.x*xv.x + xv.y*xv.y + xv.z*xv.z);  */

      /* gdouble detinv = 1./(xu.x*xv.y-xu.y*xv.x); */
      /* gradPhi2.x = (xv.y*dPhi2du-xu.y*dPhi2dv)*detinv; */
      /* gradPhi2.y = (-xv.x*dPhi2du+xu.x*dPhi2dv)*detinv; */
      /* gradPhi2.z = Phi2n; */

      /* /\* gradPhi.x = (xv.y*dPhidu-xu.y*dPhidv)*detinv; *\/ */
      /* /\* gradPhi.y = (-xv.x*dPhidu+xu.x*dPhidv)*detinv; *\/ */
      /* /\* gradPhi.z = Phin; *\/ */

      /* gradPhi.x = Phin*N.x + h1_2*dPhidu*xu.x + h2_2*dPhidv*xv.x; */
      /* gradPhi.y = Phin*N.y + h1_2*dPhidu*xu.y + h2_2*dPhidv*xv.y; */
      /* gradPhi.z = Phin*N.z + h1_2*dPhidu*xu.z + h2_2*dPhidv*xv.z; */

      /* gradphi.x = (xv.y*dphidu-xu.y*dphidv)*detinv; */
      /* gradphi.y = (-xv.x*dphidu+xu.x*dphidv)*detinv; */
      /* gradphi.z = phin; */

      /* N.x = xv.x;  // Normal to boder in Cartesian frame of reference */
      /* N.y = xv.y; */
      /* N.z = 0.; */

  /*     Vector vtmp; */
  /*     vtmp.x = sim->U.x - gradPhi.x; */
  /*     vtmp.y = sim->U.y - gradPhi.y; */
  /*     vtmp.z = sim->U.z - gradPhi.z; */
  /*     gdouble tmp = vector_scalar_product (&vtmp, &N); */

  /*     // Corrected grad i.e. the normal gradient is exactly */
  /*     // equal to -U.N */
  /*     gradPhi.x = gradPhi.x + tmp*N.x; */
  /*     gradPhi.y = gradPhi.y + tmp*N.y; */
  /*     gradPhi.z = gradPhi.z + tmp*N.z; */

  /*     Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, sim->time.t); */

  /*     gdouble rhsmn = - dtPhi */
  /* 	- sim->g*zeta */
  /* 	- 0.5*vector_scalar_product (&gradPhi,&gradPhi) */
  /* 	+ 0.5*vector_scalar_product (&W,&gradPhi); */

  /*     W.x -= gradPhi.x; */
  /*     W.y -= gradPhi.y; */
  /*     W.z -= gradPhi.z; */

  /*     rhsmn += vector_scalar_product (&W,&gradphi0) */
  /*     	+ vector_scalar_product (&W,&gradphi); */

  /*     rhsmn *= sim->time.dt; */
 
  /*     // OK for now as no motion of the hull and/or no phi0 */
  /*     /\* gdouble term1 = sim->beta*sim->time.dt*(W.x*xv.y - W.y*xv.x)*detinv; *\/ */
  /*     /\* gdouble term2 = sim->beta*sim->time.dt*(-W.x*xu.y + W.y*xu.x)*detinv; *\/ */
  /*     /\* rhsmn += sim->time.dt*(1.-sim->beta)*vector_scalar_product(&W,&gradPhi2); *\/ */

  /*     for ( m = 0; m < sp->k; m++) { */
  /* 	gdouble cu = gsl_matrix_get (Bu, m, 0); */
  /* 	gdouble cdu = gsl_matrix_get (Bu, m, 1); */
  /* 	for ( n = 0; n < sp->k; n++) { */
  /* 	  gdouble cv = gsl_matrix_get (Bv, n, 0); */
  /* 	  gdouble cdv = gsl_matrix_get (Bv, n, 1); */
  /* 	  A0[(ustart+m-sp->k+1)%NU + (vstart+n)*NU][index1]  */
  /* 	    =  cu*cv /\* + term1*cdu*cv + term2*cu*cdv *\/; */
  /* 	  // OK for now as no motion of the hull and/or no phi0 */
  /* 	} */
  /*     } */
    
  /*     RHS[index1] = Phi2 + rhsmn; */
  /*   } */
  /*   gsl_matrix_free (Bu); */
  /*   gsl_matrix_free (Bv); */
  /* } */

  /* Storage in Compressed Column Storage (CCS) format for superlu */
  CCSProblem * ccs = ccs_problem_new ();
  gsl_vector * gsl_rhs = gsl_vector_alloc (size);
  gint count = 0;
  for ( i = 0; i < size; i++) {
    g_array_append_val (ccs->index, count);
    for ( j = 0; j < size; j++) {
      if (A0[i][j] != 0.) {
  	g_array_append_val (ccs->matrix, A0[i][j]);
  	g_array_append_val (ccs->column, j);
  	count++;
      }
    }
    gsl_vector_set (gsl_rhs, i, RHS[i]);
  }
  g_array_append_val (ccs->index, count);

  /* Solve the problem using superlu */
  ccs_problem_lu_solve (ccs, gsl_rhs);

  /* Copy the solution to the patch */
  sp->copy_fit_solution (sp, gsl_rhs, 7);

  /* for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) { */
  /*   for ( j = 0; j < gsl_bspline_ncoeffs (sp->w_v); j++) { */
  /*     coeff_assign (sp, i, j, 7, gsl_vector_get (gsl_rhs, i + j*gsl_bspline_ncoeffs (sp->w_u))); */
  /*   } */
  /* } */

  ccs_problem_destroy (ccs);
  gsl_vector_free (gsl_rhs);
  
  /* Stop timer and print */
  fprintf (stdout, "   Free-surface disturbance potential update: %f \n", g_test_timer_elapsed());
}

gdouble semi_implicit_no_speed_potential_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint  i, j, k = sp->k, ii, jj;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;

  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = gp->istart;
  gint vstart = gp->jstart;
  if (sp->periodic)
    ustart -= k-1;

  gdouble zeta = 0., Phid = 0.;
  //gdouble zeta1 = 0.;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      jj = (vstart+j);

      sc = g_ptr_array_index (sp->coeffs, ii+ jj*NUT);

      Phid += sc->v[23]*cuv;
      zeta += sc->v[18]*cuv;
      // zeta1 += sc->v[9]*cuv;
    }
  }

  //return  Phid - sim->time.dt*(sim->wp.g*0.5*(zeta+zeta1));
  return  Phid - sim->time.dt*(sim->wp.g*zeta);
}

gdouble explicit_no_speed_potential_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint  i, j, k = sp->k, ii, jj;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;

  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = gp->istart;
  gint vstart = gp->jstart;
  if (sp->periodic)
    ustart -= k-1;

  gdouble zeta = 0., Phid = 0.;
  //gdouble zeta1 = 0.;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      jj = (vstart+j);

      sc = g_ptr_array_index (sp->coeffs, ii+ jj*NUT);

      Phid += sc->v[23]*cuv; /* 7 */
      zeta += sc->v[18]*cuv; /* 9 */
      // zeta1 += sc->v[9]*cuv;
    }
  }

  //return  Phid - sim->time.dt*(sim->wp.g*0.5*(zeta+zeta1));
  return  Phid - sim->time.dt*(sim->wp.g*zeta);
}

gdouble explicit_no_speed_potential_update_rhs_gauss_store (SPPanel * spp,
							    gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint  i, j, k = sp->k, ii, jj;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;

  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = gp->istart;
  gint vstart = gp->jstart;
  if (sp->periodic)
    ustart -= k-1;

  gdouble zeta = 0., Phid = 0.;
  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      jj = (vstart+j);

      sc = g_ptr_array_index (sp->coeffs, ii+ jj*NUT);

      Phid += sc->v[7]*cuv;
      zeta += sc->v[9]*cuv;
    }
  }

  return  /* Phid */ - sim->time.dt*(sim->wp.g*zeta);
}

gdouble semi_implicit_no_speed_potential_update_rhs_noflux_bc (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Vector xu, xv;
  Point p;
  gsl_matrix * Bu = gsl_matrix_alloc (sp->k,2);
  gsl_matrix * Bv = gsl_matrix_alloc (sp->k,2);
  size_t ustart, uend, vstart, vend;
  gint m, n;

  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
  p.x = p.y = p.z = 0.;

  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bu, &ustart, &uend, sp->w_u, sp->wd_u);
  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,v), 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v);

  if (sp->periodic)
    ustart -= sp->k - 1;

  for ( m = 0; m < sp->k; m++) {
    gdouble cu = gsl_matrix_get (Bu, m, 0);
    gdouble cdu = gsl_matrix_get (Bu, m, 1);
    gint ii = (ustart+m);
    for ( n = 0; n < sp->k; n++) {
      gdouble cv = gsl_matrix_get (Bv, n, 0);
      gdouble cudv = cu*gsl_matrix_get (Bv, n, 1);
      gdouble cvdu = cv*cdu;
      gdouble cuv = cu*cv;
      gint jj = (vstart+n);
      gdouble vx = coeff (sp,ii,jj, 0);
      gdouble vy = coeff (sp,ii,jj, 1);
      gdouble vz = coeff (sp,ii,jj, 2);
      /* xu.x += vx*cvdu; */
      /* xu.y += vy*cvdu; */
      /* xu.z += vz*cvdu; */
      xv.x += vx*cudv;
      xv.y += vy*cudv;
      /* xv.z += vz*cudv; */
      p.x += vx*cuv;
      p.y += vy*cuv;
      p.z += vz*cuv;
    }
  }

  gsl_matrix_free (Bu);
  gsl_matrix_free (Bv);

  Vector gradPhi0 = sim->wp.wave_potential_gradient (&sim->wp, p, sim->time.t);

  Vector N /* = vector_normalise (vector_vector_product (&xu, &xv)) */;


  // Hull motion will have to be included somewhere in here.


  // BC is on the hull, i.e. on the edge of the free-surface
  // d Phid/dn = sum motion - d Phi0/dn

  /* gdouble h1_2 = 1./(xu.x*xu.x + xu.y*xu.y + xu.z*xu.z); */
  /* gdouble h2_2 = 1./(xv.x*xv.x + xv.y*xv.y + xv.z*xv.z); */

  // For now there is exact match between hull parametric coordinates and free-surface parametric coordinates
  Spline2D * hull = sim->hull->patches->data;
  Vector Ns = spline2d_normal (hull, u, v);

  gdouble norm = 1./sqrt(xv.x*xv.x+xv.y*xv.y);

  N.x = xv.x*norm; // Normal to border in Cartesian frame of reference
  N.y = xv.y*norm;
  N.z = 0.;

  /* fprintf (stdout, "%f %f \n %f %f \n\n", p.x, p.y, p.x + 0.1*N.x, p.y + 0.1*N.y); */
  /* fprintf (stdout, "%f %f \n %f %f \n\n", p.x, p.y, p.x + 0.1*Ns.x, p.y + 0.1*Ns.y); */

  fprintf (stdout, "%f %f \n", vector_scalar_product (&N, &gradPhi0), vector_scalar_product (&Ns, &gradPhi0));

  // minus as N points inside the domain but so do v-derivatives
  // return - vector_scalar_product (&gradPhi0, &N)*vector_scalar_product (&N, &Ns);
  return - vector_scalar_product (&gradPhi0, &N);
}

static void semi_implicit_no_speed_potential_update_periodic (Simulation * sim, gdouble t, gboolean prediction)
{
  g_test_timer_start ();
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  g_assert (fs != NULL);

  // Original Galerkin method
  g_assert (fs->fit);

  // Get rhs
  gsl_vector * gsl_rhs;

  gsl_rhs = fs->build_fit_rhs (fs, semi_implicit_no_speed_potential_update_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  /* Solve the problem using superlu */
  ccs_problem_lu_solve (fs->fit, gsl_rhs);


  /* Copy the solution to the patch */
  fs->copy_fit_solution (fs, gsl_rhs, 7);
  
  gsl_vector_free (gsl_rhs);
  fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());

}

void semi_implicit_no_speed_potential_update (Simulation * sim, gdouble t, gboolean prediction)
{
  if (sim->verbose)
    g_test_timer_start ();
  Spline2D * fs = sim->fs->s->patches->data;

  g_assert (fs != NULL);

  // Original Galerkin method
  g_assert (fs->fit);

  // Get rhs
  fs->rhs = fs->build_fit_rhs (fs, semi_implicit_no_speed_potential_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
  /* Solve the problem using superlu */
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  
  /* Copy the solution to the patch */
  fs->copy_fit_solution (fs, fs->rhs, 7);

  if (sim->verbose)
    fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

static gdouble numerical_beaches_rectangle (gdouble x, gdouble y, gdouble z, gpointer data)
{
  WaveParams * wp = (WaveParams *) data;

  if ( x > 1. && fabs(y) > 2 ) {
    return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-2, 2.));
  }
  else if ( x > 1 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.);
  else if ( fabs(y) > 2 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-2, 2.);
  else
    return 0.;
}

static gdouble numerical_beaches_rectangle_spheroid (gdouble x, gdouble y, gdouble z, gpointer data)
{
  WaveParams * wp = (WaveParams *) data;

  /* if ( x > 5. && fabs(y) > 4 ) { */
  /*   return MAX (3.*wp->Cs/pow(2, 5.)*pow(fabs(x-5), 2.), 3.*wp->Cs/pow(2, 6.)*pow(fabs(y)-4, 2.)); */
  /* } */
  /* else if ( x < -15. && fabs(y) > 4 ) { */
  /*   return MAX (3.*wp->Cs/pow(2, 5.)*pow(fabs(x+15), 2.), 3.*wp->Cs/pow(2, 6.)*pow(fabs(y)-4, 2.)); */
  /* } */
  /* else if ( x > 5 ) */
  /*   return 3.*wp->Cs/pow(2, 5.)*pow(fabs(x-5), 2.); */
  /* else if ( fabs(y) > 4 ) */
  /*   return 3.*wp->Cs/pow(2, 6.)*pow(fabs(y)-4, 2.); */
  /* else if ( x < -15 ) */
  /*   return 3.*wp->Cs/pow(2, 5.)*pow(fabs(x+15), 2.); */
  /* else */
  /*   return 0.; */

  /* if ( x > 1. && fabs(y) > 4 ) { */
  /*   return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-4, 2.)); */
  /* } */
  /* else if ( x < -18. && fabs(y) > 4 ) { */
  /*   return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x+18), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-4, 2.)); */
  /* } */
  /* else if ( x > 1 ) */
  /*   return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.); */
  /* else if ( fabs(y) > 4 ) */
  /*   return 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-4, 2.); */
  /* else if ( x < -18 ) */
  /*   return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x+18), 2.); */
  /* else */
  /*   return 0.; */

  if ( x > 2.5 && fabs(y) > 4 ) {
    return MAX (3.*wp->Cs/pow(2.5, 3.)*pow(fabs(x-2.5), 2.), 3.*wp->Cs/pow(3, 2.)*pow(fabs(y)-6, 2.));
  }
  else if ( x < -7. && fabs(y) > 4 ) {
    return MAX (3.*wp->Cs/pow(3, 3.)*pow(fabs(x+7), 2.), 3.*wp->Cs/pow(2., 3.)*pow(fabs(y)-4, 2.));
  }
  else if ( x > 2.5 )
    return 3.*wp->Cs/pow(2.5, 3.)*pow(fabs(x-2.5), 2.);
  else if ( fabs(y) > 7 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-4, 2.);
  else if ( x < -18 )
    return 3.*wp->Cs/pow(3., 3.)*pow(fabs(x+7), 2.);
  else
    return 0.;

  if ( x > 5. && fabs(y) > 7 ) {
    return MAX (3.*wp->Cs/pow(5, 3.)*pow(fabs(x-5), 2.), 3.*wp->Cs/pow(3, 3.)*pow(fabs(y)-7, 2.));
  }
  else if ( x < -18. && fabs(y) > 7 ) {
    return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x+18), 2.), 3.*wp->Cs/pow(3, 3.)*pow(fabs(y)-7, 2.));
  }
  else if ( x > 5 )
    return 3.*wp->Cs/pow(5, 3.)*pow(fabs(x-5), 2.);
  else if ( fabs(y) > 7 )
    return 3.*wp->Cs/pow(3, 3.)*pow(fabs(y)-7, 2.);
  else if ( x < -18 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x+18), 2.);
  else
    return 0.;

  /* if ( x > 1. && fabs(y) > 4 ) { */
  /*   return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-4, 2.)); */
  /* } */
  /* else if ( x < -8. && fabs(y) > 4 ) { */
  /*   return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x+8), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-4, 2.)); */
  /* } */
  /* else if ( x > 1 ) */
  /*   return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.); */
  /* else if ( fabs(y) > 4 ) */
  /*   return 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-4, 2.); */
  /* else if ( x < -8 ) */
  /*   return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x+8), 2.); */
  /* else */
  /*   return 0.; */


  if ( x > 1. && fabs(y) > 2 ) {
    return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-2, 2.));
  }
  else if ( x < -6. && fabs(y) > 2 ) {
    return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x+6), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-2, 2.));
  }
  else if ( x > 1 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.);
  else if ( fabs(y) > 2 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-2, 2.);
  else if ( x < -6 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x+6), 2.);
  else
    return 0.;
}

static gdouble numerical_beaches_wu (gdouble x, gdouble y, gdouble z, gpointer data)
{
  WaveParams * wp = (WaveParams *) data;

  if ( fabs(x) > wp->r1/2. && fabs(y) > wp->r2/2. ) {
    return MAX (3.*wp->Cs/pow(wp->r1/2., 3.)*pow(fabs(x)-wp->r1/2., 2.), 3.*wp->Cs/pow(wp->r2/2., 3.)*pow(fabs(y)-wp->r2/2., 2.));
  }
  else if ( fabs(x) > wp->r1/2. )
    return 3.*wp->Cs/pow(wp->r1/2., 3.)*pow(fabs(x)-wp->r1/2., 2.);
  else if ( fabs(y) > wp->r2/2. )
    return 3.*wp->Cs/pow(wp->r2/2., 3.)*pow(fabs(y)-wp->r2/2., 2.);
  else
    return 0.;
}

static gdouble numerical_beaches_oscillatory_spheroid (gdouble x, gdouble y, gdouble z, gpointer data)
{
  WaveParams * wp = (WaveParams *) data;

#if 1
  if ( fabs(x) > 6. && fabs(y) > 6. ) {
    return MAX (3.*wp->Cs/pow(4, 3.)*pow(fabs(x)-6., 2.), 3.*wp->Cs/pow(4, 3.)*pow(fabs(y)-6., 2.));
  }
  else if ( fabs(x) > 6. )
    return 3.*wp->Cs/pow(4, 3.)*pow(fabs(x)-6., 3.);
  else if ( fabs(y) > 8. )
    return 3.*wp->Cs/pow(4, 3.)*pow(fabs(y)-6., 3.);
  else
    return 0.;
#else
  if ( fabs(x) > 4. && fabs(y) > 4. ) {
    return MAX (3.*wp->Cs/pow(1, 3.)*pow(fabs(x)-4., 2.), 3.*wp->Cs/pow(1, 3.)*pow(fabs(y)-4., 2.));
  }
  else if ( fabs(x) > 4. )
    return 3.*wp->Cs/pow(1, 3.)*pow(fabs(x)-4., 3.);
  else if ( fabs(y) > 4. )
    return 3.*wp->Cs/pow(1, 3.)*pow(fabs(y)-4., 3.);
  else
    return 0.;
#endif
}

static gdouble numerical_beaches_circle (gdouble x, gdouble y, gdouble z, gpointer data)
{
  WaveParams * wp = (WaveParams *) data;

  gdouble r = sqrt(x*x + y*y);
  if ( r > 3. ) {
    return 3.*wp->Cs/pow(2.0, 3.)*pow(r-3., 2.);
  }
  else
    return 0.;
  
}

static gdouble numerical_beaches (Spline2D * sp, gdouble u, gdouble v, WaveParams * wp)
{
  Point p = spline2d_eval_point (sp, u, v);
  gdouble x = p.x;
  gdouble y = p.y;

  gdouble nu = 0.;
  if ( x > 1. && fabs(y) > 2 ) {
    return MAX (3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.), 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-2, 2.));
   }
  else if ( x > 1 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(x-1), 2.);
  else if ( fabs(y) > 2 )
    return 3.*wp->Cs/pow(2, 3.)*pow(fabs(y)-2, 2.);
  else
    return 0.;
}

static gsl_vector *  explicit_free_surface_update_rhs (Spline2D * sp, Simulation * sim)
{
  gint i, j, m, n, ii;
  size_t ustart, vstart;
  gint size = gsl_bspline_ncoeffs (sp->w_u)*gsl_bspline_ncoeffs (sp->w_v);
  gdouble RHS[size];
  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
  }
  
  // Loop over the panels of the patch
  for ( ii = 0; ii < sp->M*sp->N; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    ustart = gp->istart;
    vstart = gp->jstart;

    for ( m = 0; m < ng; m++) {
      gdouble um = g_array_index (gp->ui, gdouble, m);
      gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	  
      for ( n = 0; n < ng; n++) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);	    
	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

	/* Point p = spline2d_eval_gauss_point_point (sp, gp, um, vn); */
	Point p = g_array_index (gp->Pi, Point, m + n*ng);

	/* gdouble dxdu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 0); */
	/* gdouble dxdv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 0); */
	/* gdouble dydu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 1); */
	/* gdouble dydv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 1); */

	/* wmn *= fabs(dxdu*dydv-dxdv*dydu); */

	// gdouble r = sqrt(p.x*p.x+p.y*p.y);

	/* For numerical beaches */
	gdouble nu = 0.;
	if ( sim->numerical_beaches )
	  nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

	//Vector gradPhi2 = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7);
	//Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
	gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);
	//Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9);
	//gdouble zeta= spline2d_eval_gauss_point (sp, gp, m, n, 9);
	
	Vector W = sim->U;

	gdouble sign = 1;

	/* W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x; */
	/* W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y; */
	/* W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z; */

	W.x -= fsd.gradPhi.x;
	W.y -= fsd.gradPhi.y;
	W.z -= fsd.gradPhi.z;

	gdouble rhsmn = fsd.zeta + sim->time.dt*(  vector_scalar_product(&W,&fsd.gradzeta)
						 /* - fsd.dtzeta0 */
						 /* + sign*vector_scalar_product(&W,&fsd.gradzeta0) */
						 /* + fsd.gradphi0.z */
						 /* + /\* fsd. *\/gradPhi.z */
						 /* + fsd.gradphi.z */
						 + fsd.gradPhi2.z
						 /* - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0) */

						  // Weakly non-linear terms
						  /* + (fsd.graddzPhi.z */
						  /*    + fsd.graddzphi0.z */
						  /*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) */
						  /*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) */
						  /*    )*fsd.zeta */

						  // Numerical beaches
						   - 2.*nu*fsd.zeta
						   + nu*nu/sim->wp.g*Phi2
						   );
	
	/* W.x = -p.y; */
	/* W.y = p.x; */
	/* W.z = 0.; */
	/* rhsmn = fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta) ); */

	// Loop over the splines whose support is included in the panel
	for ( i = ustart; i < ustart + sp->k; i++) {
	  gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	  for ( j = vstart; j < vstart + sp->k; j++) {
	    gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	    gint indexi = i + j*gsl_bspline_ncoeffs (sp->w_u);

	    RHS[indexi] += wmnij*(rhsmn);
	  }
	}
	
      }
    }
    
  }

  gint NU = gsl_bspline_ncoeffs (sp->w_u);
  gint NV = gsl_bspline_ncoeffs (sp->w_v);

/* #ifdef NO_FLUX */
  // On the solid boundary dn phi = - dn phi0
  // For now, dn phi = 0 i.e. dv phi = 0
  for ( i = 0; i < NU; i++) {
    gint index1 = i;
    RHS[index1] = 0.;
  }
/* #endif */

  // Continuity of variable on boundary
  for ( i = 0; i < NV; i++) {
    gint index1 = (i+1)*NU - 1;
    gint index2 = i*NU;

    RHS[index1] += RHS[index2];
    RHS[index2] = 0.;
  }

  // Copy lhs and rhs to gsl structures
  gsl_vector * rhs = gsl_vector_alloc (size);
  for ( i = 0; i < size; i++)
    gsl_vector_set (rhs, i, RHS[i]);

  return rhs;
}

gdouble explicit_free_surface_elevation_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;
  gint gindex = m+n*ng;

  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
  SplineCoeffs * sc;
  gint NUT = sp->periodic ? (sp->NU+sp->k-1) : sp->NU;

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);
  
  Vector W = sim->U;
  Vector gradzeta0 = sim->wp.wave_elevation_gradient (&sim->wp, p, sim->time.t);

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gdouble phid = 0., zeta = 0., phidn = 0.;
  gdouble Vn = 0., dzetadu = 0., dzetadv = 0.;
  Vector gradzeta;
  gradzeta.x = gradzeta.y = gradzeta.z = 0.;

  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    for ( j = 0; j < sp->k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cuv = cu*cv;
      gint j2 = (jstart+j);

      sc = g_ptr_array_index (sp->coeffs, istart+ j2*NUT);

      phid += sc->v[23]*cuv;
      zeta += sc->v[18]*cuv;
      phidn += sc->v[30]*cuv;

      dzetadu += sc->v[18]*cv*cdu;
      dzetadv += sc->v[18]*cu*gsl_matrix_get (Bv, j, 1);
    }
    istart++;
  }

  // zeta is a 2D variable, hence no normal
  // used to compute the gradient
  gradzeta.x = c1*dzetadu+c2*dzetadv;
  gradzeta.y = c3*dzetadu+c4*dzetadv;
  gradzeta.z = /* c5*dzetadu+c6*dzetadv */0.;

#if 1
  /* Linear */
  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;

  return zeta + sim->time.dt*( vector_scalar_product(&W,&gradzeta)
			       + fsd.graddzPhi.z*zeta
			       + phidn /* gradphi.z */
			       + vector_scalar_product(&W,&gradzeta0)
			       // Numerical beaches
			       - 2.*nu*zeta
			       + nu*nu/sim->wp.g*phid
			       );

  /* Weak-scatterer */
#else
  W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x;
  W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y;
  W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z;

  gdouble rhsmn = zeta + sim->time.dt*(  vector_scalar_product(&W,&fsd.gradzeta)
					 - fsd.dtzeta0
					 + vector_scalar_product(&W,&fsd.gradzeta0)
					 + fsd.gradphi0.z
					 + fsd.gradPhi.z
					 + fsd.gradphi.z
					 + fsd.gradPhi2.z
					 - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0)

					 // Weakly non-linear terms
					 /* + (fsd.graddzPhi.z */
					 /*    + fsd.graddzphi0.z */
					 /*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) */
					 /*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) */
					 /*    )*fsd.zeta */
					 
					 // Numerical beaches
					 - 2.*nu*zeta
					 + nu*nu/sim->wp.g*Phi2
					 );
#endif	
}

gdouble explicit_free_surface_elevation_update_rhs_gauss_store (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;
  gint gindex = m+n*ng;

  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
  SplineCoeffs * sc;
  gint NUT = sp->periodic ? (sp->NU+sp->k-1) : sp->NU;

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);
  
  Vector W = sim->U;
  Vector gradzeta0 = sim->wp.wave_elevation_gradient (&sim->wp, p, sim->time.t);

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gdouble phid = 0., zeta = 0., phidn = 0.;
  gdouble Vn = 0., dzetadu = 0., dzetadv = 0.;
  Vector gradzeta;

  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    for ( j = 0; j < sp->k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cuv = cu*cv;
      gint j2 = (jstart+j);

      sc = g_ptr_array_index (sp->coeffs, istart+ j2*NUT);

      phid += sc->v[7]*cuv;
      zeta += sc->v[9]*cuv;
      phidn += sc->v[8]*cuv;

      dzetadu += sc->v[9]*cv*cdu;
      dzetadv += sc->v[9]*cu*gsl_matrix_get (Bv, j, 1);
    }
    istart++;
  }

  // zeta is a 2D variable, hence no normal
  // used to compute the gradient
  gradzeta.x = c1*dzetadu + c2*dzetadv;
  gradzeta.y = c3*dzetadu + c4*dzetadv;
  gradzeta.z = /* c5*dzetadu+c6*dzetadv */0.;

#if 1
  /* Linear */

  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;

  return /* zeta + */ sim->time.dt*(vector_scalar_product(&W,&gradzeta)
				    + fsd.graddzPhi.z*zeta
				    + phidn
				    + vector_scalar_product(&W,&gradzeta0)

				    // Numerical beaches
				    - 2.*nu*zeta
				    + nu*nu/sim->wp.g*phid
				    );

  /* Weak-scatterer */

#else
  W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x;
  W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y;
  W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z;

  gdouble rhsmn = zeta + sim->time.dt*(  vector_scalar_product(&W,&fsd.gradzeta)
					 - fsd.dtzeta0
					 + vector_scalar_product(&W,&fsd.gradzeta0)
					 + fsd.gradphi0.z
					 + fsd.gradPhi.z
					 + fsd.gradphi.z
					 + fsd.gradPhi2.z
					 - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0)

					 // Weakly non-linear terms
					 /* + (fsd.graddzPhi.z */
					 /*    + fsd.graddzphi0.z */
					 /*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) */
					 /*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) */
					 /*    )*fsd.zeta */
					 
					 // Numerical beaches
					 - 2.*nu*zeta
					 + nu*nu/sim->wp.g*Phi2
					 );
#endif
}

gdouble explicit_free_surface_elevation_update_rhs_noflux_bc (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  Simulation * sim = (Simulation *) data;

  size_t ustart, uend, vstart, vend, ustart_x;
  gsl_matrix * Bu = gsl_matrix_alloc (sp->k, 2);
  gsl_matrix * Bv = gsl_matrix_alloc (sp->k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (sp->k, 2);

  gsl_bspline_deriv_eval_nonzero (MAX(1e-12, MIN(1.-1e-12,u)), 1, Bu, &ustart, &uend, sp->w_u, sp->wd_u);
  gsl_bspline_deriv_eval_nonzero (MAX(1e-12, MIN(1.-1e-12,v)), 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v);

  gsl_bspline_deriv_eval_nonzero (MAX(1e-12, MIN(1.-1e-12,u)), 1, Bux, &ustart_x, &uend, sp->wx_u, sp->wxd_u);

  if (sp->periodic)
    ustart -= sp->k-1;

  Vector xv, xu, gradPhi2, gradPhi, gradphi, gradzeta;
  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  gdouble zeta = 0., Phi2n = 0., Phin = 0., phin = 0.;
  /* gdouble dPhi2du = 0., dPhi2dv = 0.; */
  gdouble dPhidu = 0., dPhidv = 0.;
  /* gdouble dphidu = 0., dphidv = 0.; */
  /* gdouble dtPhi = 0.; */
  gdouble dzetadu = 0., dzetadv = 0.;
  gdouble dzPhin = 0.;

  gint m, n;

  for ( m = 0; m < sp->k; m++) {
    gdouble cu = gsl_matrix_get (Bu, m, 0);
    gdouble cdu = gsl_matrix_get (Bu, m, 1);
    gdouble cux = gsl_matrix_get (Bux, m, 0);
    gdouble cdux = gsl_matrix_get (Bux, m, 1);
    gint ii = (ustart+m);
    gint iix = (ustart_x+m);
    for ( n = 0; n < sp->k; n++) {
      gdouble cv = gsl_matrix_get (Bv, n, 0);
      gdouble cdv = gsl_matrix_get (Bv, n, 1);
      gdouble cudv = cu*cdv;
      gdouble cvdu = cv*cdu;
      gdouble cuv = cu*cv;
      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;
      gint jj = (vstart+n);
      xu.x += coeff (sp,iix,jj, 0)*cvdux;
      xu.y += coeff (sp,iix,jj, 1)*cvdux;
      xu.z += coeff (sp,iix,jj, 2)*cvdux;
      xv.x += coeff (sp,iix,jj, 0)*cudvx;
      xv.y += coeff (sp,iix,jj, 1)*cudvx;
      xv.z += coeff (sp,iix,jj, 2)*cudvx;
      p.x += coeff (sp,iix,jj, 0)*cuvx;
      p.y += coeff (sp,iix,jj, 1)*cuvx;
      /* Phi2 += coeff (sp,ii,jj, 7)*cuv;  */
      Phi2n += coeff (sp,ii,jj, 8)*cuv;
      Phin += coeff (sp,ii,jj, 4)*cuv;
      phin += coeff (sp,ii,jj, 6)*cuv;
      zeta += coeff (sp,ii,jj, 9)*cuv; //
      /* dPhi2du += coeff (sp,ii,jj, 7)*cvdu; */
      /* dPhi2dv += coeff (sp,ii,jj, 7)*cudv; */
      dPhidu += coeff (sp,ii,jj, 3)*cvdu;
      dPhidv += coeff (sp,ii,jj, 3)*cudv;
      /* dphidu += coeff (sp,ii,jj, 5)*cvdu; */
      /* dphidv += coeff (sp,ii,jj, 5)*cudv; */
      dzetadu += coeff (sp,ii,jj, 9)*cvdu;
      dzetadv += coeff (sp,ii,jj, 9)*cudv;
      dzPhin +=  coeff (sp,ii,jj, 15)*cuv;
    }
  }

  gsl_matrix_free (Bu);
  gsl_matrix_free (Bv);
  gsl_matrix_free (Bux);

  Vector N; // Normal to boder in Cartesian frame of reference
  N = vector_normalise (vector_vector_product (&xu, &xv));
 
  gdouble det = xu.x*(xv.y*N.z-xv.z*N.y)
	- xu.y*(N.z*xv.x-xv.z*N.x)
	+ xu.z*(xv.x*N.y-xv.y*N.x);
  det = 1./det;
  gdouble c1 = (xv.y*N.z-xv.z*N.y)*det;
  gdouble c2 = (xu.z*N.y-xu.y*N.z)*det;
  gdouble c3 = (xv.z*N.x-xv.x*N.z)*det;
  gdouble c4 = (xu.x*N.z-xu.z*N.x)*det;
  gdouble c5 = (xv.x*N.y-xv.y*N.x)*det;
  gdouble c6 = (N.x*xu.y-xu.x*N.y)*det;

  gradPhi.x = c1*dPhidu + c2*dPhidv + Phin*N.x;
  gradPhi.y = c3*dPhidu + c4*dPhidv + Phin*N.y;
  gradPhi.z = c5*dPhidu + c5*dPhidv + Phin*N.z;

  
  gradzeta.x = c1*dzetadu + c2*dzetadv;
  gradzeta.y = c3*dzetadu + c4*dzetadv;
  gradzeta.z = 0.;

  N.x = xv.x; // Normal to boder in Cartesian frame of reference
  N.y = xv.y;
  N.z = 0.;

  Vector vtmp;
  vtmp.x = sim->U.x - gradPhi.x;
  vtmp.y = sim->U.y - gradPhi.y;
  vtmp.z = sim->U.z - gradPhi.z;
  gdouble tmp = vector_scalar_product (&vtmp, &N);

  // Corrected grad i.e. the normal gradient is exactly
  // equal to -U.N
  gradPhi.x = gradPhi.x + tmp*N.x;
  gradPhi.y = gradPhi.y + tmp*N.y;
  gradPhi.z = gradPhi.z + tmp*N.z;

  Vector gradzeta0 = sim->wp.wave_elevation_gradient (&sim->wp, p, sim->time.t);
  
  Vector W = sim->U;

  /* Linear */

  W.x -= gradPhi.x;
  W.y -= gradPhi.y;
  W.z -= gradPhi.z;

  gdouble rhsmn = zeta + sim->time.dt*( vector_scalar_product(&W,&gradzeta)
					+ dzPhin*zeta /* graddzPhi.z*zeta */
					+ phin /* gradphi.z */
					+ Phi2n /* gradPhi2.z */
					+ vector_scalar_product(&W,&gradzeta0)
					);

  /* fprintf (stdout, "%e %e %e %e %e %e %e \n", u, v, rhsmn, xu.x, xu.y, xv.x, xv.y); */

  return rhsmn;
}

gdouble leapfrog_free_surface_elevation_update_rhs_noflux_bc (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  Simulation * sim = (Simulation *) data;

  size_t ustart, uend, vstart, vend, ustart_x, vstart_x;
  gsl_matrix * Bu = gsl_matrix_alloc (sp->k, 2);
  gsl_matrix * Bv = gsl_matrix_alloc (sp->k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (sp->k, 2);

  gsl_bspline_deriv_eval_nonzero (MAX(1.e-12,MIN(1.-1e-12,u)), 1, Bu, &ustart, &uend, sp->w_u, sp->wd_u);
  gsl_bspline_deriv_eval_nonzero (MAX(1.e-12,MIN(1.-1e-12,v)), 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (MAX(1.e-12,MIN(1.-1e-12,u)), 1, Bux, &ustart_x, &uend, sp->wx_u, sp->wxd_u);

  if (sp->periodic)
    ustart -= sp->k-1;

  Vector xv, xu, gradPhi2, gradPhi, gradphi, gradzeta;
  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  gdouble zeta = 0., Phi2n = 0., Phin = 0., phin = 0.;
  /* gdouble dPhi2du = 0., dPhi2dv = 0.; */
  gdouble dPhidu = 0., dPhidv = 0.;
  /* gdouble dphidu = 0., dphidv = 0.; */
  /* gdouble dtPhi = 0.; */
  gdouble dzetadu = 0., dzetadv = 0.;
  gdouble dzPhin = 0.;

  gint m, n;

  for ( m = 0; m < sp->k; m++) {
    gdouble cu = gsl_matrix_get (Bu, m, 0);
    gdouble cdu = gsl_matrix_get (Bu, m, 1);
    gdouble cux = gsl_matrix_get (Bux, m, 0);
    gdouble cdux = gsl_matrix_get (Bux, m, 1);
    gint ii = (ustart+m);
    gint iix = (ustart_x+m);
    for ( n = 0; n < sp->k; n++) {
      gdouble cv = gsl_matrix_get (Bv, n, 0);
      gdouble cdv = gsl_matrix_get (Bv, n, 1);
      gdouble cudv = cu*cdv;
      gdouble cvdu = cv*cdu;
      gdouble cuv = cu*cv;
      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;
      gint jj = (vstart+n);
      xu.x += coeff (sp,iix,jj, 0)*cvdux;
      xu.y += coeff (sp,iix,jj, 1)*cvdux;
      xu.z += coeff (sp,iix,jj, 2)*cvdux;
      xv.x += coeff (sp,iix,jj, 0)*cudvx;
      xv.y += coeff (sp,iix,jj, 1)*cudvx;
      xv.z += coeff (sp,iix,jj, 2)*cudvx;
      p.x += coeff (sp,iix,jj, 0)*cuvx;
      p.y += coeff (sp,iix,jj, 1)*cuvx;
      /* Phi2 += coeff (sp,ii,jj, 7)*cuv;  */
      Phi2n += coeff (sp,ii,jj, 8)*cuv;
      Phin += coeff (sp,ii,jj, 4)*cuv;
      phin += coeff (sp,ii,jj, 6)*cuv;
      zeta += coeff (sp,ii,jj, 22)*cuv; //
      /* dPhi2du += coeff (sp,ii,jj, 7)*cvdu; */
      /* dPhi2dv += coeff (sp,ii,jj, 7)*cudv; */
      dPhidu += coeff (sp,ii,jj, 3)*cvdu;
      dPhidv += coeff (sp,ii,jj, 3)*cudv;
      /* dphidu += coeff (sp,ii,jj, 5)*cvdu; */
      /* dphidv += coeff (sp,ii,jj, 5)*cudv; */
      dzetadu += coeff (sp,ii,jj, 9)*cvdu;
      dzetadv += coeff (sp,ii,jj, 9)*cudv;
      dzPhin +=  coeff (sp,ii,jj, 15)*cuv;
    }
  }

  gsl_matrix_free (Bu);
  gsl_matrix_free (Bv);
  gsl_matrix_free (Bux);

  Vector N;
  N = vector_normalise (vector_vector_product (&xu, &xv));

  gdouble det = xu.x*(xv.y*N.z-xv.z*N.y)
    - xu.y*(N.z*xv.x-xv.z*N.x)
    + xu.z*(xv.x*N.y-xv.y*N.x);
  det = 1./det;
  gdouble c1 = (xv.y*N.z-xv.z*N.y)*det;
  gdouble c2 = (xu.z*N.y-xu.y*N.z)*det;
  gdouble c3 = (xv.z*N.x-xv.x*N.z)*det;
  gdouble c4 = (xu.x*N.z-xu.z*N.x)*det;
  gdouble c5 = (xv.x*N.y-xv.y*N.x)*det;
  gdouble c6 = (N.x*xu.y-xu.x*N.y)*det;

  gradPhi.x = c1*dPhidu + c2*dPhidv + Phin*N.x;
  gradPhi.y = c3*dPhidu + c4*dPhidv + Phin*N.y;
  gradPhi.z = c5*dPhidu + c6*dPhidv + Phin*N.z;

  gradzeta.x = c1*dzetadu+c2*dzetadv;
  gradzeta.y = c3*dzetadu+c4*dzetadv;
  gradzeta.z = 0.;

  N.x = xv.x; // Normal to boder in Cartesian frame of reference
  N.y = xv.y;
  N.z = 0.;

  Vector vtmp;
  vtmp.x = sim->U.x - gradPhi.x;
  vtmp.y = sim->U.y - gradPhi.y;
  vtmp.z = sim->U.z - gradPhi.z;
  gdouble tmp = vector_scalar_product (&vtmp, &N);

  // Corrected grad i.e. the normal gradient is exactly
  // equal to -U.N
  gradPhi.x = gradPhi.x + tmp*N.x;
  gradPhi.y = gradPhi.y + tmp*N.y;
  gradPhi.z = gradPhi.z + tmp*N.z;

  Vector gradzeta0 = sim->wp.wave_elevation_gradient (&sim->wp, p, sim->time.t);
  
  Vector W = sim->U;

  /* Linear */

  W.x -= gradPhi.x;
  W.y -= gradPhi.y;
  W.z -= gradPhi.z;

  gdouble rhsmn = zeta + sim->time.dt*( vector_scalar_product(&W,&gradzeta)
					+ dzPhin*zeta /* graddzPhi.z*zeta */
					+ phin /* gradphi.z */
					+ Phi2n /* gradPhi2.z */
					+ vector_scalar_product(&W,&gradzeta0)
					);



  return rhsmn;
}

static gdouble explicit_free_surface_update_greville_rhs (Spline2D * sp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;

  GrevillePoints * gr = sp->gr;
  FSData fsd = g_array_index (gr->fsdata, FSData, m + n*gsl_bspline_ncoeffs (sp->w_u));


  Point p = g_array_index (gr->Pi, Point, m + n*gsl_bspline_ncoeffs (sp->w_u));
  /* Vector gradPhi2 = potential_gradient_on_surface (sp, u, v, 7); */
  /* Vector gradPhi = potential_gradient_on_surface (sp, u, v, 3); */
  /* gdouble Phi2 /\* = spline2d_eval (sp, u, v, 7) *\/; */
  /* Vector gradzeta = potential_gradient_on_surface (sp, u, v, 9); */
  /* gdouble zeta = fsd.zeta; */
  gdouble Phi2 = spline2d_eval_greville_point (sp, gr, m, n, 7);

  /* p.x = p.y = p.z = 0.; */
  /* Phi2 = 0.; */
  /* zeta = 0.; */

  /* gint i, j; */
  /* size_t istart, iend, jstart, jend; */
  /* gsl_vector * Bu = gsl_vector_alloc (sp->k); */
  /* gsl_vector * Bv = gsl_vector_alloc (sp->k); */

  /* gsl_bspline_eval_nonzero (u, Bu, &istart, &iend, sp->w_u); */
  /* gsl_bspline_eval_nonzero (v, Bv, &jstart, &jend, sp->w_v); */

  /* for ( i = 0; i < sp->k; i++) { */
  /*   gdouble cu = gsl_vector_get(Bu, i); */
  /*   for ( j = 0; j < sp->k; j++) { */
  /*     gdouble cv = cu*gsl_vector_get(Bv, j); */
  /*     p.x += coeff (sp,istart, jstart+j,0)*cv; */
  /*     p.y += coeff (sp,istart, jstart+j,1)*cv; */
  /*     p.z += coeff (sp,istart, jstart+j,2)*cv; */
  /*     zeta += coeff (sp,istart, jstart+j,9)*cv; */
  /*     Phi2 += coeff (sp,istart, jstart+j,7)*cv; */
  /*   } */
  /*   istart++; */
  /* } */

  /* gsl_vector_free (Bu); */
  /* gsl_vector_free (Bv); */


  

  //Point p = spline2d_eval_gauss_point_point (sp, gp, um, vn);

  	/* gdouble dxdu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 0); */
  	/* gdouble dxdv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 0); */
  	/* gdouble dydu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 1); */
  	/* gdouble dydv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 1); */

  	/* wmn *= fabs(dxdu*dydv-dxdv*dydu); */

  	// gdouble r = sqrt(p.x*p.x+p.y*p.y);

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  //Vector gradPhi2 = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7);
  

  //Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
  

  //gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);
  
  //Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9);
  
  //gdouble zeta= spline2d_eval_gauss_point (sp, gp, m, n, 9);
  
  Vector W = sim->U;


  	/* W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x; */
  	/* W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y; */
  	/* W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z; */

  W.x -= /* fsd. */fsd.gradPhi.x;
  W.y -= /* fsd. */fsd.gradPhi.y;
  /* W.z -= /\* fsd. *\/gradPhi.z; */
  
  gdouble rhsmn = fsd.zeta + sim->time.dt*(  vector_scalar_product(&W,&/* fsd. */fsd.gradzeta)
  						 /* - fsd.dtzeta0 */
  						 /* + sign*vector_scalar_product(&W,&fsd.gradzeta0) */
  						 /* + fsd.gradphi0.z */
  						 /* + /\* fsd. *\/gradPhi.z */
  						 /* + fsd.gradphi.z */
  						 + /* fsd. */fsd.gradPhi2.z
  						 /* - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0) */
  						  // Weakly non-linear terms
  						  /* + (fsd.graddzPhi.z */
  						  /*    + fsd.graddzphi0.z */
  						  /*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) */
  						  /*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) */
  						  /*    )*fsd.zeta */
  						  // Numerical beaches
  						   - 2.*nu*fsd.zeta
  						   + nu*nu/sim->wp.g*Phi2
  						   );

  W.x = -p.y;
  W.y = p.x;
  W.z = 0.;

  rhsmn = fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta) );

  return rhsmn;
}

static gsl_vector *  explicit_free_surface_potential_update_rhs (Spline2D * sp, Simulation * sim)
{
  gint i, j, m, n, ii;
  size_t ustart, vstart;
  gint size = gsl_bspline_ncoeffs (sp->w_u)*gsl_bspline_ncoeffs (sp->w_v);
  gdouble RHS[size];
  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
  }
  
  // Loop over the panels of the patch
  for ( ii = 0; ii < sp->M*sp->N; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    ustart = gp->istart;
    vstart = gp->jstart;

    for ( m = 0; m < ng; m++) {
      gdouble um = g_array_index (gp->ui, gdouble, m);
      gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	  
      for ( n = 0; n < ng; n++) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);	    
	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

	//	Point p = spline2d_eval_gauss_point_point (sp, gp, um, vn);

	/* gdouble dxdu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 0); */
	/* gdouble dxdv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 0); */
	/* gdouble dydu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 1); */
	/* gdouble dydv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 1); */

	/* wmn *= fabs(dxdu*dydv-dxdv*dydu); */

	// gdouble r = sqrt(p.x*p.x+p.y*p.y);


	//gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);

	Vector W = sim->U;
	/* W.x = W.y = W.z = 0.; */
	/* W.x = -1.; */
	/* W.y = 0.5; */

	gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 9);
	gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);
	//Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
	//Vector gradPhi2 = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7);
	/* Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9); */

	gdouble rhsmn = /* 0.5*vector_scalar_product (&fsd.gradphi0,&fsd.gradphi0) - sim->g*fsd.zeta0 */
	  /* + 0.5*vector_scalar_product (&fsd.gradphi,&fsd.gradphi) */ - sim->g*zeta
	  + 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi)
	  /* - fsd.dtphi0 - fsd.dtPhi - fsd.dtphi */;
	
	W.x -= fsd.gradPhi.x;
	W.y -= fsd.gradPhi.y;
	W.z -= fsd.gradPhi.z;
	rhsmn += vector_scalar_product (&W,&fsd.gradPhi);

	/* W.x -= fsd.gradphi.x; */
	/* W.y -= fsd.gradphi.y; */
	/* W.z -= fsd.gradphi.z; */
	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi); */

	/* W.x -= fsd.gradphi0.x; */
	/* W.y -= fsd.gradphi0.y; */
	/* W.z -= fsd.gradphi0.z; */
	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi0); */
	/* rhsmn = 0.; */
	rhsmn = /* (1.-2*nu)* */Phi2 + sim->time.dt*(vector_scalar_product(&W,&fsd.gradPhi2)+rhsmn);
	/* W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x; */
	/* W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y; */
	/* W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z; */

	/* gdouble rhsmn = fsd.zeta + sim->time.dt*(  sign*vector_scalar_product(&W,&fsd.gradzeta) */
	/* 					 /\* - fsd.dtzeta0 *\/ */
	/* 					 /\* + sign*vector_scalar_product(&W,&fsd.gradzeta0) *\/ */
	/* 					 /\* + fsd.gradphi0.z *\/ */
	/* 					 + fsd.gradPhi.z */
	/* 					 /\* + fsd.gradphi.z *\/ */
	/* 					 + fsd.gradPhi2.z */
	/* 					 /\* - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0) *\/ */
	/* 					  // Weakly non-linear terms */
	/* 					  /\* + (fsd.graddzPhi.z *\/ */
	/* 					  /\*    + fsd.graddzphi0.z *\/ */
	/* 					  /\*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) *\/ */
	/* 					  /\*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) *\/ */
	/* 					  /\*    )*fsd.zeta *\/ */
	/* 					  // Numerical beaches */
	/* 					   - 2.*nu*fsd.zeta */
	/* 					   /\* + nu*nu/sim->wp.g*Phi2 *\/ */
	/* 					   ) */
	/*   /\* - 2.*nu*fsd.zeta *\/ */
	/*   /\* + nu*nu/sim->wp.g*Phi2 *\/; */
	
	/* gdouble rhsmn =  (1.-2.*nu)*fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta)); */

	// Vector gradzeta = surface_elevation_perturbation_gradient (sp, um, vn, 9);
	/* Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9); */
	/* gdouble rhsmn = (1.-2.*nu)*fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&gradzeta)); */
	
	//gdouble rhsmn = fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta) - 2.*nu*fsd.zeta + nu*nu/sim->wp.g*Phi2);

	/* gdouble rhsmn = (1.-2.*nu)*spline2d_eval_gauss_point (sp, gp, m, n, 9) + sim->time.dt*( vector_scalar_product(&W,&gradzeta) /\* + spline2d_eval (sp, um, vn, 3) *\/); */

	//gdouble rhsmn = (1.-2.*nu)*fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta) );

	//rhsmn = Phi2 + vector_scalar_product (&/* fsd. */gradPhi,&/* fsd. */gradPhi);

	// Loop over the splines whose support is included in the panel
	for ( i = ustart; i < ustart + sp->k; i++) {
	  gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	  for ( j = vstart; j < vstart + sp->k; j++) {
	    gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	    gint indexi = i + j*gsl_bspline_ncoeffs (sp->w_u);

	    RHS[indexi] += wmnij*(rhsmn);
	  }
	}
	
      }
    }
    
  }

  // Copy lhs and rhs to gsl structures
  gsl_vector * rhs = gsl_vector_alloc (size);
  for ( i = 0; i < size; i++)
    gsl_vector_set (rhs, i, RHS[i]);

  return rhs;
}

static gdouble explicit_free_surface_potential_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
  gint gindex = m+n*ng;

  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  Vector N = g_array_index (gp->Ni, Vector, gindex);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
  SplineCoeffs * sc;
  gint NUT = sp->periodic ? (sp->NU+sp->k-1) : sp->NU;

  Vector W = sim->U;
  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p, sim->time.t);

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gdouble zeta = 0., phid = 0., phidn = 0.;
  gdouble dphiddu = 0., dphiddv = 0.;
  Vector gradphid;
  gradphid.x = gradphid.y = gradphid.z = 0.;

  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    for ( j = 0; j < sp->k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cuv = cu*cv;
      gint j2 = (jstart+j);

      sc = g_ptr_array_index (sp->coeffs, istart+ j2*NUT);

      phid += sc->v[23]*cuv;
      zeta += sc->v[18]*cuv;
      phidn += sc->v[30]*cuv;

      dphiddu += sc->v[23]*cv*cdu;
      dphiddv += sc->v[23]*cu*gsl_matrix_get (Bv, j, 1);
    }
    istart++;
  }

  // zeta is a 2D variable, hence 2d no normal
  // used to compute the gradient
  gradphid.x = c1*dphiddu + c2*dphiddv + phidn*N.x;
  gradphid.y = c3*dphiddu + c4*dphiddv + phidn*N.y;
  gradphid.z = c5*dphiddu + c6*dphiddv + phidn*N.z;

  /* Linear */
  gdouble rhsmn = /* - fsd.dtPhi */
    - sim->g*zeta
    + vector_scalar_product (&W, &fsd.gradPhi)
    - 0.5*vector_scalar_product (&fsd.gradPhi, &fsd.gradPhi);

  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;
  
  rhsmn += vector_scalar_product (&W, &gradphi0)
    + vector_scalar_product (&W, &gradphid);

  //return phid + sim->time.dt*vector_scalar_product (&sim->U, &gradphid);
  return phid + sim->time.dt*rhsmn;
}

static gdouble explicit_free_surface_potential_update_rhs_gauss_store (SPPanel * spp,
								       gint m, gint n,
								       gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
  gint gindex = m+n*ng;

  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  Vector N = g_array_index (gp->Ni, Vector, gindex);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);

  SplineCoeffs * sc;
  gint NUT = sp->periodic ? (sp->NU+sp->k-1) : sp->NU;

  Vector W = sim->U;
  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p, sim->time.t);

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gdouble zeta = 0., phid = 0., phidn = 0.;
  gdouble dphiddu = 0., dphiddv = 0.;
  Vector gradphid;

  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    for ( j = 0; j < sp->k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cuv = cu*cv;
      gint j2 = (jstart+j);

      sc = g_ptr_array_index (sp->coeffs, istart+ j2*NUT);

      phid += sc->v[7]*cuv;
      zeta += sc->v[9]*cuv;
      phidn += sc->v[8]*cuv;

      dphiddu += sc->v[7]*cv*cdu;
      dphiddv += sc->v[7]*cu*gsl_matrix_get (Bv, j, 1);
    }
    istart++;
  }

  gradphid.x = c1*dphiddu + c2*dphiddv + phidn*N.x;
  gradphid.y = c3*dphiddu + c4*dphiddv + phidn*N.y;
  gradphid.z = c5*dphiddu + c6*dphiddv + phidn*N.z;

  /* Linear */
  gdouble rhsmn = /* - fsd.dtPhi */
    - sim->g*zeta
    + vector_scalar_product (&W, &fsd.gradPhi)
    - 0.5*vector_scalar_product (&fsd.gradPhi, &fsd.gradPhi);

  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;
  
  rhsmn += vector_scalar_product (&W, &gradphi0)
    + vector_scalar_product (&W, &gradphid);

  return /* phid + */ sim->time.dt*rhsmn;
}

static gdouble explicit_free_surface_potential_update_abm4_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
  FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);

  Vector W = sim->U;
  /* W.x = W.y = W.z = 0.; */
  /* W.x = -1.; */
  /* W.y = 0.5; */

  gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 9);
  gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);
  //Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
  //Vector gradPhi2 = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7);
  /* Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9); */

  gdouble rhsmn = /* 0.5*vector_scalar_product (&fsd.gradphi0,&fsd.gradphi0) - sim->g*fsd.zeta0 */
    /* + 0.5*vector_scalar_product (&fsd.gradphi,&fsd.gradphi) */ - sim->g*zeta
    + 0.5*vector_scalar_product (&fsd.gradPhi,&fsd.gradPhi)
    /* - fsd.dtphi0 - fsd.dtPhi - fsd.dtphi */;
	
  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;
  rhsmn += vector_scalar_product (&W,&fsd.gradPhi);

  /* W.x -= fsd.gradphi.x; */
  /* W.y -= fsd.gradphi.y; */
  /* W.z -= fsd.gradphi.z; */
  /* rhsmn += vector_scalar_product (&W,&fsd.gradphi); */

  /* W.x -= fsd.gradphi0.x; */
  /* W.y -= fsd.gradphi0.y; */
  /* W.z -= fsd.gradphi0.z; */
  /* rhsmn += vector_scalar_product (&W,&fsd.gradphi0); */
  /* rhsmn = 0.; */
  rhsmn = (vector_scalar_product(&W,&fsd.gradPhi2)+rhsmn);
  /* W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x; */
  /* W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y; */
  /* W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z; */

  /* gdouble rhsmn = (  sign*vector_scalar_product(&W,&fsd.gradzeta) */
  /* 					 /\* - fsd.dtzeta0 *\/ */
  /* 					 /\* + sign*vector_scalar_product(&W,&fsd.gradzeta0) *\/ */
  /* 					 /\* + fsd.gradphi0.z *\/ */
  /* 					 + fsd.gradPhi.z */
  /* 					 /\* + fsd.gradphi.z *\/ */
  /* 					 + fsd.gradPhi2.z */
  /* 					 /\* - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0) *\/ */
  /* 					  // Weakly non-linear terms */
  /* 					  /\* + (fsd.graddzPhi.z *\/ */
  /* 					  /\*    + fsd.graddzphi0.z *\/ */
  /* 					  /\*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) *\/ */
  /* 					  /\*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) *\/ */
  /* 					  /\*    )*fsd.zeta *\/ */
  /* 					  // Numerical beaches */
  /* 					   - 2.*nu*fsd.zeta */
  /* 					   /\* + nu*nu/sim->wp.g*Phi2 *\/ */
  /* 					   ) */
  /*   /\* - 2.*nu*fsd.zeta *\/ */
  /*   /\* + nu*nu/sim->wp.g*Phi2 *\/; */

  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  W.x = -p.y;
  W.y = p.x;
  W.z = 0.;

  rhsmn =  ( vector_scalar_product(&W,&fsd.gradPhi2));

  return rhsmn;
}

static gdouble explicit_free_surface_potential_update_greville_rhs (Spline2D * sp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;

  gdouble u = g_array_index (sp->gr->ui, gdouble, m);
  gdouble v = g_array_index (sp->gr->vj, gdouble, n);

  //Point p = spline2d_eval_gauss_point_point (sp, gp, um, vn);
  Point p = spline2d_eval_point (sp, u, v);

	/* gdouble dxdu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 0); */
	/* gdouble dxdv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 0); */
	/* gdouble dydu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 1); */
	/* gdouble dydv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 1); */

	/* wmn *= fabs(dxdu*dydv-dxdv*dydu); */

	// gdouble r = sqrt(p.x*p.x+p.y*p.y);

	/* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);


	//gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);

	Vector W = sim->U;
	/* W.x = W.y = W.z = 0.; */
	/* W.x = -1.; */
	/* W.y = 0.5; */

	//	gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 9);
	gdouble zeta = spline2d_eval_greville_point (sp, sp->gr, m, n, 9);
//gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);
	gdouble Phi2 = spline2d_eval_greville_point (sp, sp->gr, m, n, 7);
//	Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
	Vector gradPhi = potential_gradient_on_surface (sp, u, v, 3);
//	Vector gradPhi2 = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7);
	Vector gradPhi2 = potential_gradient_on_surface (sp, u, v, 7);

	/* Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9); */

	gdouble rhsmn = /* 0.5*vector_scalar_product (&fsd.gradphi0,&fsd.gradphi0) - sim->g*fsd.zeta0 */
	  /* + 0.5*vector_scalar_product (&fsd.gradphi,&fsd.gradphi) */ - sim->g*zeta
	  + 0.5*vector_scalar_product (&/* fsd. */gradPhi,&/* fsd. */gradPhi)
	  /* - fsd.dtphi0 - fsd.dtPhi - fsd.dtphi */;
	
	W.x -= /* fsd. */gradPhi.x;
	W.y -= /* fsd. */gradPhi.y;
	W.z -= /* fsd. */gradPhi.z;
	rhsmn += vector_scalar_product (&W,&/* fsd. */gradPhi);

	/* W.x -= fsd.gradphi.x; */
	/* W.y -= fsd.gradphi.y; */
	/* W.z -= fsd.gradphi.z; */
	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi); */

	/* W.x -= fsd.gradphi0.x; */
	/* W.y -= fsd.gradphi0.y; */
	/* W.z -= fsd.gradphi0.z; */
	/* rhsmn += vector_scalar_product (&W,&fsd.gradphi0); */
	/* rhsmn = 0.; */
	rhsmn = Phi2 + sim->time.dt*(vector_scalar_product(&W,&/* fsd. */gradPhi2)+rhsmn);
	/* W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x; */
	/* W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y; */
	/* W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z; */

	/* gdouble rhsmn = fsd.zeta + sim->time.dt*(  sign*vector_scalar_product(&W,&fsd.gradzeta) */
	/* 					 /\* - fsd.dtzeta0 *\/ */
	/* 					 /\* + sign*vector_scalar_product(&W,&fsd.gradzeta0) *\/ */
	/* 					 /\* + fsd.gradphi0.z *\/ */
	/* 					 + fsd.gradPhi.z */
	/* 					 /\* + fsd.gradphi.z *\/ */
	/* 					 + fsd.gradPhi2.z */
	/* 					 /\* - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0) *\/ */
	/* 					  // Weakly non-linear terms */
	/* 					  /\* + (fsd.graddzPhi.z *\/ */
	/* 					  /\*    + fsd.graddzphi0.z *\/ */
	/* 					  /\*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) *\/ */
	/* 					  /\*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) *\/ */
	/* 					  /\*    )*fsd.zeta *\/ */
	/* 					  // Numerical beaches */
	/* 					   - 2.*nu*fsd.zeta */
	/* 					   /\* + nu*nu/sim->wp.g*Phi2 *\/ */
	/* 					   ) */
	/*   /\* - 2.*nu*fsd.zeta *\/ */
	/*   /\* + nu*nu/sim->wp.g*Phi2 *\/; */
	
	/* gdouble rhsmn =  (1.-2.*nu)*fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta)); */

	// Vector gradzeta = surface_elevation_perturbation_gradient (sp, um, vn, 9);
	/* Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9); */
	/* gdouble rhsmn = (1.-2.*nu)*fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&gradzeta)); */
	
	//gdouble rhsmn = fsd.zeta + sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta) - 2.*nu*fsd.zeta + nu*nu/sim->wp.g*Phi2);

	/* gdouble rhsmn = (1.-2.*nu)*spline2d_eval_gauss_point (sp, gp, m, n, 9) + sim->time.dt*( vector_scalar_product(&W,&gradzeta) /\* + spline2d_eval (sp, um, vn, 3) *\/); */

	W.x = -p.y;
	W.y = p.x;
	W.z = 0.;
	rhsmn = Phi2 + sim->time.dt*(vector_scalar_product(&W,&gradPhi2));

	return rhsmn;

}

static gsl_vector *  border_rhs (Spline2D * sp, Simulation * sim, gint var)
{
  gint i, j, m, n, ii;
  size_t ustart, vstart;
  gint size = (gsl_bspline_ncoeffs (sp->w_u)-2)*(gsl_bspline_ncoeffs (sp->w_v)-2);
  gdouble RHS[size];
  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
  }
  
  // Loop over the panels of the patch
  for ( ii = 0; ii < sp->M*sp->N; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    ustart = gp->istart;
    vstart = gp->jstart;

    for ( m = 0; m < ng; m++) {
      gdouble um = g_array_index (gp->ui, gdouble, m);
      gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	  
      for ( n = 0; n < ng; n++) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);	    
	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	/* gdouble wmn = g_array_index (gp->wij, gdouble, m+n*ng); */
	//FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
	Point p = spline2d_eval_gauss_point_point (sp, gp, um, vn);



	gdouble rhsmn = (p.x*p.x-2*p.y)*cos(p.y/2.) /* - spline2d_eval (sp, um, vn, 9) */;

	// Loop over the splines whose support is included in the panel
	for ( i = MAX(ustart, 0); i < MIN(ustart + sp->k, gsl_bspline_ncoeffs (sp->w_u)-1); i++) {
	  gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	  for ( j = MAX(vstart, 0); j < MIN(vstart + sp->k, gsl_bspline_ncoeffs (sp->w_v)-1); j++) {
	    gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	    gint indexi = (i-1) + (j-1)*(gsl_bspline_ncoeffs (sp->w_u)-2);

	    RHS[indexi] += wmnij*(rhsmn);
	  }
	}
	
      }
    }
    
  }
  

  // Copy lhs and rhs to gsl structures
  gsl_vector * rhs = gsl_vector_alloc (size);
  for ( i = 0; i < size; i++)
    gsl_vector_set (rhs, i, RHS[i]);

  return rhs;
}

static gdouble test_function (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  Point p = spline2d_eval_point (sp, u, v);
  return (p.x*p.x-2.*p.y)*cos(p.y/2.);
}

static gdouble advection_function (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  Simulation * sim = data;

  gdouble varn = spline2d_eval (sp, u, v, 9);
  Vector grad = potential_gradient_on_surface (sp, u, v, 9);
  Vector U;
  U.x = 1.;
  U.y = -0.5;
  U.z = 0.;

  return varn + sim->time.dt*vector_scalar_product (&U, &grad);
}

/**
 * Advect the surface elevation disturbance according to the free-surface kinematic and
 * dynamic conditions.
 **/
static void explicit_free_surface_elevation_disturbance_update (Simulation * sim, gdouble t, gboolean prediction)
{
  g_test_timer_start ();
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  g_assert (fs != NULL);

  // Original Galerkin method
  g_assert (fs->fit);

  // Get rhs
  fs->rhs = fs->build_fit_rhs (fs, explicit_free_surface_elevation_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
  /* Solve the problem using superlu */
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  /* Copy the solution to the patch */
  fs->copy_fit_solution (fs, fs->rhs, 9);

  fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

gdouble explicit_free_surface_elevation_update_abm4_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  //Vector gradPhi2 = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7);
  //Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
  gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);
  //Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9);
  //gdouble zeta= spline2d_eval_gauss_point (sp, gp, m, n, 9);
	
  Vector W = sim->U;

  gdouble sign = 1;

  /* W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x; */
  /* W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y; */
  /* W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z; */

  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;

  gdouble rhsmn = (  vector_scalar_product(&W,&fsd.gradzeta)
		     /* - fsd.dtzeta0 */
		     /* + sign*vector_scalar_product(&W,&fsd.gradzeta0) */
		     /* + fsd.gradphi0.z */
		     /* + /\* fsd. *\/gradPhi.z */
		     /* + fsd.gradphi.z */
		     + fsd.gradPhi2.z
		     /* - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0) */

		     // Weakly non-linear terms
		     /* + (fsd.graddzPhi.z */
		     /*    + fsd.graddzphi0.z */
		     /*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) */
		     /*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) */
		     /*    )*fsd.zeta */

		     // Numerical beaches
		     - 2.*nu*fsd.zeta
		     + nu*nu/sim->wp.g*Phi2
		     );
	
  W.x = -p.y;
  W.y = p.x;
  W.z = 0.;
  rhsmn = ( vector_scalar_product(&W,&fsd.gradzeta) );

  return rhsmn;
}

static gsl_vector * explicit_free_surface_elevation_disturbance_abm4_rhs (Simulation * sim)
{
  Spline2D * fs = sim->fs->s->patches->data;

  g_assert (fs != NULL);

  // Get rhs
  gsl_vector * gsl_rhs;

  if (fs->periodic) {
    gsl_rhs = fs->build_fit_noflux_rhs (fs, explicit_free_surface_elevation_update_abm4_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }
  else {
    gsl_rhs = fs->build_fit_rhs (fs, explicit_free_surface_elevation_update_abm4_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }

  return gsl_rhs;
}

static gdouble galerkin_free_surface_elevation_rhs_variable_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);

  return fsd.zeta;
}

static gsl_vector * explicit_free_surface_elevation_disturbance_abm4_variable_rhs (Simulation * sim)
{
  Spline2D * fs = sim->fs->s->patches->data;

  g_assert (fs != NULL);

  // Get rhs
  gsl_vector * gsl_rhs;

  if (fs->periodic) {
    gsl_rhs = fs->build_fit_noflux_rhs (fs, galerkin_free_surface_elevation_rhs_variable_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }
  else {
    gsl_rhs = fs->build_fit_rhs (fs, galerkin_free_surface_elevation_rhs_variable_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }

  return gsl_rhs;
}

static gdouble leapfrog_free_surface_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
  gint gindex = m+n*ng;
  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  SplineCoeffs * sc;
  gint NUT = sp->periodic ? (sp->NU+sp->k-1) : sp->NU;
	
  // Numerical beaches
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gdouble Phi2 = 0., dzphi = 0., zeta = 0.;
  gdouble Vn = 0., dvardu = 0., dvardv = 0.;
  Vector gradzeta, W = sim->U;
  Vector gradzeta0 = sim->wp.wave_elevation_gradient (&sim->wp, p, sim->time.t);
  

  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    for ( j = 0; j < sp->k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cuv = cu*cv;
      gint j2 = (jstart+j);

      sc = g_ptr_array_index (sp->coeffs, istart+ j2*NUT);

      dzphi += sc->v[/* 8 */30]*cuv;
      Phi2 += sc->v[23]*cuv;
      // zeta at time t-dt (Leapfrog approach)
      zeta += sc->v[22]*cuv;

      dvardu += sc->v[/* 9 */18]*cv*cdu;
      dvardv += sc->v[/* 9 */18]*cu*gsl_matrix_get (Bv, j, 1);
      Vn += sc->v[10]*cuv;
    }
    istart++;
  }

  // zeta is a 2D variable, hence no normal
  // used to compute the gradient
  gradzeta.x = c1*dvardu + c2*dvardv;
  gradzeta.y = c3*dvardu + c4*dvardv;
  gradzeta.z = 0.;
  

#if 1
  /* Linear */
  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;

  gdouble rhsmn = zeta + 2.*sim->time.dt*(vector_scalar_product(&W,&gradzeta)
					  + fsd.graddzPhi.z*zeta
					  + dzphi
					  + vector_scalar_product(&W,&gradzeta0)
					     
					  // Numerical beaches
					  - 2.*nu*zeta
					  + nu*nu/sim->wp.g*Phi2
					  );
#else
  /* Weak Scatter */
  W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x;
  W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y;
  W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z;

  gdouble rhsmn = zeta + 2.*sim->time.dt*(  vector_scalar_product(&W,&fsd.gradzeta)
  					    - fsd.dtzeta0
  					    + vector_scalar_product(&W,&fsd.gradzeta0)
  					    + fsd.gradphi0.z
  					    + fsd.gradPhi.z
  					    + fsd.gradphi.z
  					    + fsd.gradPhi2.z
  					    - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0)
						  
  					    // Weakly non-linear terms
  					    /* + (fsd.graddzPhi.z */
  					    /*    + fsd.graddzphi0.z */
  					    /*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) */
  					    /*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) */
  					    /*    )*fsd.zeta */
						  
  					    // Numerical beaches
  					    - 2.*nu*zeta
  					    + nu*nu/sim->wp.g*Phi2
  					    );

#endif

  return rhsmn;
}

static gdouble leapfrog_no_speed_elevation_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint k = sp->k;
  Point p = g_array_index (gp->Pi, Point, m + n*sp->nouter);
	
  // Numerical beaches
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);
 
  gdouble Phi2 = 0., Phi2n = 0., zeta = 0.;
  gint i, j;
  size_t istart, jstart;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  
  istart = gp->istart;
  jstart = gp->jstart;

  if (sp->periodic)
    istart -= sp->k-1;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);

      sc = g_ptr_array_index (sp->coeffs, istart+ jj*NUT);

      Phi2 += sc->v[23]*cuv;
      Phi2n += sc->v[30]*cuv;
      zeta += sc->v[22]*cuv;
    }
    istart++;
  }

  return zeta + 2.*sim->time.dt*(Phi2n
				 // Numerical beaches
				 - 2.*nu*zeta
				 + nu*nu/sim->wp.g*Phi2);
}

static gsl_vector *  leapfrog_free_surface_update_rhs (Spline2D * sp, Simulation * sim)
{
  gint i, j, m, n, ii;
  size_t ustart, vstart;
  gint size = gsl_bspline_ncoeffs (sp->w_u)*gsl_bspline_ncoeffs (sp->w_v);
  gdouble RHS[size];
  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
  }
  
  // Loop over the panels of the patch
  for ( ii = 0; ii < sp->M*sp->N; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    ustart = sp->periodic ? gp->istart - sp->k + 1 : gp->istart;
    vstart = gp->jstart;

    for ( m = 0; m < ng; m++) {
      gdouble um = g_array_index (gp->ui, gdouble, m);
      gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	  
      for ( n = 0; n < ng; n++) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);	    
	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

	/* Point p = spline2d_eval_gauss_point_point (sp, gp, um, vn); */
	Point p = g_array_index (gp->Pi, Point, m + n*ng);

	/* gdouble dxdu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 0); */
	/* gdouble dxdv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 0); */
	/* gdouble dydu = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 1, 0, 1); */
	/* gdouble dydv = spline2d_derivative_eval_gauss_point (sp, gp, m, n, 0, 1, 1); */

	/* wmn *= fabs(dxdu*dydv-dxdv*dydu); */

	// gdouble r = sqrt(p.x*p.x+p.y*p.y);

	/* For numerical beaches */
	/* gdouble nu/\*  = r > (sim->wp.r - sim->wp.Cw) ? *\/ */
	/*   /\* 3.*sim->wp.Cs/pow(sim->wp.Cw, 3.)*pow(r-(sim->wp.r - sim->wp.Cw), 2.)  : 0. *\/; */
	
	/* // For rectangular domain */
	/* nu = p.x < -25 ? 3.*sim->wp.Cs/pow(10, 3.)*pow(fabs(p.x+25), 2.) : fabs(p.y) > 20 ? 3.*sim->wp.Cs/pow(10, 3.)*pow(fabs(p.y)-20, 2.) : 0.; */
	gdouble nu = 0.;
	if ( sim->numerical_beaches )
	  nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

	//Vector gradPhi2 = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 7);
	//Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
	gdouble Phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 7);
	//Vector gradzeta = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9);
	//gdouble zeta= spline2d_eval_gauss_point (sp, gp, m, n, 9);
	
	Vector W = sim->U;

	gdouble sign = 1;

	/* W.x -= fsd.gradPhi.x + fsd.gradphi.x + fsd.gradphi0.x; */
	/* W.y -= fsd.gradPhi.y + fsd.gradphi.y + fsd.gradphi0.y; */
	/* W.z -= fsd.gradPhi.z + fsd.gradphi.z + fsd.gradphi0.z; */

	W.x -= fsd.gradPhi.x;
	W.y -= fsd.gradPhi.y;
	W.z -= fsd.gradPhi.z;

	// zeta at time t-dt (Leapfrog approach)
	gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 22);

	gdouble rhsmn = zeta + 2.*sim->time.dt*(  vector_scalar_product(&W,&fsd.gradzeta)
						  /* - fsd.dtzeta0 */
						  /* + sign*vector_scalar_product(&W,&fsd.gradzeta0) */
						  /* + fsd.gradphi0.z */
						  /* + /\* fsd. *\/gradPhi.z */
						  /* + fsd.gradphi.z */
						  + fsd.gradPhi2.z
						  /* - vector_scalar_product(&fsd.gradPhi2,&fsd.gradzeta0) */
						  
						  // Weakly non-linear terms
						  /* + (fsd.graddzPhi.z */
						  /*    + fsd.graddzphi0.z */
						  /*    - vector_scalar_product(&fsd.graddzPhi,&fsd.gradzeta0) */
						  /*    - vector_scalar_product(&fsd.graddzphi0,&fsd.gradzeta0) */
						  /*    )*fsd.zeta */
						  
						  // Numerical beaches
						  - 2.*nu*/* fsd. */zeta
						  + nu*nu/sim->wp.g*Phi2
						  );

	/* W.x = -p.y; */
	/* W.y = p.x; */
	/* W.z = 0.; */
	/* rhsmn = zeta + 2.*sim->time.dt*( vector_scalar_product(&W,&fsd.gradzeta) ); */

	// Loop over the splines whose support is included in the panel
	for ( i = ustart; i < ustart + sp->k; i++) {
	  gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	  for ( j = vstart; j < vstart + sp->k; j++) {
	    gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	    gint indexi = i + j*gsl_bspline_ncoeffs (sp->w_u);

	    RHS[indexi] += wmnij*(rhsmn);
	  }
	}
	
      }
    }
    
  }

  gint NU = gsl_bspline_ncoeffs (sp->w_u);
  gint NV = gsl_bspline_ncoeffs (sp->w_v);
  // Zero normal derivative near object
/* #ifdef NO_FLUX */
  for ( i = 0; i < NU; i++) {
    gint index1 = i;
    RHS[index1] = 0.;
  }
/* #endif */

  // Continuity of variable on boundary
  for ( i = 0; i < NV; i++) {
    gint index1 = (i+1)*NU - 1;
    gint index2 = i*NU;

    RHS[index1] += RHS[index2];
    RHS[index2] = 0.;
  }

  // Copy lhs and rhs to gsl structures
  gsl_vector * rhs = gsl_vector_alloc (size);
  for ( i = 0; i < size; i++)
    gsl_vector_set (rhs, i, RHS[i]);

  return rhs;
}



gdouble explicit_no_speed_elevation_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 18);
  gdouble Phi2dn = spline2d_eval_gauss_point (sp, gp, m, n, 30);
  gdouble Phi2d = spline2d_eval_gauss_point (sp, gp, m, n, 23);

  return zeta + sim->time.dt*(Phi2dn
 			      // Numerical beaches
 			      - 2.*nu*zeta
			      + nu*nu/sim->wp.g*Phi2d);
}

gdouble explicit_no_speed_elevation_update_rhs_gauss_store (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;
  gint  i, j, k = sp->k, ii, jj;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = gp->istart;
  gint vstart = gp->jstart;
  if (sp->periodic)
    ustart -= k-1;

  double zeta = 0., Phi2dn = 0., Phi2d = 0.;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      jj = (vstart+j);

      sc = g_ptr_array_index (sp->coeffs, ii+ jj*NUT);

      Phi2d += sc->v[7]*cuv;
      Phi2dn += sc->v[8]*cuv;
      zeta += sc->v[9]*cuv;
    }
  }


  /* gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 9); */
  /* gdouble Phi2dn = spline2d_eval_gauss_point (sp, gp, m, n, 8); */
  /* gdouble Phi2d = spline2d_eval_gauss_point (sp, gp, m, n, 7); */

  return /* zeta +  */sim->time.dt*(Phi2dn
 			      // Numerical beaches
 			      - 2.*nu*zeta
			      + nu*nu/sim->wp.g*Phi2d);
}

void leapfrog_no_speed_elevation_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;

  // Leapfrog scheme is explicit scheme for the first time step
  if (/* sim->time.t == 0. */1) {
    
    fs->rhs = fs->build_fit_rhs (fs, explicit_no_speed_elevation_update_rhs_gauss, sim, NULL, NULL, fs->rhs);			
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 9);
    return;
  }

  if (sim->verbose)
    g_test_timer_start ();
    
  fs->rhs = fs->build_fit_rhs (fs, leapfrog_no_speed_elevation_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->copy_fit_solution (fs, fs->rhs, 9);

  if (sim->verbose)
    fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

void abm4_no_speed_elevation_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;
  fs->rhs = fs->rhs_vector (fs, fs->rhs);

  // First 4 time-steps
  if (sim->time.itime < 4) {
    fs->rhs = fs->build_fit_rhs (fs, explicit_no_speed_elevation_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 9);
    return;
  }
  
  // Adam-Bashforth-Moulton method
  if (prediction) {
    // dt/24*(55 rhs4 - 59 rhs3 + 37 rhs2 - 9 rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(55.*gsl_vector_get (sim->fseu_rhs4, i)
			    - 59.*gsl_vector_get (sim->fseu_rhs3, i)
			    + 37.*gsl_vector_get (sim->fseu_rhs2, i)
			    -9.*gsl_vector_get (sim->fseu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  else {
    // dt/24*(9 rhs4 + 19 rhs3 - 5 rhs2 + rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(9.*gsl_vector_get (sim->fseu_rhs4, i)
			    + 19.*gsl_vector_get (sim->fseu_rhs3, i)
			    - 5.*gsl_vector_get (sim->fseu_rhs2, i)
			    + gsl_vector_get (sim->fseu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->add_fit_solution (fs, fs->rhs, 9, 18);
}

void abm4_no_speed_elevation_store (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  // Once prediction done rhs1 is no longer needed and the
  // new rhs should be stored or replaced by the corrected one
  if (prediction) {
    gsl_vector * fse_rhs5 = sim->fseu_rhs1;
    sim->fseu_rhs1 = sim->fseu_rhs2;
    sim->fseu_rhs2 = sim->fseu_rhs3;
    sim->fseu_rhs3 = sim->fseu_rhs4;
    sim->fseu_rhs4 = fse_rhs5;
  }

  sim->fseu_rhs4 = fs->build_fit_rhs (fs, explicit_no_speed_elevation_update_rhs_gauss_store, sim, NULL, NULL, sim->fseu_rhs4);
}

gdouble explicit_no_speed_elevation2_update_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;
  gint  i, j, k = sp->k, ii, jj;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;
  gint gindex = m + n*ng;
  Point p = g_array_index (gp->Pi, Point, gindex);

  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = gp->istart;
  gint vstart = gp->jstart;
  if (sp->periodic)
    ustart -= k-1;

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  gdouble zeta2 = 0., zeta1 = 0.;
  gdouble Phi2dn = 0., Phi2d = 0.;
  gdouble dphi1du = 0., dphi1dv = 0.;
  gdouble dzeta1du = 0., dzeta1dv = 0.;
  gdouble dphi1dzdz = 0.;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cuv = cu*cv;
      gdouble cudv = cu*gsl_matrix_get (Bv, j, 1);
      gdouble cvdu = cdu*cv;

      jj = (vstart+j);

      sc = g_ptr_array_index (sp->coeffs, ii + jj*NUT);

      zeta2 += sc->v[39]*cuv;
      zeta1 += sc->v[18]*cuv;
      Phi2dn += sc->v[38]*cuv;
      Phi2d += sc->v[37]*cuv;
      dphi1dzdz += sc->v[42]*cuv;
      dphi1du += sc->v[7/*23*/]*cvdu;
      dphi1dv += sc->v[7/*23*/]*cudv;
      dzeta1du += sc->v[9/* 18 */]*cvdu;
      dzeta1dv += sc->v[9/* 18 */]*cudv;
    }
  }

  /* Metric coefficients for general gradient */
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);

  /* gdouble zeta2 = spline2d_eval_gauss_point (sp, gp, m, n, 39); */
  /* gdouble zeta1 = spline2d_eval_gauss_point (sp, gp, m, n, 18); */
  /* gdouble Phi2dn = spline2d_eval_gauss_point (sp, gp, m, n, 38); */
  /* gdouble Phi2d = spline2d_eval_gauss_point (sp, gp, m, n, 37); */
  
  Vector gradphi1;
  //    = potential_gradient2d_on_surface_gauss_point (sp, gp, m, n, 37);
  gradphi1.x = c1*dphi1du + c2*dphi1dv;
  gradphi1.y = c3*dphi1du + c4*dphi1dv;
  gradphi1.z = 0.;
  Vector gradzeta1;
  //  = potential_gradient2d_on_surface_gauss_point (sp, gp, m, n, 18);
  gradzeta1.x = c1*dzeta1du + c2*dzeta1dv;
  gradzeta1.y = c3*dzeta1du + c4*dzeta1dv;
  gradzeta1.z = 0.;

  Vector gradphi02 = sim->wp.wave_potential2_gradient (&sim->wp, p, sim->time.t+sim->time.dt);
  gdouble dtzeta02 = sim->wp.wave_elevation2_time_derivative (&sim->wp, p, sim->time.t+sim->time.dt);

  return zeta2 + sim->time.dt*(Phi2dn
			       + gradphi02.z
			       - dtzeta02
			       - vector_scalar_product (&gradphi1, &gradzeta1)
			       - zeta1*dphi1dzdz
			       // Numerical beaches
			       - 2.*nu*zeta2
			       + nu*nu/sim->wp.g*Phi2d);
}

gdouble explicit_no_speed_elevation2_update_rhs_gauss_store (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 9);
  gdouble Phi2dn = spline2d_eval_gauss_point (sp, gp, m, n, 8);
  gdouble Phi2d = spline2d_eval_gauss_point (sp, gp, m, n, 7);

  return /* zeta +  */sim->time.dt*(Phi2dn
 			      // Numerical beaches
 			      - 2.*nu*zeta
			      + nu*nu/sim->wp.g*Phi2d);
}

static void abm4_no_speed_elevation2_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;
  fs->rhs = fs->rhs_vector (fs, fs->rhs);

  // First 4 time-steps
  if (sim->time.itime < 4) {
    fs->rhs = fs->build_fit_rhs (fs, explicit_no_speed_elevation2_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 36);
    return;
  }
  
  // Adam-Bashforth-Moulton method
  if (prediction) {
    // dt/24*(55 rhs4 - 59 rhs3 + 37 rhs2 - 9 rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(55.*gsl_vector_get (sim->fseu2_rhs4, i)
			    - 59.*gsl_vector_get (sim->fseu2_rhs3, i)
			    + 37.*gsl_vector_get (sim->fseu2_rhs2, i)
			    -9.*gsl_vector_get (sim->fseu2_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  else {
    // dt/24*(9 rhs4 + 19 rhs3 - 5 rhs2 + rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(9.*gsl_vector_get (sim->fseu2_rhs4, i)
			    + 19.*gsl_vector_get (sim->fseu2_rhs3, i)
			    - 5.*gsl_vector_get (sim->fseu2_rhs2, i)
			    + gsl_vector_get (sim->fseu2_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->add_fit_solution (fs, fs->rhs, 36, 39);
}

static void abm4_no_speed_elevation2_store (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  // Once prediction done rhs1 is no longer needed and the
  // new rhs should be stored or replaced by the corrected one
  if (prediction) {
    gsl_vector * fse_rhs5 = sim->fseu2_rhs1;
    sim->fseu2_rhs1 = sim->fseu2_rhs2;
    sim->fseu2_rhs2 = sim->fseu2_rhs3;
    sim->fseu2_rhs3 = sim->fseu2_rhs4;
    sim->fseu2_rhs4 = fse_rhs5;
  }

  sim->fseu2_rhs4 = fs->build_fit_rhs (fs, explicit_no_speed_elevation2_update_rhs_gauss_store, sim, NULL, NULL, sim->fseu2_rhs4);
}

static void explicit_no_speed_potential_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;

  fs->rhs = fs->build_fit_rhs (fs, explicit_no_speed_potential_update_rhs_gauss, sim, NULL, NULL, fs->rhs);			
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->copy_fit_solution (fs, fs->rhs, 7);
}

void abm4_no_speed_potential_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;
  fs->rhs = fs->rhs_vector (fs, fs->rhs);

  // First 4 time-steps
  if (  sim->time.itime < 4 ) {
    fs->rhs = fs->build_fit_rhs (fs, explicit_no_speed_potential_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 7);
    return;
  }

  // Adam-Bashforth-Moulton method
  if (prediction) {
    // dt/24*(55 rhs4 - 59 rhs3 + 37 rhs2 - 9 rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(55.*gsl_vector_get (sim->fspu_rhs4, i)
			    - 59.*gsl_vector_get (sim->fspu_rhs3, i)
			    + 37.*gsl_vector_get (sim->fspu_rhs2, i)
			    -9.*gsl_vector_get (sim->fspu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  else {
    // dt/24*(9 rhs4 + 19 rhs3 - 5 rhs2 + rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(9.*gsl_vector_get (sim->fspu_rhs4, i)
			    + 19.*gsl_vector_get (sim->fspu_rhs3, i)
			    - 5.*gsl_vector_get (sim->fspu_rhs2, i)
			    + gsl_vector_get (sim->fspu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }

  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->add_fit_solution (fs, fs->rhs, 7, 23);
}

void abm4_no_speed_potential_store (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  // Once prediction done rhs1 is no longer needed and the
  // new rhs should be stored or replaced by the corrected one
  if (prediction) {
    gsl_vector * fsp_rhs5 = sim->fspu_rhs1;
    sim->fspu_rhs1 = sim->fspu_rhs2;
    sim->fspu_rhs2 = sim->fspu_rhs3;
    sim->fspu_rhs3 = sim->fspu_rhs4;
    sim->fspu_rhs4 = fsp_rhs5;
  }

  sim->fspu_rhs4 = fs->build_fit_rhs (fs, explicit_no_speed_potential_update_rhs_gauss_store, sim, NULL, NULL, sim->fspu_rhs4);
}

/******************************/

gdouble explicit_no_speed_potential2_update_rhs_gauss (SPPanel * spp,
						       gint m, gint n,
						       gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  gint ng = sp->nouter;
  GaussPoints * gp = spp->outer;
  gint  i, j, k = sp->k, ii, jj;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;
  Point p = g_array_index (gp->Pi, Point, m+n*ng);

  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = gp->istart;
  gint vstart = gp->jstart;
  if (sp->periodic)
    ustart -= k-1;

  gdouble zeta2 = 0., Phid2 = 0.;
  gdouble zeta1 = 0., dphi1dzdt = 0.;
  gdouble phi1n0 = 0., phi1n1 = 0., phi1n2 = 0., phi1n3 = 0., phi1n4 = 0.;
  gdouble zeta02 = sim->wp.wave_elevation2 (p.x, p.y, sim->time.t+sim->time.dt, &sim->wp);
  gdouble dtphi02 = sim->wp.wave_potential2_dt (&sim->wp, p, sim->time.t+sim->time.dt);

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      jj = (vstart+j);

      sc = g_ptr_array_index (sp->coeffs, ii + jj*NUT);

      Phid2 += sc->v[37]*cuv; /* 7 */
      zeta2 += sc->v[39]*cuv; /* 9 */
      // zeta1 += sc->v[9]*cuv;
      phi1n0 += sc->v[8]*cuv;
      phi1n1 += sc->v[30]*cuv;
      phi1n2 += sc->v[40]*cuv;
      phi1n3 += sc->v[41]*cuv;
      phi1n3 += sc->v[42]*cuv;
    }
  }

  dphi1dzdt = 1./(12.*sim->time.dt)*(25.*phi1n0 - 48.*phi1n1 + 36.*phi1n2 - 16.*phi1n3 + 3.*phi1n4);

  Vector gradphi1
    = potential_gradient2d_on_surface_gauss_point (sp, gp, m, n, 37);

  return  Phid2 - sim->time.dt*(sim->wp.g*zeta2
				+ sim->wp.g*zeta02 
				- dtphi02
				+ zeta1*dphi1dzdt
				+ 0.5*vector_scalar_product (&gradphi1, &gradphi1));
}

gdouble explicit_no_speed_potential2_update_rhs_gauss_store (SPPanel * spp,
							     gint m, gint n,
							     gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint  i, j, k = sp->k, ii, jj;
  gint NUT = sp->periodic ? (sp->NU+k-1) : sp->NU;
  SplineCoeffs * sc;

  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = gp->istart;
  gint vstart = gp->jstart;
  if (sp->periodic)
    ustart -= k-1;

  gdouble zeta = 0., Phid = 0.;
  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      jj = (vstart+j);

      sc = g_ptr_array_index (sp->coeffs, ii+ jj*NUT);

      Phid += sc->v[7]*cuv;
      zeta += sc->v[9]*cuv;
      /* phi1n0 += sc->v[8]*cuv; */
      /* phi1n1 += sc->v[30]*cuv; */
      /* phi1n2 += sc->v[40]*cuv; */
      /* phi1n3 += sc->v[41]*cuv; */
      /* phi1n3 += sc->v[42]*cuv; */
    }
  }

  return  /* Phid */ - sim->time.dt*(sim->wp.g*zeta);
}

static void abm4_no_speed_potential2_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;
  fs->rhs = fs->rhs_vector (fs, fs->rhs);

  // First 4 time-steps
  if (  sim->time.itime < 4 ) {
    fs->rhs = fs->build_fit_rhs (fs, explicit_no_speed_potential2_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 7);
    return;
  }

  // Adam-Bashforth-Moulton method
  if (prediction) {
    // dt/24*(55 rhs4 - 59 rhs3 + 37 rhs2 - 9 rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(55.*gsl_vector_get (sim->fspu2_rhs4, i)
			    - 59.*gsl_vector_get (sim->fspu2_rhs3, i)
			    + 37.*gsl_vector_get (sim->fspu2_rhs2, i)
			    -9.*gsl_vector_get (sim->fspu2_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  else {
    // dt/24*(9 rhs4 + 19 rhs3 - 5 rhs2 + rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(9.*gsl_vector_get (sim->fspu2_rhs4, i)
			    + 19.*gsl_vector_get (sim->fspu2_rhs3, i)
			    - 5.*gsl_vector_get (sim->fspu2_rhs2, i)
			    + gsl_vector_get (sim->fspu2_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }

  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->add_fit_solution (fs, fs->rhs, 7, 23);
}

static void abm4_no_speed_potential2_store (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  // Once prediction done rhs1 is no longer needed and the
  // new rhs should be stored or replaced by the corrected one
  if (prediction) {
    gsl_vector * fsp_rhs5 = sim->fspu2_rhs1;
    sim->fspu2_rhs1 = sim->fspu2_rhs2;
    sim->fspu2_rhs2 = sim->fspu2_rhs3;
    sim->fspu2_rhs3 = sim->fspu2_rhs4;
    sim->fspu2_rhs4 = fsp_rhs5;
  }

  sim->fspu2_rhs4 = fs->build_fit_rhs (fs, explicit_no_speed_potential2_update_rhs_gauss_store, sim, NULL, NULL, sim->fspu2_rhs4);
}

static void leapfrog_free_surface_elevation_disturbance_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;

  // Leapfrog scheme is explicit scheme for the first time step
  if (sim->time.t == 0.) {
    fs->rhs = fs->build_fit_rhs (fs, explicit_free_surface_elevation_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 9);
    return;
  }

  if (sim->verbose)
    g_test_timer_start ();

  /* Get rhs */
  fs->rhs = fs->build_fit_rhs (fs, leapfrog_free_surface_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
  /* Solve the problem using superlu */
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  /* Copy the solution to the patch */
  fs->copy_fit_solution (fs, fs->rhs, 9);

  if (sim->verbose)
    fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

static void abm4_free_surface_elevation_disturbance_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;
  fs->rhs = fs->rhs_vector (fs, fs->rhs);

  // First 4 time-steps
  if (sim->time.itime < 4) {

#if NOFLUX
    fs->rhs = fs->build_fit_noflux_rhs (fs, explicit_free_surface_elevation_update_rhs_gauss, sim, zero_flux, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit_noflux, fs->rhs);
#else
    fs->rhs = fs->build_fit_rhs (fs, explicit_free_surface_elevation_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
#endif

    fs->copy_fit_solution (fs, fs->rhs, 9);
    return;
  }

  // Adam-Bashforth-Moulton method
  if (prediction) {
    // dt/24*(55 rhs4 - 59 rhs3 + 37 rhs2 - 9 rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(55.*gsl_vector_get (sim->fseu_rhs4, i)
			    - 59.*gsl_vector_get (sim->fseu_rhs3, i)
			    + 37.*gsl_vector_get (sim->fseu_rhs2, i)
			    -9.*gsl_vector_get (sim->fseu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  else {
    // dt/24*(9 rhs4 + 19 rhs3 - 5 rhs2 + rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(9.*gsl_vector_get (sim->fseu_rhs4, i)
			    + 19.*gsl_vector_get (sim->fseu_rhs3, i)
			    - 5.*gsl_vector_get (sim->fseu_rhs2, i)
			    + gsl_vector_get (sim->fseu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  
#if NOFLUX
  ccs_problem_lu_solve (fs->fit_noflux, fs->rhs);
#else
  ccs_problem_lu_solve (fs->fit, fs->rhs);
#endif

  fs->add_fit_solution (fs, fs->rhs, 9, 18);
}

static void abm4_free_surface_elevation_disturbance_store (Simulation * sim,
							   gdouble t,
							   gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  // Once prediction done rhs1 is no longer needed and the
  // new rhs should be stored or replaced by the corrected one
  if (prediction) {
    gsl_vector * fse_rhs5 = sim->fseu_rhs1;
    sim->fseu_rhs1 = sim->fseu_rhs2;
    sim->fseu_rhs2 = sim->fseu_rhs3;
    sim->fseu_rhs3 = sim->fseu_rhs4;
    sim->fseu_rhs4 = fse_rhs5;
  }

#if NOFLUX
  sim->fseu_rhs4 = fs->build_fit_noflux_rhs (fs, explicit_free_surface_elevation_update_rhs_gauss_store, sim, zero_flux, NULL, sim->fseu_rhs4);
#else
  sim->fseu_rhs4 = fs->build_fit_rhs (fs, explicit_free_surface_elevation_update_rhs_gauss_store, sim, NULL, NULL, sim->fseu_rhs4);
#endif
}

static void explicit_free_surface_elevation_disturbance_update_greville (Simulation * sim)
{
  g_test_timer_start ();
  Spline2D * sp = sim->fs->s->patches->data;

  if (sp->periodic)
    spline2d_fit_greville_periodic (sp, explicit_free_surface_update_greville_rhs, sim, 9);
  else
    spline2d_fit_greville (sp, explicit_free_surface_update_greville_rhs, sim, 9);

  fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

static void semi_implicit_free_surface_elevation_disturbance_update_greville (Simulation * sim)
{
  g_test_timer_start ();
  Spline2D * sp = sim->fs->s->patches->data;
   gint i, j, a, b;
  GrevillePoints * gr = sp->gr;
  gint NU = gsl_bspline_ncoeffs (sp->w_u);
  gint NV = gsl_bspline_ncoeffs (sp->w_v);
  gint size = NU*NV;
  gsl_vector * rhs = gsl_vector_alloc (size);
  gdouble A0[size][size];

  for ( i = 0; i < size; i++)
    for ( j = 0; j < size; j++)
      A0[i][j] = 0.;
  
  for ( i = 0; i < NU; i++) {
    gdouble u = g_array_index (gr->ui, gdouble, i);
    gsl_matrix * Bu = g_ptr_array_index (gr->Bu, i);
    gint istart = g_array_index (gr->ustart, gint, i);
    if (sp->periodic)
      istart -= sp->k-1;
    for ( j = 0; j < NV; j++) {
      gdouble v = g_array_index (gr->vj, gdouble, j);
      gsl_matrix * Bv = g_ptr_array_index (gr->Bv, j);
      gint jstart = g_array_index (gr->vstart, gint, j);
      FSData fsd = g_array_index (gr->fsdata, FSData, i + j*NU);

      // Calculate W at point (um, vn)
      Vector W = sim->U;
      Vector xu, xv;
      gdouble zeta, Phi2, Phi2n, zetan;
      xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
      zeta = Phi2 = Phi2n = zetan = 0.;

      for ( a = 0; a < sp->k; a++) {
	gdouble cu = gsl_matrix_get (Bu, a, 0);
	gdouble cdu = gsl_matrix_get (Bu, a, 1);
	gint ii = (istart+a);
	for ( b = 0; b < sp->k; b++) {
	  gdouble cv = gsl_matrix_get (Bv, b, 0);
	  gdouble cudv = cu*gsl_matrix_get (Bv, b, 1);
	  gdouble cvdu = cv*cdu;
	  gdouble cuv = cu*cv;
	  gint jj = (jstart+b);
	  xu.x += coeff (sp,ii,jj, 0)*cvdu;
	  xu.y += coeff (sp,ii,jj, 1)*cvdu;
	  xu.z += coeff (sp,ii,jj, 2)*cvdu;
	  xv.x += coeff (sp,ii,jj, 0)*cudv;
	  xv.y += coeff (sp,ii,jj, 1)*cudv;
	  xv.z += coeff (sp,ii,jj, 2)*cudv;
	  Phi2 += coeff (sp,ii,jj, 7)*cuv;
	  Phi2n += coeff (sp,ii,jj, 8)*cuv;
	  zeta += coeff (sp,ii,jj, 9)*cuv;
	  zetan += coeff (sp,ii,jj, 10)*cuv;
	}
      }

      gdouble rhsmn = fsd.zeta;

      /* Lame coefficients squared */
      gdouble h1_2 = xu.x*xu.x + xu.y*xu.y + xu.z*xu.z;
      gdouble h2_2 = xv.x*xv.x + xv.y*xv.y + xv.z*xv.z;
      /* xu = vector_normalise (xu); */
      /* xv = vector_normalise (xv); */

      Point p = g_array_index (gr->Pi, Point, i + j*NU);
      Vector N = g_array_index (gr->Ni, Vector, i + j*NU);
      W.x = -p.y;
      W.y = p.x;
      W.z = 0.;

      xu.x /= h1_2; xu.y /= h1_2; xu.z /= h1_2;
      xv.x /= h2_2; xv.y /= h2_2; xv.z /= h2_2;

      gdouble term1 = 0.5*sim->time.dt*vector_scalar_product (&W,&xu);
      gdouble term2 = 0.5*sim->time.dt*vector_scalar_product (&W,&xv);
	// Phi2n = -Phi0n
      gdouble term3 = -0.5*sim->time.dt*zetan*vector_scalar_product (&W,&N);

      rhsmn += sim->time.dt*0.5*vector_scalar_product(&W,&fsd.gradzeta) + term3;

      for ( a = istart; a < istart + sp->k; a++) {
      	for ( b = jstart; b < jstart + sp->k; b++) {
      	  A0[i+j*NU][a+b*NU] = gsl_matrix_get (Bu, a-istart, 0)*gsl_matrix_get (Bv, b-jstart, 0) + term1*gsl_matrix_get (Bu, a-istart, 1)*gsl_matrix_get (Bv, b-jstart, 0) + term2*gsl_matrix_get (Bu, a-istart, 0)*gsl_matrix_get (Bv, b-jstart, 1);
      	}
      }
 
      gsl_vector_set (rhs, i+j*NU, rhsmn);
    }
  }

  /* Storage in Compressed Column Storage (CCS) format for superlu */
  CCSProblem * css = ccs_problem_new ();
  gint count = 0;
  for ( i = 0; i < size; i++) {
    g_array_append_val (css->index, count);
    for ( j = 0; j < size; j++) {
      if (A0[i][j] != 0.) {
  	g_array_append_val (css->matrix, A0[i][j]);
  	g_array_append_val (css->column, j);
  	count++;
      }
    }
  }
  g_array_append_val (css->index, count);

  ccs_problem_lu_solve (css, rhs);

  for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) {
    for ( j = 0; j < gsl_bspline_ncoeffs (sp->w_v); j++) {
      coeff_assign (sp, i, j, 9, gsl_vector_get (rhs, i+j*gsl_bspline_ncoeffs (sp->w_u)));
    }
  }

  gsl_vector_free (rhs);



  /* spline2d_fit_greville_border (sp, explicit_free_surface_update_greville_rhs, sim, 9); */

  /* gint i, j, a, b; */
  /* GrevillePoints * gr = sp->gr; */
  /* gint NU = gsl_bspline_ncoeffs (sp->w_u); */
  /* gint NV = gsl_bspline_ncoeffs (sp->w_v); */
  /* gint size = NU*NV; */
  /* gsl_vector * rhs = gsl_vector_alloc (size); */
  /* gdouble A0[size][size]; */
  
  /* for ( i = 0; i < NU; i++) { */
  /*   gdouble u = g_array_index (gr->ui, gdouble, i); */
  /*   for ( j = 0; j < NV; j++) { */
  /*     gdouble v = g_array_index (gr->vj, gdouble, j); */

  /*     for ( a = 0; a < NU; a++) { */
  /* 	for ( b = 0; b < NV; b++) { */
  /* 	  A0[i+j*NU][a+b*NU] = spline2d_eval_spline (sp, a, b, u, v); */
  /* 	} */
  /*     } */
  /*     gsl_vector_set (rhs, i+j*NU, func (sp, u, v, data)); */
  /*   } */
  /* } */

  /* /\* Storage in Compressed Column Storage (CCS) format for superlu *\/ */
  /* CCSProblem * css = ccs_problem_new (); */
  /* gint count = 0; */
  /* for ( i = 0; i < size; i++) { */
  /*   g_array_append_val (css->index, count); */
  /*   for ( j = 0; j < size; j++) { */
  /*     if (A0[i][j] != 0.) { */
  /* 	g_array_append_val (css->matrix, A0[i][j]); */
  /* 	g_array_append_val (css->column, j); */
  /* 	count++; */
  /*     } */
  /*   } */
  /* } */
  /* g_array_append_val (css->index, count); */

  /* ccs_problem_lu_solve (css, rhs); */

  /* for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) { */
  /*   for ( j = 0; j < gsl_bspline_ncoeffs (sp->w_v); j++) { */
  /*     coeff_assign (sp, i, j, var, gsl_vector_get (rhs, i+j*gsl_bspline_ncoeffs (sp->w_u))); */
  /*   } */
  /* } */

  /* gsl_vector_free (rhs); */


  fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

static void explicit_free_surface_disturbance_potential_update (Simulation * sim, gdouble t, gboolean prediction)
{
  g_test_timer_start ();
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  g_assert (fs != NULL);

  // Original Galerkin method
  if (!fs->fit)
    fs->fit = fs->build_fit_matrix (fs);

  fs->rhs = fs->build_fit_rhs (fs, explicit_free_surface_potential_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
  ccs_problem_lu_solve (fs->fit, fs->rhs);

  /* Copy the solution to the patch */
  fs->copy_fit_solution (fs, fs->rhs, 7);

  fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

static void abm4_free_surface_disturbance_potential_update (Simulation * sim,
							    gdouble t,
							    gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;
  fs->rhs = fs->rhs_vector (fs, fs->rhs);

  // First 4 time-steps
  if (  sim->time.itime < 4 ) {
    fs->rhs = fs->build_fit_rhs (fs, explicit_free_surface_potential_update_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 7);
    return;
  }

  // Adam-Bashforth-Moulton method
  if (prediction) {
    // dt/24*(55 rhs4 - 59 rhs3 + 37 rhs2 - 9 rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(55.*gsl_vector_get (sim->fspu_rhs4, i)
			    - 59.*gsl_vector_get (sim->fspu_rhs3, i)
			    + 37.*gsl_vector_get (sim->fspu_rhs2, i)
			    -9.*gsl_vector_get (sim->fspu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  else {
    // dt/24*(9 rhs4 + 19 rhs3 - 5 rhs2 + rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(9.*gsl_vector_get (sim->fspu_rhs4, i)
			    + 19.*gsl_vector_get (sim->fspu_rhs3, i)
			    - 5.*gsl_vector_get (sim->fspu_rhs2, i)
			    + gsl_vector_get (sim->fspu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }

  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->add_fit_solution (fs, fs->rhs, 7, 23);
}

static void abm4_free_surface_disturbance_potential_store (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  // Once prediction done rhs1 is no longer needed and the
  // new rhs should be stored or replaced by the corrected one
  if (prediction) {
    gsl_vector * fsp_rhs5 = sim->fspu_rhs1;
    sim->fspu_rhs1 = sim->fspu_rhs2;
    sim->fspu_rhs2 = sim->fspu_rhs3;
    sim->fspu_rhs3 = sim->fspu_rhs4;
    sim->fspu_rhs4 = fsp_rhs5;
  }

  sim->fspu_rhs4 = fs->build_fit_rhs (fs, explicit_free_surface_potential_update_rhs_gauss_store, sim, NULL, NULL, sim->fspu_rhs4);
}

static gsl_vector * explicit_free_surface_disturbance_potential_abm4_rhs (Simulation * sim)
{
  Spline2D * fs = sim->fs->s->patches->data;

  g_assert (fs != NULL);

  // Get rhs
  gsl_vector * gsl_rhs;

  if (fs->periodic) {
    gsl_rhs = fs->build_fit_noflux_rhs (fs, explicit_free_surface_potential_update_abm4_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }
  else {
    gsl_rhs = fs->build_fit_rhs (fs, explicit_free_surface_potential_update_abm4_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }

  return gsl_rhs;
}

static gdouble galerkin_free_surface_potential_rhs_variable_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;

  return spline2d_eval_gauss_point (spp->sp, gp, m, n, 7);
}

static gsl_vector * explicit_free_surface_disturbance_potential_abm4_variable_rhs (Simulation * sim)
{
  Spline2D * fs = sim->fs->s->patches->data;

  g_assert (fs != NULL);

  // Get rhs
  gsl_vector * gsl_rhs;

  if (fs->periodic) {
    gsl_rhs = fs->build_fit_noflux_rhs (fs, galerkin_free_surface_potential_rhs_variable_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }
  else {
    gsl_rhs = fs->build_fit_rhs (fs, galerkin_free_surface_potential_rhs_variable_rhs_gauss, sim, NULL, NULL, gsl_rhs);
  }

  return gsl_rhs;
}

static void explicit_free_surface_disturbance_potential_update_greville (Simulation * sim)
{
  g_test_timer_start ();
  Spline2D * fs = sim->fs->s->patches->data;
  
  if (sim->time.itime == 0)
    g_warning ("explicit_free_surface_potential_update_greville_rhs\n needs improving to take full advantage of storedGreville points \n");

  // Get rhs
  if (fs->periodic)
     spline2d_fit_greville_periodic (fs, explicit_free_surface_potential_update_greville_rhs, sim, 7);
  else
    spline2d_fit_greville (fs, explicit_free_surface_potential_update_greville_rhs, sim, 7);

  fprintf (stdout, "   Free surface elevation update: %f \n", g_test_timer_elapsed());
}

/* static void abm4_free_surface_elevation_disturbance_update (Simulation * sim) */
/* { */
/*   /\* Start timer *\/ */
/*   g_test_timer_start (); */
/*   gint i; */

/*   /\* We use the explicit scheme for the first 4 iterations and store the rhs*\/ */
/*   if (sim->time.itime == 0) { */
/*     explicit_free_surface_elevation_disturbance_update (sim); */
/*     sim->fseu_rhs1 = explicit_free_surface_elevation_disturbance_abm4_rhs (sim); */
/*     return; */
/*   } */
/*   else if (sim->time.itime == 1) { */
/*     explicit_free_surface_elevation_disturbance_update (sim); */
/*     sim->fseu_rhs2 = explicit_free_surface_elevation_disturbance_abm4_rhs (sim); */
/*     return; */
/*   } */
/*   else if (sim->time.itime == 2) { */
/*     explicit_free_surface_elevation_disturbance_update (sim); */
/*     sim->fseu_rhs3 = explicit_free_surface_elevation_disturbance_abm4_rhs (sim); */
/*     return; */
/*   } */
/*   else if (sim->time.itime == 3) { */
/*     explicit_free_surface_elevation_disturbance_update (sim); */
/*     sim->fseu_rhs4 = explicit_free_surface_elevation_disturbance_abm4_rhs (sim); */
/*     return; */
/*   } */

/*   Spline2D * sp = sim->fs->s->patches->data; */
/*   gint size = sp->NU*sp->NV; */
  

/*   g_assert (sp != NULL); */

/*   /\**** Prediction ****\/ */
/*   gsl_vector * rhs5 = gsl_vector_alloc (size); */
/*   gsl_vector * var9 = explicit_free_surface_elevation_disturbance_abm4_variable_rhs (sim); */
  
/*   for ( i = 0; i < size; i++) { */
/*     gsl_vector_set (rhs5, i, gsl_vector_get (var9, i) */
/* 		    + sim->time.dt/24.*(55.*gsl_vector_get (sim->fseu_rhs4, i) */
/* 					- 59.*gsl_vector_get (sim->fseu_rhs3, i) */
/* 					+ 37.*gsl_vector_get (sim->fseu_rhs2, i) */
/* 					-9.*gsl_vector_get (sim->fseu_rhs1, i))); */
/*   } */


/*   if (sp->periodic) */
/*     ccs_problem_lu_solve (sp->fit_noflux, rhs5); */
/*   else */
/*     ccs_problem_lu_solve (sp->fit, rhs5); */

/*   sp->copy_fit_solution (sp, rhs5, 9); */
/*   gsl_vector_free (sim->fseu_rhs1); */
/*   sim->fseu_rhs1 = sim->fseu_rhs2; */
/*   sim->fseu_rhs2 = sim->fseu_rhs3; */
/*   sim->fseu_rhs3 = sim->fseu_rhs4; */

/*   /\**** Correction ****\/ */
/*   sim->fseu_rhs4 = explicit_free_surface_elevation_disturbance_abm4_rhs (sim); */
  
/*   for ( i = 0; i < size; i++) { */
/*     gsl_vector_set (rhs5, i, gsl_vector_get (var9, i) */
/* 		    + sim->time.dt/24.*(9.*gsl_vector_get (sim->fseu_rhs4, i) */
/* 					+ 19.*gsl_vector_get (sim->fseu_rhs3, i) */
/* 					- 5.*gsl_vector_get (sim->fseu_rhs2, i) */
/* 					+ gsl_vector_get (sim->fseu_rhs1, i))); */
/*   } */

/*   gsl_vector_free (var9); */

/*   if (sp->periodic) */
/*     ccs_problem_lu_solve (sp->fit_noflux, rhs5); */
/*   else */
/*     ccs_problem_lu_solve (sp->fit, rhs5); */

/*   sp->copy_fit_solution (sp, rhs5, 9); */
/*   gsl_vector_free (rhs5); */
  
/*   /\* Stop timer and print *\/ */
/*   fprintf (stdout, "   Free-surface disturbance elevation update ABM4: %f \n", g_test_timer_elapsed()); */
/* } */

void simulation_build_galerkin_fit_matrixes (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);

  while (patches) {
    Spline2D * sp = patches->data;
    if (sp->fit == NULL)
      sp->fit = sp->build_fit_matrix (sp);

    if (sp->fit_noflux == NULL && !sp->periodic)
      sp->fit_noflux = sp->fit;

    if (sp->fit_noflux == NULL && sp->periodic)
      sp->fit_noflux = sp->build_fit_noflux_matrix (sp);

    patches = patches->next;
  }
}

/**
 * Boundary problem with Phin = 0 on the free surface and
 * Phin = U.N on the hull
 **/

void solve_boundary_problem_for_basis_flow (Simulation * sim)
{
  // Start timer
  g_test_timer_start ();

  // Apply Phin = U.N on the hull (stored in variable 4)
  GSList * patches = sim->hull->wet_patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, uniform_normal_velocity, &sim->U, 4);
    patches = patches->next;
  }

  // Apply Phin = 0 on the free-surface (stored in variable 4)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, zero_normal_velocity, NULL, 4);
    patches = patches->next;
  }

  // Apply Phin = 0 on the bathymetry (stored in variable 4)
  patches = sim->bathy->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, zero_normal_velocity, NULL, 4);
    patches = patches->next;
  }
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_neumann_sub_problems_rhs (sim, 4);

  // Assemble the total Neumann rhs
  boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems);

  if (sim->continuity)
    add_neumann_continuity_conditions_rhs (sim, sim->neumann_problem, 4);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->neumann_lu, sim->neumann_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->neumann_problem, 3);

  /* coeff_set_var_to_zero (sim->fs->s->patches->data, 4); */
  /* simulation_build_dirichlet_sub_problems_rhs (sim, 3); */
  /* boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems); */
  /* sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs); */
  /* cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 4); */

  
  /* coeff_set_var_to_zero (sim->fs->s->patches->data, 4); */
  /* simulation_build_mixed_sub_problems_rhs (sim, 3, 4); */
  /* boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim); */
  /* sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs); */
  /* cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem, */
  /* 							sim, 3, 4); */

  // Stops the timer
  fprintf (stderr, "   Basis flow : %f \n", g_test_timer_elapsed());
}

/**
 * Boundary problem with Phin = 0 on the free surface and
 * Phin = U.N on the hull
 **/
void solve_boundary_problem_for_m_terms (Simulation * sim)
{
  // Start timer
  g_test_timer_start ();

  // Apply U.x-Phi_x has dirichlet condition on all the surfaces (stored in 24)
  GSList * patches = simulation_all_patches_list (sim);
  while (patches) {
    apply_dirichlet_conditions (patches->data, m1_term_dirichlet_bc, &sim->U, 24);
    patches = patches->next;
  }

  // Build the rhs corresponding to the Dirichlet problem for each subproblem
  // using the Dirichlet condition stored in variable 24
  simulation_build_dirichlet_sub_problems_rhs (sim, 24);

  // Assemble the total Dirichlet rhs
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  // Solve the Dirichlet problem using the LU method
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  // Copies the solution back to the patches (stored in variable 25)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 25);



  // Apply U.y-Phi_y has dirichlet condition on all the surfaces (stored in 26)
  patches = simulation_all_patches_list (sim);
  while (patches) {
    apply_dirichlet_conditions (patches->data, m2_term_dirichlet_bc, &sim->U, 26);
    patches = patches->next;
  }

  // Build the rhs corresponding to the Dirichlet problem for each subproblem
  // using the Dirichlet condition stored in variable 26
  simulation_build_dirichlet_sub_problems_rhs (sim, 26);

  // Assemble the total Dirichlet rhs
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  // Solve the Dirichlet problem using the LU method
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  // Copies the solution back to the patches (stored in variable 27)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 27);



  // Apply U.z-Phi_z has dirichlet condition on all the surfaces (stored in 28)
  patches = simulation_all_patches_list (sim);
  while (patches) {
    apply_dirichlet_conditions (patches->data, m3_term_dirichlet_bc, &sim->U, 28);
    patches = patches->next;
  }
  
  // Build the rhs corresponding to the Dirichlet problem for each subproblem
  // using the Dirichlet condition stored in variable 26
  simulation_build_dirichlet_sub_problems_rhs (sim, 28);

  // Assemble the total Dirichlet rhs
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  // Solve the Dirichlet problem using the LU method
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  // Copies the solution back to the patches (stored in variable 29)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 29);
  

  // Stops the timer
  fprintf (stderr, "   Calculate m-terms : %f \n", g_test_timer_elapsed());
}

static gdouble basis_flow_time_derivatives_hull_condition (SPPanel * spp,
							   gint m, gint n,
							   gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Simulation * sim = (Simulation * ) data;
  Vector gradPhi = potential_gradient_on_surface_gauss_point (spp->sp, gp, m, n, 3);
  Point p = spline2d_eval_gauss_point_point (spp->sp, gp, m, n);
  Vector nt = hull_normal_time_derivative (sim->hull, g_array_index (gp->ui, gdouble, m), g_array_index (gp->ui, gdouble, n));

  gradPhi.x -= sim->U.x;
  gradPhi.y -= sim->U.y;
  gradPhi.z -= sim->U.z;

  // dn dt (Phi) = (U - nabla(Phi))*n_t
  return vector_scalar_product (&gradPhi, &nt);
}

static gdouble basis_flow_time_derivatives_free_surface_condition (SPPanel * spp,
								   gint m, gint n,
								   gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Simulation * sim = (Simulation * ) data;
  Vector gradPhi = potential_gradient_on_surface_gauss_point (spp->sp, gp, m, n, 3);
  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  Vector nt = sim->wp.wave_normal_time_derivative (&sim->wp, p, sim->time.t);

  // dn dt (Phi) = - nabla(Phi))*n_t
  return -vector_scalar_product (&gradPhi, &nt);
}

static gdouble basis_flow_time_derivatives_bathymetry_condition (SPPanel * spp,
								 gint m, gint n,
								 gpointer data)
{
  // dn dt (Phi) = 0
  return 0.;
}

/**
 * Boundary problem with dn dt (Phi) = - nabla(Phi))*n_t on the free surface and
 * dn dt (Phi) = (U - nabla(Phi))*n_t on the hull
 **/
void solve_boundary_problem_for_basis_flow_time_derivatives (Simulation * sim)
{
  // Start timer
  g_test_timer_start ();

  // Apply dn dt (Phi) = (U - nabla(Phi))*n_t on the hull (stored in variable 11)
  GSList * patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data,
				 basis_flow_time_derivatives_hull_condition,
				 sim, 11);
    patches = patches->next;
  }

  // Apply dn dt (Phi) = - nabla(Phi))*n_t on the free-surface (stored in variable 11)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data,
				 basis_flow_time_derivatives_free_surface_condition,
				 sim, 11);
    patches = patches->next;
  }

  // Apply dn dt (Phi) = 0 on the bathymetry (stored in variable 11)
  patches = sim->bathy->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data,
				 basis_flow_time_derivatives_bathymetry_condition,
				 NULL, 11);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 11
  simulation_build_neumann_sub_problems_rhs (sim, 11);

  // Assemble the total Neumann rhs
  boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems);

  // Solve the Neumann using the LU method implemented in the GNU Scientific Library
  //boundary_problem_direct_LU_solve (sim->neumann_problem);
  sim->lu_factorised_solve (sim->neumann_lu, sim->neumann_problem->rhs);
  

  // Copies the solution to the patches (stored in variable 11)
  // boundary_problem_copy_solution_to_patches (patches, sim->neumann_problem, 11);
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->neumann_problem, 11);

  // Stops the timer
  fprintf (stderr, "   Basis flow time derivative : %f \n", g_test_timer_elapsed());
}

/**
 * Boundary condition on the hull for the time-local flow
 * as stated page 40 of (Kim, 2011). This is for the linear formulation.
 **/
gdouble hull_motion_time_local_bc_linear_kim (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Hull * hull = sim->hull;
  Motion m1 = hull->m;
  Vector U = hull->U;

  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector Ni = g_array_index (gp->Ni, Vector, m + n*ng);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);
  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, P, sim->time.t);

  gdouble N[6], M[6];
  N[0] = Ni.x;
  N[1] = Ni.y;
  N[2] = Ni.z;
  N[3] = P.y*Ni.z - P.z*Ni.y;
  N[4] = P.z*Ni.x - P.x*Ni.z;
  N[5] = P.x*Ni.y - P.y*Ni.x;

  // m-terms from (Wu, 1991)
  gint i, j;
  size_t istart = gp->istart, jstart = gp->jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gdouble Phi_x = 0., Phi_y = 0., Phi_z = 0.;

  for ( i = 0; i < 6; i++)
    M[i] = 0.;

  if (sp->periodic)
    istart -= (sp->k-1);

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gint ii = istart;
    for ( j = 0; j < sp->k; j++) {
      gint jj = (jstart+j);
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      
      M[0] += coeff (sp, ii, jj, 25)*cuv;
      M[1] += coeff (sp, ii, jj, 27)*cuv;
      M[2] += coeff (sp, ii, jj, 29)*cuv;

      // These are the values used as bc to find m1, m2 and m3
      // Alternatively, the values from the spline derivatives could be used.
      Phi_x += coeff (sp, ii, jj, 24)*cuv;
      Phi_y += coeff (sp, ii, jj, 26)*cuv;
      Phi_z += coeff (sp, ii, jj, 28)*cuv;
    }
    istart++;
  }

  M[3] = M[2]*P.y - Ni.y*(Phi_z-U.z) - M[1]*P.z + Ni.z*(Phi_y-U.y);
  M[4] = M[0]*P.z - Ni.z*(Phi_x-U.x) - M[2]*P.x + Ni.x*(Phi_z-U.z);
  M[5] = M[1]*P.x - Ni.x*(Phi_y-U.y) - M[0]*P.y + Ni.y*(Phi_x-U.x);

  // bc = sum xi_t * n + xi * m
  gdouble val = 0.;
  for ( i = 0; i < 6; i++)
    val += m1.v[i]*N[i] + m1.x[i]*M[i];

  return val-vector_scalar_product (&gradphi0, &Ni);
}

gdouble hull_motion_time_local_bc_linear_nospeed_kim (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Hull * hull = sim->hull;
  Motion m1 = hull->m;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector Ni = g_array_index (gp->Ni, Vector, m + n*ng);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);
  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, P, sim->time.t);

  Vector x;
  Point xg = sim->hull->xg;
  x.x = P.x-xg.x; x.y = P.y-xg.y; x.z = P.z-xg.z;
  //x = vector_vector_product (&x, &Ni);

  gdouble N[6];
  N[0] = Ni.x;
  N[1] = Ni.y;
  N[2] = Ni.z;
  N[3] = x.y*Ni.z - x.z*Ni.y;
  N[4] = x.z*Ni.x - x.x*Ni.z;
  N[5] = x.x*Ni.y - x.y*Ni.x;

  gint i;

  // bc = sum xi_t * n + xi * m
  gdouble val = 0.;
  for ( i = 0; i < 6; i++)
    val += m1.u[i]*N[i]; // Might be u ??

  return val-vector_scalar_product (&gradphi0, &Ni);
}

gdouble hull_motion_time_local_bc_linear_nospeed_kim_1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Hull * hull = sim->hull;
  Motion m1 = hull->m;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector Ni = g_array_index (gp->Ni, Vector, m + n*ng);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);
  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, P, sim->time.t);

  Vector x;
  Point xg = sim->hull->xg;
  x.x = P.x-xg.x; x.y = P.y-xg.y; x.z = P.z-xg.z;
  //x = vector_vector_product (&x, &Ni);

  gdouble N[6];
  N[0] = Ni.x;
  N[1] = Ni.y;
  N[2] = Ni.z;
  N[3] = x.y*Ni.z - x.z*Ni.y;
  N[4] = x.z*Ni.x - x.x*Ni.z;
  N[5] = x.x*Ni.y - x.y*Ni.x;

  gint i;

  // bc = sum xi_t * n + xi * m
  gdouble val = 0.;
  for ( i = 0; i < 6; i++)
    val += m1.u1[i]*N[i]; // Might be u ??

  return val-vector_scalar_product (&gradphi0, &Ni);
}

void solve_boundary_problem_for_disturbance_flow_kim_1 (Simulation * sim)
{
  // Start timer
  if (sim->verbose)
    g_test_timer_start ();

  // Apply phin = d delta/dt.N on the hull (stored in variable 8)
  GSList * patches = sim->hull->wet_patches;
  while (patches) {
    //apply_dirichlet_conditions (patches->data, minus_normal_phi0_derivative, sim, 8);
    // apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_kim, sim, 8);
    apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_nospeed_kim_1, sim, 8);
    patches = patches->next;
  }

  // No need to apply the dirichlet conditions on the free surface as this
  // was done when applying the free-surface conditions and is already stored in
  // variable 7

  // Apply phin = 0 on the bathymetry (stored in variable 8)
  patches = sim->bathy->s->patches;
  while (patches) {
    coeff_set_var_to_zero (patches->data, 8);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichlet condition stored in variable 7 or
  // the Neumann condition stored in variable 8
  simulation_build_mixed_sub_problems_rhs (sim, 7, 8);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_mixed_continuity_conditions_rhs (sim, sim->mixed_problem, 7, 8);

  // Solve the Neumann problem using the LU method 
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 7, 8);

  // Stops the timer
  if (sim->verbose)
    fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}


gdouble hull_netcdf_motion_time_local_bc_linear_nospeed_kim (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Hull * hull = sim->hull;
  Motion m1 = hull->m;

  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector Ni = g_array_index (gp->Ni, Vector, m + n*ng);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);
  Vector gradphi0;

  gradphi0.x = spline2d_eval_gauss_point (sp, gp, m, n, 32);
  gradphi0.y = spline2d_eval_gauss_point (sp, gp, m, n, 33);
  gradphi0.z = 0.;

  Vector x;
  Point xg = sim->hull->xg;
  x.x = P.x-xg.x; x.y = P.y-xg.y; x.z = P.z-xg.z;
  //x = vector_vector_product (&x, &Ni);

  gdouble N[6];
  N[0] = Ni.x;
  N[1] = Ni.y;
  N[2] = Ni.z;
  N[3] = x.y*Ni.z - x.z*Ni.y;
  N[4] = x.z*Ni.x - x.x*Ni.z;
  N[5] = x.x*Ni.y - x.y*Ni.x;

  gint i;

  // bc = sum xi_t * n + xi * m
  gdouble val = 0.;
  for ( i = 0; i < 6; i++)
    val += m1.u[i]*N[i]; // Might be u ??

  return val-vector_scalar_product (&gradphi0, &Ni);
}

gdouble hull_motion_time_local_bc_linear_nospeed_huang (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Hull * hull = sim->hull;
  Motion m1 = hull->m;

  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector Ni = g_array_index (gp->Ni, Vector, m + n*ng);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);

  Vector x;
  Point xg = sim->hull->xg;
  x.x = P.x-xg.x; x.y = P.y-xg.y; x.z = P.z-xg.z;
  //x = vector_vector_product (&x, &Ni);

  gdouble N[6];
  N[0] = Ni.x;
  N[1] = Ni.y;
  N[2] = Ni.z;
  N[3] = x.y*Ni.z - x.z*Ni.y;
  N[4] = x.z*Ni.x - x.x*Ni.z;
  N[5] = x.x*Ni.y - x.y*Ni.x;

  gint i;

  // bc = sum xi_t * n + xi * m
  //  m1.u[2] = 1.;
  gdouble val = 0.;
  for ( i = 0; i < 6; i++)
    val += m1.u[i]*N[i]; // Might be u ??

  return val;
}

/**
 * Boundary problem with phi = 0 on the free surface,
 * phin = d delta/dt.N on the hull (zero for now)
 **/
void solve_boundary_problem_for_time_local_flow (Simulation * sim)
{
  // Start timer
  g_test_timer_start ();

  // We make sure that the velocity of the boat is also store in hull
  sim->hull->U = sim->U;

  // Apply phin = d delta/dt.N on the hull (stored in variable 6)
  GSList * patches = sim->hull->patches;
  /* gint i; */
  /* for ( i = 2; i < 3; i++) */
  /*   fprintf (stderr, "Mode %i %f\n", sim->hull->m.u[i]); */
  while (patches) {
    //apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_huang, sim->hull, 6);
    apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_nospeed_huang, sim->hull, 6);
    patches = patches->next;
  }

  // Apply phi = 0 on the free-surface (stored in variable 5)
  patches = sim->fs->s->patches;
  while (patches) {
    coeff_set_var_to_zero (patches->data, 5);
    //apply_dirichlet_conditions (patches->data, zero_potential, NULL, 5);
    patches = patches->next;
  }

  // Apply phin = 0 on the bathymetry (stored in variable 6)
  patches = sim->bathy->s->patches;
  while (patches) {
    //   apply_dirichlet_conditions (patches->data, zero_normal_velocity, NULL, 6);
    coeff_set_var_to_zero (patches->data, 6);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichelt condition stored in variable 5 or
  // the Neumann condition stored in variable 6
  simulation_build_mixed_sub_problems_rhs (sim, 5, 6);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_mixed_continuity_conditions_rhs (sim, sim->mixed_problem, 5, 6);

  // Solve the Neumann using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 5, 6);

  // Stops the timer
  fprintf (stderr, "   Time local flow : %f \n", g_test_timer_elapsed());
}

/**
 * Applies one iteration of the 7 points low-pass filter of (Nakos, 1993)
 * to the field @var of the patch @sp
 **/
void spline2d_filter_variable (Spline2D * sp, gint var)
{
  gdouble w[7]; // Filter kernel (Huang, 1995)
  w[0] = 0.019361;
  w[1] = -0.100604;
  w[2] = 0.230639;
  w[3] = 0.701207;
  w[4] = 0.230639;
  w[5] = -0.100604;
  w[6] = 0.019361;

  gdouble new[gsl_bspline_ncoeffs (sp->w_u)+6][gsl_bspline_ncoeffs (sp->w_v)+6];
  gint i, j, k, l;

  // Copy data + reflection conditions on the edges
  for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) {
     /* Core of the domain */
    for ( j = 0; j < gsl_bspline_ncoeffs (sp->w_v); j++) {
      new[i+3][j+3] = coeff (sp, i, j, var);
    }
  }

  // Corners
  new[0][0] = new[6][6];
  new[1][0] = new[5][6];
  new[2][0] = new[4][6];
  new[0][1] = new[6][5];
  new[1][1] = new[5][5];
  new[2][1] = new[4][5];
  new[0][2] = new[6][4];
  new[1][2] = new[5][4];
  new[2][2] = new[4][4];

  new[gsl_bspline_ncoeffs (sp->w_u)+5][0] = new[gsl_bspline_ncoeffs (sp->w_u)-1][6];
  new[gsl_bspline_ncoeffs (sp->w_u)+4][0] = new[gsl_bspline_ncoeffs (sp->w_u)][6];
  new[gsl_bspline_ncoeffs (sp->w_u)+3][0] = new[gsl_bspline_ncoeffs (sp->w_u)+1][6];
  new[gsl_bspline_ncoeffs (sp->w_u)+5][1] = new[gsl_bspline_ncoeffs (sp->w_u)-1][5];
  new[gsl_bspline_ncoeffs (sp->w_u)+4][1] = new[gsl_bspline_ncoeffs (sp->w_u)][5];
  new[gsl_bspline_ncoeffs (sp->w_u)+3][1] = new[gsl_bspline_ncoeffs (sp->w_u)+1][5];
  new[gsl_bspline_ncoeffs (sp->w_u)+5][2] = new[gsl_bspline_ncoeffs (sp->w_u)-1][4];
  new[gsl_bspline_ncoeffs (sp->w_u)+4][2] = new[gsl_bspline_ncoeffs (sp->w_u)][4];
  new[gsl_bspline_ncoeffs (sp->w_u)+3][2] = new[gsl_bspline_ncoeffs (sp->w_u)+1][4];

  new[0][gsl_bspline_ncoeffs (sp->w_v)+5] = new[6][gsl_bspline_ncoeffs (sp->w_v)-1];
  new[0][gsl_bspline_ncoeffs (sp->w_v)+4] = new[6][gsl_bspline_ncoeffs (sp->w_v)];
  new[0][gsl_bspline_ncoeffs (sp->w_v)+3] = new[6][gsl_bspline_ncoeffs (sp->w_v)+1];
  new[1][gsl_bspline_ncoeffs (sp->w_v)+5] = new[5][gsl_bspline_ncoeffs (sp->w_v)-1];
  new[1][gsl_bspline_ncoeffs (sp->w_v)+4] = new[5][gsl_bspline_ncoeffs (sp->w_v)];
  new[1][gsl_bspline_ncoeffs (sp->w_v)+3] = new[5][gsl_bspline_ncoeffs (sp->w_v)+1];
  new[2][gsl_bspline_ncoeffs (sp->w_v)+5] = new[4][gsl_bspline_ncoeffs (sp->w_v)-1];
  new[2][gsl_bspline_ncoeffs (sp->w_v)+4] = new[4][gsl_bspline_ncoeffs (sp->w_v)];
  new[2][gsl_bspline_ncoeffs (sp->w_v)+3] = new[4][gsl_bspline_ncoeffs (sp->w_v)+1];

  new[gsl_bspline_ncoeffs (sp->w_u)+5][gsl_bspline_ncoeffs (sp->w_v)+5] =
    new[gsl_bspline_ncoeffs (sp->w_u)-1][gsl_bspline_ncoeffs (sp->w_v)-1];
  new[gsl_bspline_ncoeffs (sp->w_u)+5][gsl_bspline_ncoeffs (sp->w_v)+4] =
    new[gsl_bspline_ncoeffs (sp->w_u)-1][gsl_bspline_ncoeffs (sp->w_v)];
  new[gsl_bspline_ncoeffs (sp->w_u)+5][gsl_bspline_ncoeffs (sp->w_v)+3] =
    new[gsl_bspline_ncoeffs (sp->w_u)-1][gsl_bspline_ncoeffs (sp->w_v)+1];
  new[gsl_bspline_ncoeffs (sp->w_u)+4][gsl_bspline_ncoeffs (sp->w_v)+5] =
    new[gsl_bspline_ncoeffs (sp->w_u)][gsl_bspline_ncoeffs (sp->w_v)-1];
  new[gsl_bspline_ncoeffs (sp->w_u)+4][gsl_bspline_ncoeffs (sp->w_v)+4] =
    new[gsl_bspline_ncoeffs (sp->w_u)][gsl_bspline_ncoeffs (sp->w_v)];
  new[gsl_bspline_ncoeffs (sp->w_u)+4][gsl_bspline_ncoeffs (sp->w_v)+3] =
    new[gsl_bspline_ncoeffs (sp->w_u)][gsl_bspline_ncoeffs (sp->w_v)+1];
  new[gsl_bspline_ncoeffs (sp->w_u)+3][gsl_bspline_ncoeffs (sp->w_v)+5] =
    new[gsl_bspline_ncoeffs (sp->w_u)+1][gsl_bspline_ncoeffs (sp->w_v)-1];
  new[gsl_bspline_ncoeffs (sp->w_u)+3][gsl_bspline_ncoeffs (sp->w_v)+4] =
    new[gsl_bspline_ncoeffs (sp->w_u)+1][gsl_bspline_ncoeffs (sp->w_v)];
  new[gsl_bspline_ncoeffs (sp->w_u)+3][gsl_bspline_ncoeffs (sp->w_v)+3] =
    new[gsl_bspline_ncoeffs (sp->w_u)+1][gsl_bspline_ncoeffs (sp->w_v)+1];

  for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_v); i++) {
    /* Edges */
    new[0][i+3] = new[6][i+3];
    new[1][i+3] = new[5][i+3];
    new[2][i+3] = new[4][i+3];

    new[gsl_bspline_ncoeffs (sp->w_u)+3][i+3] = new[gsl_bspline_ncoeffs (sp->w_u)+1][i+3];
    new[gsl_bspline_ncoeffs (sp->w_u)+4][i+3] = new[gsl_bspline_ncoeffs (sp->w_u)][i+3];
    new[gsl_bspline_ncoeffs (sp->w_u)+5][i+3] = new[gsl_bspline_ncoeffs (sp->w_u)-1][i+3];
  }

  for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) {
    new[i+3][0] = new[i+3][6];
    new[i+3][1] = new[i+3][5];
    new[i+3][2] = new[i+3][4];

    new[i+3][gsl_bspline_ncoeffs (sp->w_v)+3] = new[i+3][gsl_bspline_ncoeffs (sp->w_v)+1];
    new[i+3][gsl_bspline_ncoeffs (sp->w_v)+4] = new[i+3][gsl_bspline_ncoeffs (sp->w_v)];
    new[i+3][gsl_bspline_ncoeffs (sp->w_v)+5] = new[i+3][gsl_bspline_ncoeffs (sp->w_v)-1];
  }

  /* Apply filter */
  for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) {
    for ( j = 0; j < gsl_bspline_ncoeffs (sp->w_v); j++) {
      gdouble sum = 0.;
      
      for (k = 0; k < 7; k++) {
	for (l = 0; l < 7; l++) {
	  sum += w[(gint) fabs(k)]*w[(gint) fabs(l)]*new[i+k][j+l];
	}
      }

      coeff_assign (sp, i, j, var, sum);;
    }
  }
}

/**
 *
 * Applies one iteration of the 7 points Chebyshev filter described page 61 of (Huang, 1995).
 *
 **/
void periodic_fs_filter_variable (Spline2D * sp, gint var)
{
  gdouble w[7]; // Filter kernel (Huang, 1995)
  w[0] = 0.019361;
  w[1] = -0.100604;
  w[2] = 0.230639;
  w[3] = 0.701207;
  w[4] = 0.230639;
  w[5] = -0.100604;
  w[6] = 0.019361;

  g_assert (sp->periodic);
  g_assert (sp->NUT != 0);
  
  // Periodic in the u direction
  gint NUT = sp->NUT;
  gdouble old[NUT][sp->NV+6];
  gint i, j, k = sp->k, l, m, n;
  Spline2D * patches = sp;

  while (patches) {
    for ( i = 0; i < patches->NU+k-1; i++) {
      gint ii = (patches->fs_index + i)%NUT;
      for ( j = 0; j < patches->NV; j++) {
	old[ii][j+3] = coeff (patches, i, j, var);
      }
    }
    patches = patches->next;
  }

  // Apply mirror on edges
  for ( i = 0; i < NUT; i++) {
    old[i][0] = old[i][6];
    old[i][1] = old[i][5];
    old[i][2] = old[i][4];

    old[i][sp->NV+5] = old[i][sp->NV-1];
    old[i][sp->NV+4] = old[i][sp->NV];
    old[i][sp->NV+3] = old[i][sp->NV+1];
  }

  gdouble new[NUT][sp->NV];
#if 0
  // Just radial
  for ( i = 0; i < NUT; i++) {
    for ( j = 0; j < sp->NV; j++) {
      new[i][j] = 0.;
      for ( m = 0; m < 7; m++)
	new[i][j] += w[m]*old[i][j+m];
    }
  }

#else
 // Both ways
  for ( i = 0; i < NUT; i++) {
    for ( j = 0; j < sp->NV; j++) {
      new[i][j] = 0.;

      // Angular
      /* for ( n = 0; n < 7; n++) { */
      /* 	gint ii = (i-3+n)%NUT; */
      /* 	ii = ii < 0 ? ii + NUT: ii; //Needed as % in C can return negative values */
      /* 	new[i][j] += w[n]*old[ii][j+3]; */
      /* } */


      
      for ( n = 0; n < 7; n++) {
	gint ii = (i-3+n)%NUT;
	ii = ii < 0 ? ii + NUT: ii; //Needed as % in C can return negative values
	for ( m = 0; m < 7; m++) {
	  new[i][j] += w[n]*w[m]*old[ii][j+m];
	}
      }

    }
  }

#endif

  // Copy back
  patches = sp;
  while (patches) {
    gint NU = (patches->NU+patches->k-1);
    for ( i = 0; i < NU; i++) {
      gint indexi = (patches->fs_index + i)%NUT;
      for ( j = 0; j < patches->NV; j++) {
  	SplineCoeffs * sc = g_ptr_array_index (patches->coeffs, i+ j*NU);
  	sc->v[var] = new[indexi][j];
      }
    }
    patches = patches->next;
  }
}

gdouble minus_normal_phi0_derivative (SPPanel * spp, gint m, gint n, gpointer data)
{
  g_assert (data != NULL);

  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Simulation * sim = data;
  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  Vector grad = sim->wp.wave_potential_gradient (&sim->wp, p, sim->time.t);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  return -vector_scalar_product (&grad, &N);
}

/**
 * Boundary problem with Phi2 = value from free surface condition on the free surface,
 * phin = - nabla(phi0).N on the hull (zero for now)
 **/
void solve_boundary_problem_for_disturbance_flow (Simulation * sim)
{
  // Start timer
  //  g_test_timer_start ();

  // Apply phin = d delta/dt.N on the hull (stored in variable 8)
  GSList * patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, minus_normal_phi0_derivative, sim, 8);
    // apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_kim, sim, 8);
    //apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_nospeed_kim, sim, 8);
    patches = patches->next;
  }

  // No need to apply the dirichlet conditions on the free surface as this
  // was done when applying the free-surface conditions and is already stored in
  // variable 7

  // Apply phin = 0 on the bathymetry (stored in variable 8)
  patches = sim->bathy->s->patches;
  while (patches) {
    //apply_dirichlet_conditions (patches->data, zero_normal_velocity, NULL, 8);
    coeff_set_var_to_zero (patches->data, 8);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichlet condition stored in variable 7 or
  // the Neumann condition stored in variable 8
  simulation_build_mixed_sub_problems_rhs (sim, 7, 8);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_mixed_continuity_conditions_rhs (sim, sim->mixed_problem, 7, 8);

  // Solve the Neumann problem using the LU method 
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 7, 8);

  // Stops the timer
  /* fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed()); */
}

void solve_boundary_problem_for_disturbance_flow_kim (Simulation * sim)
{
  // Start timer
  if (sim->verbose)
    g_test_timer_start ();

  // Apply phin = d delta/dt.N on the hull (stored in variable 8)
  GSList * patches = sim->hull->wet_patches;
  while (patches) {
    //apply_dirichlet_conditions (patches->data, minus_normal_phi0_derivative, sim, 8);
    // apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_kim, sim, 8);
    apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_nospeed_kim, sim, 8);
    patches = patches->next;
  }

  // No need to apply the dirichlet conditions on the free surface as this
  // was done when applying the free-surface conditions and is already stored in
  // variable 7

  // Apply phin = 0 on the bathymetry (stored in variable 8)
  patches = sim->bathy->s->patches;
  while (patches) {
    coeff_set_var_to_zero (patches->data, 8);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichlet condition stored in variable 7 or
  // the Neumann condition stored in variable 8
  simulation_build_mixed_sub_problems_rhs (sim, 7, 8);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_mixed_continuity_conditions_rhs (sim, sim->mixed_problem, 7, 8);

  // Solve the Neumann problem using the LU method 
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 7, 8);

  // Stops the timer
  if (sim->verbose)
    fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}

static gdouble no_speed_implicit (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  Simulation * sim = (Simulation *) data;

  /* gdouble phi0 = spline2d_eval_gauss_point (sp, gp, m, n, 23); */
  /* gdouble phi1 = spline2d_eval_gauss_point (sp, gp, m, n, 34); */
  /* gdouble phi2 = spline2d_eval_gauss_point (sp, gp, m, n, 35); */
  /* gdouble phi3 = spline2d_eval_gauss_point (sp, gp, m, n, 36); */
  /* gdouble phi4 = spline2d_eval_gauss_point (sp, gp, m, n, 37); */

  gdouble phi0, phi1, phi2, phi3, phi4;

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

  Point p = g_array_index (gp->Pi, Point, m + n*sp->nouter);
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  phi0 = phi1 = phi2 = phi3 = phi4 = 0.;
  
  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    for ( j = 0; j < sp->k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      phi0 += coeff (sp, istart, (jstart+j), 23)*cuv;
      phi1 += coeff (sp, istart, (jstart+j), 34)*cuv;
      phi2 += coeff (sp, istart, (jstart+j), 35)*cuv;
      phi3 += coeff (sp, istart, (jstart+j), 36)*cuv;
      phi4 += coeff (sp, istart, (jstart+j), 37)*cuv;
    }
    istart++;
  }


  // Based on 4th order backward finite-difference
  return 1./(12.*sim->g*sim->time.dt*sim->time.dt)*(154.*phi0 - 214.*phi1 + 156.*phi2 - 61.*phi3 + 10.*phi4);

  // NEW 
  //  return 1./(12.*sim->g*sim->time.dt)*( (154./sim->time.dt + 2.*nu*48.)*phi0 - (214./sim->time.dt + 2.*nu*36.)*phi1 + (156./sim->time.dt 2.*nu*16 )*phi2 - (61./sim->time.dt + 2.*nu*3.)*phi3 + 10*phi4);

  // Based on second order backward finite-difference
  return 1./(sim->g*sim->time.dt*sim->time.dt)*(5.*phi0 - 4.*phi1 + phi2);
}

void solve_boundary_problem_for_disturbance_flow_nospeed_kim (Simulation * sim)
{
  // Start timer
  g_test_timer_start ();

  // Apply phin = d delta/dt.N on the hull (stored in variable 8)
  GSList * patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_nospeed_kim, sim, 8);
    patches = patches->next;
  }

  // No need to apply the dirichlet conditions on the free surface as this
  // was done when applying the free-surface conditions and is already stored in
  // variable 7
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, no_speed_implicit, sim, 8);
    patches = patches->next;
  }

  // Apply phin = 0 on the bathymetry (stored in variable 8)
  patches = sim->bathy->s->patches;
  while (patches) {
    coeff_set_var_to_zero (patches->data, 8);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichlet condition stored in variable 7 or
  // the Neumann condition stored in variable 8
  simulation_build_neumann_sub_problems_rhs (sim, 8);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems);

  // Solve the Neumann problem using the LU method 
  sim->lu_factorised_solve (sim->nospeed_lu, sim->neumann_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->neumann_problem, 7);

  // Stops the timer
  fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}

void solve_netcdf_boundary_problem_for_disturbance_flow_kim (Simulation * sim)
{
  // Start timer
  g_test_timer_start ();

  // Apply phin = d delta/dt.N on the hull (stored in variable 8)
  GSList * patches = /* sim->hull->patches */sim->hull->wet_patches;
  while (patches) {
    //apply_dirichlet_conditions (patches->data, minus_normal_phi0_derivative, sim, 8);
    // apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_kim, sim, 8);
    apply_dirichlet_conditions (patches->data, hull_netcdf_motion_time_local_bc_linear_nospeed_kim, sim, 8);
    patches = patches->next;
  }

  // No need to apply the dirichlet conditions on the free surface as this
  // was done when applying the free-surface conditions and is already stored in
  // variable 7

  // Apply phin = 0 on the bathymetry (stored in variable 8)
  patches = sim->bathy->s->patches;
  while (patches) {
    coeff_set_var_to_zero (patches->data, 8);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichlet condition stored in variable 7 or
  // the Neumann condition stored in variable 8
  simulation_build_mixed_sub_problems_rhs (sim, 7, 8);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_mixed_continuity_conditions_rhs (sim, sim->mixed_problem, 7, 8);

  // Solve the Neumann problem using the LU method 
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 7, 8);

  // Stops the timer
  fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}

/*******************************************************************/

#define new_grad 1

static void store_gradients_at_gauss_points (Simulation * sim, WaveParams * wp, gdouble t)
{
  gint ii, m, n;
  GSList * patches = simulation_all_patches_list (sim);
  Spline2D * fs = sim->fs->s->patches->data;

  while (patches) {
    Spline2D * sp = patches->data;
    
    while (sp) {
      for ( ii = 0; ii < sp->panels->len; ii++) {
	SPPanel * spp = g_ptr_array_index (sp->panels, ii);
	GaussPoints * gp = spp->outer;
	gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
	gint istart = gp->istart;
	if (sp->periodic)
	  istart -= sp->k-1;
	gint istart_x = gp->istart_x;
	gint jstart = gp->jstart;

	for ( n = 0; n < ng; n++ ) {
	  gdouble vn = g_array_index (gp->vj, gdouble, n);
	  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

	  for ( m = 0; m < ng; m++ ) {
	    gdouble um = g_array_index (gp->ui, gdouble, m);
	    gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	    gsl_matrix * Bux = g_ptr_array_index (gp->Bux, m);
	    gint  i, j;
	    FSData d;
	    gint gindex = m + n*ng;
	    gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
	    gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
	    gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
	    gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
	    gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
	    gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
	    
	    /* Normal to the surface */
	    Vector N = g_array_index (gp->Ni, Vector, gindex);

	    if ( patches->data != fs) {
	      gdouble  dvardu3, dvardv3, dvardu5, dvardv5, Vn4, Vn6;
	      dvardu3 = dvardv3 = dvardu5 = dvardv5 = Vn4 = Vn6 = 0.;

	      for ( i = 0; i < sp->k; i++) {
		gdouble cu = gsl_matrix_get (Bu, i, 0);
		gdouble cdu = gsl_matrix_get (Bu, i, 1);
		gint i2 = (istart+i);
		for ( j = 0; j < sp->k; j++) {
		  gdouble cv = gsl_matrix_get (Bv, j, 0);
		  gdouble cdv = gsl_matrix_get (Bv, j, 1);
		  gdouble cudv = cu*cdv;
		  gdouble cvdu = cv*cdu;
		  gint j2 = (jstart+j);

		  SplineCoeffs * sc;
		  if (sp->periodic)
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU+sp->k-1));
		  else
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU));

		  dvardu3 += sc->v[3]*cvdu;
		  dvardv3 += sc->v[3]*cudv;
		  dvardu5 += sc->v[5]*cvdu;
		  dvardv5 += sc->v[5]*cudv;
		  Vn4 += sc->v[4]*cu*cv;
		  Vn6 += sc->v[6]*cu*cv;
		}
	      }

#if LINEAR
	      /* Store gradient of Phi */
	      d.gradPhi.x = Vn4*N.x + c1*dvardu3 + c2*dvardv3;
	      d.gradPhi.y = Vn4*N.y + c3*dvardu3 + c4*dvardv3;
	      d.gradPhi.z = Vn4*N.z + c5*dvardu3 + c6*dvardv3;
#else
	      /* Store gradient of phi */
	      d.gradphi.x = Vn6*N.x + c1*dvardu5 + c2*dvardv5;
	      d.gradphi.y = Vn6*N.y + c3*dvardu5 + c4*dvardv5;
	      d.gradphi.z = Vn6*N.z + c5*dvardu5 + c6*dvardv5;
#endif
	    }
	    else { /* Quantities only needed on the free-surface */
	      gdouble  dvardu3, dvardv3, dvardu5, dvardv5, dvardu7, dvardv7, dvardu9, dvardv9, Vn4, Vn6, Vn8, Vn10;
	      gdouble zeta, dtPhi, dtphi, dtdzPhi, dtdzphi;
	      dvardu3 = dvardv3 = dvardu5 = dvardv5 = dvardu7 = dvardv7 = dvardu9 = dvardv9 =  Vn4 = Vn6 = Vn8 = Vn10 = 0.;
	      zeta = dtPhi = dtphi = dtdzPhi = dtdzphi = 0.;

	      for ( i = 0; i < sp->k; i++) {
		gdouble cu = gsl_matrix_get (Bu, i, 0);
		gdouble cdu = gsl_matrix_get (Bu, i, 1);
		gint i2 = (istart+i);
		for ( j = 0; j < sp->k; j++) {
		  gdouble cv = gsl_matrix_get (Bv, j, 0);
		  gdouble cdv = gsl_matrix_get (Bv, j, 1);
		  gdouble cudv = cu*cdv;
		  gdouble cvdu = cv*cdu;
		  gdouble cuv = cu*cv;
		  gint j2 = (jstart+j);

		  SplineCoeffs * sc, * scx;
		  if (sp->periodic)
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU+sp->k-1));
		  else
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU));

		  gdouble v3 = sc->v[3];
		  gdouble v5 = sc->v[5];
		  gdouble v7 = sc->v[7];
		  gdouble v9 = sc->v[9];

		  dvardu3 += v3*cvdu;
		  dvardv3 += v3*cudv;
		  dvardu5 += v5*cvdu;
		  dvardv5 += v5*cudv;
		  dvardu7 += v7*cvdu;
		  dvardv7 += v7*cudv;
		  dvardu9 += v9*cvdu;
		  dvardv9 += v9*cudv;
		  Vn4 += sc->v[4]*cuv;
		  Vn6 += sc->v[6]*cuv;
		  Vn8 += sc->v[8]*cuv;
		  //Vn8 += sc->v[30]*cuv;
		  Vn10 += sc->v[10]*cuv;
		  zeta += sc->v[9/* 22 */]*cuv;
		  dtPhi += sc->v[11]*cuv;
		  dtphi += (v5 - sc->v[12])*cuv;
		  dtdzPhi += (sc->v[14] - sc->v[20])*cuv;
		  dtdzphi += (sc->v[16] - sc->v[21])*cuv;
		}
	      }
	      dtphi /= sim->time.dt;
	      dtdzPhi /= sim->time.dt;
	      dtdzphi /= sim->time.dt;

	      /* Store gradient of Phi */
#if LINEAR
	      d.gradPhi.x = Vn4*N.x + c1*dvardu3 + c2*dvardv3;
	      d.gradPhi.y = Vn4*N.y + c3*dvardu3 + c4*dvardv3;
	      d.gradPhi.z = Vn4*N.z + c5*dvardu3 + c6*dvardv3;
#else  

	      /* Store gradient of phi */
	      d.gradphi.x = Vn6*N.x + c1*dvardu5 + c2*dvardv5;
	      d.gradphi.y = Vn6*N.y + c3*dvardu5 + c4*dvardv5;
	      d.gradphi.z = Vn6*N.z + c5*dvardu5 + c6*dvardv5;

	      /* Store gradient of Phi2 */
	      d.gradPhi2.x = Vn8*N.x + c1*dvardu7 + c2*dvardv7;
	      d.gradPhi2.y = Vn8*N.y + c3*dvardu7 + c4*dvardv7;
	      d.gradPhi2.z = Vn8*N.z + c5*dvardu7 + c6*dvardv7;
#endif

	      d.zeta = zeta;

	      /* Store time derivative of Phi */
	      d.dtPhi = dtPhi;

	      /* Store time derivative of phi */
	      d.dtphi = dtphi;

	      /* Store time derivative of dzPhi */
	      d.dtdzPhi = dtdzPhi;

	      /* Store time derivative of dzphi */
	      d.dtdzphi = dtdzphi;

	      /* Store gradient of zeta */
	      d.gradzeta.x = Vn10*N.x + c1*dvardu9 + c2*dvardv9;
	      d.gradzeta.y = Vn10*N.y + c3*dvardu9 + c4*dvardv9;
	      d.gradzeta.z = Vn10*N.z + c5*dvardu9 + c6*dvardv9;

	      /* Store gradient of phi0 */
	      Point p = g_array_index (gp->Pi, Point, m+n*ng);
	      d.gradphi0 = wp->wave_potential_gradient (wp, p, t);

	      /* Store gradient of zeta0 */
	      d.gradzeta0 = wp->wave_elevation_gradient (wp, p, t);

	      /* Store zeta0 */
	      d.zeta0 = wp->wave_elevation (p.x, p.y, t, wp);

	      /* Store time derivative of zeta0 */
	      d.dtzeta0 = wp->wave_elevation_time_derivative (wp, p, t);

	      /* Store time derivative of phi0 */
	      d.dtphi0 = wp->wave_potential_dt (wp, p, t);

	      /* Store time derivative of dzphi0 */
	      d.dtdzphi0 = wp->wave_potential_dz_dt (wp, p, t);

	      /* Store gradient of d phi0 / dz */
	      d.graddzphi0 = wp->wave_potential_z_derivative_gradient (wp, p, t);
	    }

	    if ( gp->fsdata->len < ng*ng )
	      g_array_append_val (gp->fsdata, d);
	    else
	      g_array_index (gp->fsdata, FSData, gindex) = d;

	  }
	}

      }
      sp = sp->next;
    }
    patches = patches->next;
  }
}

static void store_gradients_at_gauss_points_linear (Simulation * sim, WaveParams * wp, gdouble t)
{
  gint ii, m, n;
  GSList * patches = simulation_all_patches_list (sim);
  Spline2D * fs = sim->fs->s->patches->data;

  while (patches) {
    Spline2D * sp = patches->data;
    
    while (sp) {
      for ( ii = 0; ii < sp->panels->len; ii++) {
	SPPanel * spp = g_ptr_array_index (sp->panels, ii);
	GaussPoints * gp = spp->outer;
	gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
	gint istart = gp->istart;
	if (sp->periodic)
	  istart -= sp->k-1;
	gint istart_x = gp->istart_x;
	gint jstart = gp->jstart;

	for ( n = 0; n < ng; n++ ) {
	  gdouble vn = g_array_index (gp->vj, gdouble, n);
	  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

	  for ( m = 0; m < ng; m++ ) {
	    gdouble um = g_array_index (gp->ui, gdouble, m);
	    gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	    gint gindex = m + n*ng;
	    gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
	    gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
	    gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
	    gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
	    gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
	    gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
	    Vector N = g_array_index (gp->Ni, Vector, gindex);

	    gint  i, j;
	    FSData d;
	    if ( patches->data != fs) {
	      gdouble  dvardu3, dvardv3, dvardu5, dvardv5, Vn4, Vn6;
	      dvardu3 = dvardv3 = dvardu5 = dvardv5 = Vn4 = Vn6 = 0.;

	      for ( i = 0; i < sp->k; i++) {
		gdouble cu = gsl_matrix_get (Bu, i, 0);
		gdouble cdu = gsl_matrix_get (Bu, i, 1);
		gint i2 = (istart+i);
		for ( j = 0; j < sp->k; j++) {
		  gdouble cv = gsl_matrix_get (Bv, j, 0);
		  gdouble cdv = gsl_matrix_get (Bv, j, 1);
		  gdouble cudv = cu*cdv;
		  gdouble cvdu = cv*cdu;
		  gint j2 = (jstart+j);

		  SplineCoeffs * sc;
		  if (sp->periodic)
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU+sp->k-1));
		  else
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU));

		  dvardu3 += sc->v[3]*cvdu;
		  dvardv3 += sc->v[3]*cudv;
		  dvardu5 += sc->v[5]*cvdu;
		  dvardv5 += sc->v[5]*cudv;
		  Vn4 += sc->v[4]*cu*cv;
		  Vn6 += sc->v[6]*cu*cv;
		}
	      }

	      /* Store gradient of Phi */
	      d.gradPhi.x = Vn4*N.x + c1*dvardu3 + c2*dvardv3;
	      d.gradPhi.y = Vn4*N.y + c3*dvardu3 + c4*dvardv3;
	      d.gradPhi.z = Vn4*N.z + c5*dvardu3 + c6*dvardv3;
	    }
	    else { /* Quantities only needed on the free-surface */
	      gdouble  dvardu3, dvardv3, Vn4;
	      dvardu3 = dvardv3 = Vn4 = 0.;

	      for ( i = 0; i < sp->k; i++) {
		gdouble cu = gsl_matrix_get (Bu, i, 0);
		gdouble cdu = gsl_matrix_get (Bu, i, 1);
		gint i2 = (istart+i);
		for ( j = 0; j < sp->k; j++) {
		  gdouble cv = gsl_matrix_get (Bv, j, 0);
		  gdouble cdv = gsl_matrix_get (Bv, j, 1);
		  gdouble cudv = cu*cdv;
		  gdouble cvdu = cv*cdu;
		  gdouble cuv = cu*cv;
     
		  gint j2 = (jstart+j);

		  SplineCoeffs * sc;
		  if (sp->periodic)
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU+sp->k-1));
		  else
		    sc = g_ptr_array_index (sp->coeffs, i2+ j2*(sp->NU));

		  gdouble v3 = sc->v[3];

		  dvardu3 += v3*cvdu;
		  dvardv3 += v3*cudv;
		  Vn4 += sc->v[4]*cuv;
		}
	      }

	      d.gradPhi.x = Vn4*N.x + c1*dvardu3 + c2*dvardv3;
	      d.gradPhi.y = Vn4*N.y + c3*dvardu3 + c4*dvardv3;
 	      d.gradPhi.z = Vn4*N.z + c5*dvardu3 + c6*dvardv3;
	    }

	    if ( gp->fsdata->len < ng*ng )
	      g_array_append_val (gp->fsdata, d);
	    else
	      g_array_index (gp->fsdata, FSData, gindex) = d;

	  }
	}

      }
      sp = sp->next;
    }
    patches = patches->next;
  }
}

static void store_gradients_at_greville_points (Simulation * sim, WaveParams * wp, gdouble t)
{
  gint ii, m, n;
  GSList * patches = simulation_all_patches_list (sim);
  Spline2D * fs = sim->fs->s->patches->data;

  while (patches) {
    Spline2D * sp = patches->data;
    gint NU = gsl_bspline_ncoeffs (sp->w_u);
    gint NV = gsl_bspline_ncoeffs (sp->w_v);
    GrevillePoints * gr = sp->gr;
    
    for ( n = 0; n < NV; n++ ) {
      gdouble vn = g_array_index (gr->vj, gdouble, n);
      gsl_matrix * Bv = g_ptr_array_index (gr->Bv, n);
      gint jstart = g_array_index (gr->vstart, gint, n);
      
      for ( m = 0; m < NU; m++ ) {
	gdouble um = g_array_index (gr->ui, gdouble, m);
	gsl_matrix * Bu = g_ptr_array_index (gr->Bu, m);
	gint istart = g_array_index (gr->ustart, gint, m);
	if (sp->periodic)
	  istart -= sp->k-1;
	gint  i, j;
	FSData d;

	if ( sp != fs ) {
	  gdouble  dvardu3, dvardv3, dvardu5, dvardv5, Vn4, Vn6;
	  Vector xu, xv;
	  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
	  dvardu3 = dvardv3 = dvardu5 = dvardv5 = Vn4 = Vn6 = 0.;

	  for ( i = 0; i < sp->k; i++) {
	    gdouble cu = gsl_matrix_get (Bu, i, 0);
	    gdouble cdu = gsl_matrix_get (Bu, i, 1);
	    gint ii = (istart+i);
	    for ( j = 0; j < sp->k; j++) {
	      gdouble cv = gsl_matrix_get (Bv, j, 0);
	      gdouble cudv = cu*gsl_matrix_get (Bv, j, 1);
	      gdouble cvdu = cv*cdu;
	      gint jj = (jstart+j);

	      xu.x += coeff (sp,ii,jj, 0)*cvdu;
	      xu.y += coeff (sp,ii,jj, 1)*cvdu;
	      xu.z += coeff (sp,ii,jj, 2)*cvdu;
	      xv.x += coeff (sp,ii,jj, 0)*cudv;
	      xv.y += coeff (sp,ii,jj, 1)*cudv;
	      xv.z += coeff (sp,ii,jj, 2)*cudv;
	      dvardu3 += coeff (sp,ii,jj, 3)*cvdu;
	      dvardv3 += coeff (sp,ii,jj, 3)*cudv;
	      dvardu5 += coeff (sp,ii,jj, 5)*cvdu;
	      dvardv5 += coeff (sp,ii,jj, 5)*cudv;
	      Vn4 += coeff (sp,ii,jj, 4)*cu*cv;
	      Vn6 += coeff (sp,ii,jj, 6)*cu*cv;
	    }
	  }

	  /* Normal to the surface */
	  Vector N = g_array_index (gr->Ni, Vector, m + n*NU);

	  gdouble det = xu.x*(xv.y*N.z-xv.z*N.y)
	    - xu.y*(N.z*xv.x-xv.z*N.x)
	    + xu.z*(xv.x*N.y-xv.y*N.x);
	  det = 1./det;
	  gdouble c1 = (xv.y*N.z-xv.z*N.y)*det;
	  gdouble c2 = (xu.z*N.y-xu.y*N.z)*det;
	  gdouble c3 = (xv.z*N.x-xv.x*N.z)*det;
	  gdouble c4 = (xu.x*N.z-xu.z*N.x)*det;
	  gdouble c5 = (xv.x*N.y-xv.y*N.x)*det;
	  gdouble c6 = (N.x*xu.y-xu.x*N.y)*det;

	  /* Store gradient of Phi */
	  d.gradPhi.x = Vn4*N.x + c1*dvardu3 + c2*dvardv3;
	  d.gradPhi.y = Vn4*N.y + c3*dvardu3 + c4*dvardv3;
	  d.gradPhi.z = Vn4*N.z + c5*dvardu3 + c6*dvardv3;

	  /* Store gradient of phi */
	  d.gradphi.x = Vn6*N.x + c1*dvardu5 + c2*dvardv5;
	  d.gradphi.y = Vn6*N.y + c3*dvardu5 + c4*dvardv5;
	  d.gradphi.z = Vn6*N.z + c5*dvardu5 + c6*dvardv5;
	}
	else { /* Quantities only needed on the free-surface */
	  gdouble  dvardu3, dvardv3, dvardu5, dvardv5, dvardu7, dvardv7, dvardu9, dvardv9, Vn4, Vn6, Vn8, Vn10;
	  gdouble zeta, dtPhi, dtphi, dtdzPhi, dtdzphi;
	  Vector xu, xv;
	  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;
	  dvardu3 = dvardv3 = dvardu5 = dvardv5 = dvardu7 = dvardv7 = dvardu9 = dvardv9 =  Vn4 = Vn6 = Vn8 = Vn10 = 0.;
	  zeta = dtPhi = dtphi = dtdzPhi = dtdzphi = 0.;

	  for ( i = 0; i < sp->k; i++) {
	    gdouble cu = gsl_matrix_get (Bu, i, 0);
	    gdouble cdu = gsl_matrix_get (Bu, i, 1);
	    gint ii = (istart+i);
	    for ( j = 0; j < sp->k; j++) {
	      gdouble cv = gsl_matrix_get (Bv, j, 0);
	      gdouble cudv = cu*gsl_matrix_get (Bv, j, 1);
	      gdouble cvdu = cv*cdu;
	      gdouble cuv = cu*cv;
	      gint jj = (jstart+j);
	      gdouble v0 = coeff (sp,ii,jj, 0);
	      gdouble v1 = coeff (sp,ii,jj, 1);
	      gdouble v2 = coeff (sp,ii,jj, 2);
	      gdouble v3 = coeff (sp,ii,jj, 3);
	      gdouble v5 = coeff (sp,ii,jj, 5);
	      gdouble v7 = coeff (sp,ii,jj, 7);
	      gdouble v9 = coeff (sp,ii,jj, 9);

	      xu.x += v0*cvdu;
	      xu.y += v1*cvdu;
	      xu.z += v2*cvdu;
	      xv.x += v0*cudv;
	      xv.y += v1*cudv;
	      xv.z += v2*cudv;
	      dvardu3 += v3*cvdu;
	      dvardv3 += v3*cudv;
	      dvardu5 += v5*cvdu;
	      dvardv5 += v5*cudv;
	      dvardu7 += v7*cvdu;
	      dvardv7 += v7*cudv;
	      dvardu9 += v9*cvdu;
	      dvardv9 += v9*cudv;
	      Vn4 += coeff (sp,ii,jj, 4)*cuv;
	      Vn6 += coeff (sp,ii,jj, 6)*cuv;
	      Vn8 += coeff (sp,ii,jj, 8)*cuv;
	      Vn10 += coeff (sp,ii,jj, 10)*cuv;
	      zeta += coeff (sp,ii,jj, 9)*cuv;
	      dtPhi += coeff (sp,ii,jj, 11)*cuv;
	      dtphi += (v5 - coeff (sp,ii,jj, 12))*cuv;
	      dtdzPhi += (coeff (sp,ii,jj, 14) - coeff (sp,ii,jj, 20))*cuv;
	      dtdzphi += (coeff (sp,ii,jj, 16) - coeff (sp,ii,jj, 21))*cuv;
	    }
	  }
	  dtphi /= sim->time.dt;
	  dtdzPhi /= sim->time.dt;
	  dtdzphi /= sim->time.dt;

	  /* Normal to the surface */
	  Vector N = g_array_index (gr->Ni, Vector, m + n*NU);

	  gdouble det = xu.x*(xv.y*N.z-xv.z*N.y)
	    - xu.y*(N.z*xv.x-xv.z*N.x)
	    + xu.z*(xv.x*N.y-xv.y*N.x);
	  det = 1./det;
	  gdouble c1 = (xv.y*N.z-xv.z*N.y)*det;
	  gdouble c2 = (xu.z*N.y-xu.y*N.z)*det;
	  gdouble c3 = (xv.z*N.x-xv.x*N.z)*det;
	  gdouble c4 = (xu.x*N.z-xu.z*N.x)*det;
	  gdouble c5 = (xv.x*N.y-xv.y*N.x)*det;
	  gdouble c6 = (N.x*xu.y-xu.x*N.y)*det;

	  /* Store gradient of Phi */
	  d.gradPhi.x = Vn4*N.x + c1*dvardu3 + c2*dvardv3;
	  d.gradPhi.y = Vn4*N.y + c3*dvardu3 + c4*dvardv3;
	  d.gradPhi.z = Vn4*N.z + c5*dvardu3 + c6*dvardv3;

	  /* Store gradient of phi */
	  d.gradphi.x = Vn6*N.x + c1*dvardu5 + c2*dvardv5;
	  d.gradphi.y = Vn6*N.y + c3*dvardu5 + c4*dvardv5;
	  d.gradphi.z = Vn6*N.z + c5*dvardu5 + c6*dvardv5;

	  /* Store gradient of Phi2 */
	  d.gradPhi2.x = Vn8*N.x + c1*dvardu7 + c2*dvardv7;
	  d.gradPhi2.y = Vn8*N.y + c3*dvardu7 + c4*dvardv7;
	  d.gradPhi2.z = Vn8*N.z + c5*dvardu7 + c6*dvardv7;

	  d.zeta = zeta;

	  /* Store time derivative of Phi */
	  d.dtPhi = dtPhi;

	  /* Store time derivative of phi */
	  d.dtphi = dtphi;

	  /* Store time derivative of dzPhi */
	  d.dtdzPhi = dtdzPhi;

	  /* Store time derivative of dzphi */
	  d.dtdzphi = dtdzphi;

	  /* Store gradient of zeta */
	  d.gradzeta.x = Vn10*N.x + c1*dvardu9 + c2*dvardv9;
	  d.gradzeta.y = Vn10*N.y + c3*dvardu9 + c4*dvardv9;
	  d.gradzeta.z = Vn10*N.z + c5*dvardu9 + c6*dvardv9;

	  /* Store gradient of phi0 */
	  Point p = g_array_index (gr->Pi, Point, m+n*NU);
	  d.gradphi0 = wp->wave_potential_gradient (wp, p, t);

	  /* Store gradient of zeta0 */
	  d.gradzeta0 = wp->wave_elevation_gradient (wp, p, t);

	  /* Store zeta0 */
	  d.zeta0 = wp->wave_elevation (p.x, p.y, t, wp);

	  /* Store time derivative of zeta0 */
	  d.dtzeta0 = wp->wave_elevation_time_derivative (wp, p, t);

	  /* Store time derivative of phi0 */
	  d.dtphi0 = wp->wave_potential_dt (wp, p, t);

	  /* Store time derivative of dzphi0 */
	  d.dtdzphi0 = wp->wave_potential_dz_dt (wp, p, t);

	  /* Store gradient of d phi0 / dz */
	  d.graddzphi0 = wp->wave_potential_z_derivative_gradient (wp, p, t);
	}

	if ( gr->fsdata->len < NU*NV )
	  g_array_append_val (gr->fsdata, d);
	else
	  g_array_index (gr->fsdata, FSData, m + n*NU) = d;

      }
    }
    patches = patches->next;
  }
}

typedef struct {
  gsl_vector * rhs1, * rhs2;
} RHSS;

static RHSS * build_dz_galerkin_rhs (Spline2D * sp, WaveParams * wp, gdouble t)
{
  gint i, j, m, n, ii;
  gint size = gsl_bspline_ncoeffs (sp->w_u)*gsl_bspline_ncoeffs (sp->w_v);
  gdouble RHS1[size], RHS2[size];

  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS1[i] = RHS2[i] = 0.;
  }
  
  // Loop over the panels of the patch
  for ( ii = 0; ii < sp->M*sp->N; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    gint ustart = gp->istart;
    gint vstart = gp->jstart;

    for ( m = 0; m < ng; m++) {
      gdouble um = g_array_index (gp->ui, gdouble, m);
      gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	  
      for ( n = 0; n < ng; n++) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);
	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
	//FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
	
	Vector gradPhi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 3);
	Vector gradphi = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 5);
	gdouble fmn1 = gradPhi.z;
	gdouble fmn2 = gradphi.z;

	// Loop over the splines whose support is included in the panel
	for ( i = ustart; i < ustart + sp->k; i++) {
	  gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	  for ( j = vstart; j < vstart + sp->k; j++) {
	    gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	    gint indexi = i + j*gsl_bspline_ncoeffs (sp->w_u);
	 
	    RHS1[indexi] += wmnij*fmn1;
	    RHS2[indexi] += wmnij*fmn2;
	  }
	}
	
      }
    }
    
  }

  // Copy lhs and rhs to gsl structures
  RHSS * rhss = g_malloc (sizeof(RHSS));
  rhss->rhs1 = gsl_vector_alloc (size);
  rhss->rhs2 = gsl_vector_alloc (size);
  for ( i = 0; i < size; i++) {
    gsl_vector_set (rhss->rhs1, i, RHS1[i]);
    gsl_vector_set (rhss->rhs2, i, RHS2[i]);
  }

  return rhss;
}

static gdouble gradPhiz_rhs_new (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
 
  //FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
    
  /* gdouble fmn1 = fsd.gradPhi.z; */
  /* gdouble fmn2 = fsd.gradphi.z; */
  Vector gradPhi = potential_gradient_on_surface_gauss_point (spp->sp, gp, m, n, 3);
  gdouble fmn1 = gradPhi.z;

  return gradPhi.z;
}

static gdouble gradphiz_rhs_new (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
 
  //FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);
    
  /* gdouble fmn1 = fsd.gradPhi.z; */
  /* gdouble fmn2 = fsd.gradphi.z; */
  Vector gradphi = potential_gradient_on_surface_gauss_point (spp->sp, gp, m, n, 5);

  return gradphi.z;
}

static void calculate_dz_spline_coeff_new (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);
  gint i, j;

  while (patches) {
    Spline2D * sp = patches->data;

    if (!sp->fit)
      sp->fit = sp->build_fit_matrix (sp);

    sp->rhs = spline2d_rhs_vector (sp, sp->rhs);

    /* dz Phi */
    sp->rhs = sp->build_fit_rhs (sp, gradPhiz_rhs_new, NULL, NULL, NULL, sp->rhs);
    ccs_problem_lu_solve (sp->fit, sp->rhs);
    sp->copy_fit_solution (sp, sp->rhs, 14);

    /* dz phi */
    sp->rhs = sp->build_fit_rhs (sp, gradphiz_rhs_new, NULL, NULL, NULL, sp->rhs);
    ccs_problem_lu_solve (sp->fit, sp->rhs);
    sp->copy_fit_solution (sp, sp->rhs, 16);

    patches = patches->next;
  }
}

static gdouble gradPhiz_rhs (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
 
  /* FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng); */

  /* return spline2d_eval_gauss_point (spp->sp, gp, m, n, 4); */
  Vector grad = potential_gradient_on_surface_gauss_point (spp->sp, gp, m, n, 3);
  return grad.z;
  /* return fsd.gradPhi.z; */
}

static gdouble gradphiz_rhs (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
 
  /* FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng); */

  /* return spline2d_eval_gauss_point (spp->sp, gp, m, n, 6); */
  Vector grad = potential_gradient_on_surface_gauss_point (spp->sp, gp, m, n, 5);
  return grad.z;
  /* return fsd.gradphi.z; */
}

static void calculate_dz_spline_coeff (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);
  gint i, j;

  while (patches) {
    Spline2D * sp = patches->data;

    if (!sp->fit)
      sp->fit = sp->build_fit_matrix (sp);

    /* dz Phi */
    sp->rhs = sp->build_fit_rhs (sp, gradPhiz_rhs, NULL,
				 NULL, NULL, sp->rhs);
    ccs_problem_lu_solve (sp->fit, sp->rhs);
    sp->copy_fit_solution (sp, sp->rhs, 14);

    /* dz phi */
    sp->rhs = sp->build_fit_rhs (sp, gradphiz_rhs, NULL,
				 NULL, NULL, sp->rhs);
    ccs_problem_lu_solve (sp->fit, sp->rhs);
    sp->copy_fit_solution (sp, sp->rhs, 16);

    patches = patches->next;
  }
}

static void store_dz_gradients_at_gauss_points (Spline2D * sp, WaveParams * wp, gdouble t)
{
  gint ii, m, n;

  while (sp) {
    for ( ii = 0; ii < sp->panels->len; ii++) {
      SPPanel * spp = g_ptr_array_index (sp->panels, ii);
      GaussPoints * gp = spp->outer;
      gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
      gint istart = gp->istart;
      if (sp->periodic)
	istart -= sp->k-1;
      gint istart_x = gp->istart_x;
      gint jstart = gp->jstart;

      for ( n = 0; n < ng; n++ ) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

	for ( m = 0; m < ng; m++ ) {
	  gdouble um = g_array_index (gp->ui, gdouble, m);
	  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	  gsl_matrix * Bux = g_ptr_array_index (gp->Bux, m);
	  gint gindex = m + n*ng;
	  FSData d = g_array_index (gp->fsdata, FSData, gindex);
	  Vector N = g_array_index (gp->Ni, Vector, gindex);
	  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
	  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
	  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
	  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
	  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
	  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
	  gint  i, j;
	  gdouble dvardu14 = 0., dvardv14 = 0., Vn15 = 0.;
	  gdouble dvardu16 = 0., dvardv16 = 0., Vn17 = 0.;

	  for ( i = 0; i < sp->k; i++) {
	    gdouble cu = gsl_matrix_get (Bu, i, 0);
	    gdouble cdu = gsl_matrix_get (Bu, i, 1);
	    gint i2 = (istart+i);
	    for ( j = 0; j < sp->k; j++) {
	      gdouble cv = gsl_matrix_get (Bv, j, 0);
	      gdouble cdv = gsl_matrix_get (Bv, j, 1);
	      gdouble cudv = cu*cdv;
	      gdouble cvdu = cv*cdu;
	      gint j2 = (jstart+j);

	      dvardu14 += coeff (sp,i2,j2, 14)*cvdu;
	      dvardv14 += coeff (sp,i2,j2, 14)*cudv;
	      Vn15 += coeff (sp,i2,j2, 15)*cu*cv;
	      dvardu16 += coeff (sp,i2,j2, 16)*cvdu;
	      dvardv16 += coeff (sp,i2,j2, 16)*cudv;
	      Vn17 += coeff (sp,i2,j2, 17)*cu*cv;
	    }
	  }

	  /* Store gradient of Phi */
	  d.graddzPhi.x = Vn15*N.x + c1*dvardu14 + c2*dvardv14;
	  d.graddzPhi.y = Vn15*N.y + c3*dvardu14 + c4*dvardv14;
	  d.graddzPhi.z = Vn15*N.z + c5*dvardu14 + c6*dvardv14;
	  /* d.graddzPhi.x = d.graddzPhi.y = d.graddzPhi.z = 0.; */

	  /* Store gradient of dz phi */
	  d.graddzphi.x = Vn17*N.x + c1*dvardu16 + c2*dvardv16;
	  d.graddzphi.y = Vn17*N.y + c3*dvardu16 + c4*dvardv16;
	  d.graddzphi.z = Vn17*N.z + c5*dvardu16 + c6*dvardv16;

	  g_array_index (gp->fsdata, FSData, gindex) = d;
	}
      }

    }
    sp = sp->next;
  }
}

static void store_dz_gradients_at_gauss_points_linear (Spline2D * sp, WaveParams * wp, gdouble t)
{
  gint ii, m, n;

  while (sp) {
    for ( ii = 0; ii < sp->panels->len; ii++) {
      SPPanel * spp = g_ptr_array_index (sp->panels, ii);
      GaussPoints * gp = spp->outer;
      gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
      gint istart = gp->istart;
      if (sp->periodic)
	istart -= sp->k-1;
      gint istart_x = gp->istart_x;
      gint jstart = gp->jstart;

      for ( n = 0; n < ng; n++ ) {
	gdouble vn = g_array_index (gp->vj, gdouble, n);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

	for ( m = 0; m < ng; m++ ) {
	  gdouble um = g_array_index (gp->ui, gdouble, m);
	  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
	  gint gindex = m + n*ng;
	  FSData d = g_array_index (gp->fsdata, FSData, gindex);
	  Vector N = g_array_index (gp->Ni, Vector, gindex);
	  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
	  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
	  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
	  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
	  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
	  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
	  gint  i, j;
	  gdouble dvardu4 = 0., dvardv4 = 0., Vn15 = 0.;

	  for ( i = 0; i < sp->k; i++) {
	    gdouble cu = gsl_matrix_get (Bu, i, 0);
	    gdouble cdu = gsl_matrix_get (Bu, i, 1);
	    gint i2 = (istart+i);
	    for ( j = 0; j < sp->k; j++) {
	      gdouble cv = gsl_matrix_get (Bv, j, 0);
	      gdouble cdv = gsl_matrix_get (Bv, j, 1);
	      gdouble cudv = cu*cdv;
	      gdouble cvdu = cv*cdu;
	      gint j2 = (jstart+j);

	      dvardu4 += coeff (sp,i2,j2, 4)*cvdu;
	      dvardv4 += coeff (sp,i2,j2, 4)*cudv;
	      Vn15 += coeff (sp,i2,j2, 15)*cu*cv;
	    }
	  }

	  /* Store gradient of Phi */
	  d.graddzPhi.x = Vn15*N.x + c1*dvardu4 + c2*dvardv4;
	  d.graddzPhi.y = Vn15*N.y + c3*dvardu4 + c4*dvardv4;
	  d.graddzPhi.z = Vn15*N.z + c5*dvardu4 + c6*dvardv4;

	  g_array_index (gp->fsdata, FSData, gindex) = d;
	}
      }

    }
    sp = sp->next;
  }
}

/**
 * Store and calculate the various gradient quantities required
 * to solve the surface elevation equation and the disturbance
 * potential equation (dynamic and kinematic free-surface conditions).
 **/
static void simulation_calculate_gradients (Simulation * sim)
{
  /* Start timer */
  g_test_timer_start ();

  /* Calculate and store potential gradient at outer gauss points */
  store_gradients_at_gauss_points (sim, &sim->wp, sim->time.t);
  // store_gradients_at_greville_points (sim, &sim->wp, sim->time.t);
#if 1
  /* Build and solve galerkin problem and store dz Phi and dz phi as variables */
  calculate_dz_spline_coeff (sim);

  /* Build rhs and solve the Dirichlet boundary problem to get grad (dz Phi).n */
  simulation_build_dirichlet_sub_problems_rhs (sim, 14);
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  /* Solves the dirichlet problem */
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  /* Copies the solution back to the patches (stored in variable 15) */
  GSList * patches = simulation_all_patches_list (sim);
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 15);

  /* Build rhs and solve the Dirichlet boundary problem to get grad (dz phi).n */
  //simulation_build_dirichlet_sub_problems_rhs (sim, 16);
  //boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  // /* Solves the dirichlet problem */
  //sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  /* Copies the solution back to the patches (stored in variable 17) */
  //cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 17);
#endif
  /* Calculate and store gradient of dz Phi and dz phi on the
     free surface at outer gauss points*/
  Spline2D * fs = sim->fs->s->patches->data;
  store_dz_gradients_at_gauss_points (fs, &sim->wp, sim->time.t);

  /* Stop timer and print */
  fprintf (stdout, "   Calculate gradients: %f \n", g_test_timer_elapsed());
}

static gdouble gradphi1z_rhs (SPPanel * spp, gint m, gint n, gpointer data)
{
  Vector grad = potential_gradient_on_surface_gauss_point (spp->sp, spp->outer, m, n, 7);

  return grad.z;
}

static void calculate_phi1dz_spline_coeff (Simulation * sim)
{
  GSList * patches = simulation_all_patches_list (sim);
  gint i, j;

  while (patches) {
    Spline2D * sp = patches->data;

    /* dz Phi */
    sp->rhs = sp->build_fit_rhs (sp, gradphi1z_rhs, NULL,
				 NULL, NULL, sp->rhs);
    ccs_problem_lu_solve (sp->fit, sp->rhs);
    sp->copy_fit_solution (sp, sp->rhs, 42);

    patches = patches->next;
  }
}

static void simulation_calculate_dphi1dzdz (Simulation * sim)
{

  /* Build and solve galerkin problem and store dz phi1 as variables */
  calculate_phi1dz_spline_coeff (sim);

  /* Build rhs and solve the Dirichlet boundary problem to get grad (dz Phi).n */
  simulation_build_dirichlet_sub_problems_rhs (sim, 42);
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  /* Solves the dirichlet problem */
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  /* Copies the solution back to the patches (stored in variable 15) */
  GSList * patches = simulation_all_patches_list (sim);
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 42);
}

static gdouble test_dx (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);

  return fsd.gradPhi.x;
}

static gdouble test_dy (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);

  return fsd.gradPhi.y;
}

static gdouble test_dzz (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  //FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng);

  Vector gradx = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 14);
  Vector grady = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 15);

  return -gradx.x-grady.y;
}

static void test_dz (Simulation * sim)
{
  // Works because the free-surface is flat
  Spline2D * fs = sim->fs->s->patches->data;

  // Store dx Phi
  fs->rhs = fs->build_fit_rhs (fs, test_dx, sim, NULL, NULL, fs->rhs);
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->copy_fit_solution (fs, fs->rhs, 14);

  // Store dy Phi
  fs->rhs = fs->build_fit_rhs (fs, test_dy, sim, NULL, NULL, fs->rhs);
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->copy_fit_solution (fs, fs->rhs, 15);

  // Store dzdz Phi = - dxdx Phi - dydy Phi
  fs->rhs = fs->build_fit_rhs (fs, test_dzz, sim, NULL, NULL, fs->rhs);
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->copy_fit_solution (fs, fs->rhs, 15);
}

static void simulation_calculate_gradients_linear (Simulation * sim)
{
  /* Start timer */
  g_test_timer_start ();

  /* Calculate and store potential gradient at outer gauss points */
  store_gradients_at_gauss_points_linear (sim, &sim->wp, sim->time.t);
#if 1
  /* Build and solve galerkin problem and store dz Phi and dz phi as variables */
  calculate_dz_spline_coeff (sim);

  /* Build rhs and solve the Dirichlet boundary problem to get grad (dz Phi).n */
  simulation_build_dirichlet_sub_problems_rhs (sim, 14);
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  /* if (sim->continuity) */
  /*   add_dirichlet_continuity_conditions_rhs (sim, sim->dirichlet_problem, 14); */

  /* Solves the dirichlet problem */
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  /* Copies the solution back to the patches (stored in variable 15) */
  GSList * patches = simulation_all_patches_list (sim);
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 15);
#else
  test_dz (sim);
#endif
  /* Calculate and store gradient of dz Phi and dz phi on the
     free surface at outer gauss points*/
  Spline2D * fs = sim->fs->s->patches->data;
  store_dz_gradients_at_gauss_points_linear (fs, &sim->wp, sim->time.t);

  /* Stop timer and print */
  fprintf (stdout, "   Calculate gradients: %f \n", g_test_timer_elapsed());
}

/***********************************************************************************************/
static void local_pressure_forces_contribution (Spline2D * sp,
						Simulation * sim,
						gpointer data,
						gdouble u, gdouble v,
						gdouble weight, 
						HeightCurve hz,
						gdouble t,
						gpointer hz_data)
{
  Forces * f = (Forces *) data;
  gdouble Pm = 0., Pl = 0., Ph = 0., Pfk = 0., Pr = 0.;
  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  gdouble v5n = 0., v3n = 0., v7n = 0.;
  gdouble d5u = 0., d3u = 0., d7u = 0.;
  gdouble d5v = 0., d3v = 0., d7v = 0.;
  Vector gradphi, gradPhi, gradPhi2;

  gdouble var5 = 0., var7 = 0., var11 = 0., var12 = 0., var23 = 0.;

  gint  i, j;
  size_t istart, iend, jstart, jend, istart_x;
  gsl_matrix * Bu = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bu, &istart, &iend, sp->w_u, sp->wd_u);
  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,v), 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  if (sp->periodic)
    istart -= sp->k-1;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    gint ii = istart;
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cudv = cu*cdv;
      gdouble cvdu = cv*cdu;
      gdouble cuv = cu*cv;
      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
      gdouble v3 = coeff (sp,ii,jj,3);
      gdouble v5 = coeff (sp,ii,jj,5);
      gdouble v7 = coeff (sp,ii,jj,7);

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;

      d3u += v3*cvdu;
      d3v += v3*cudv;
      v3n += coeff (sp,ii,jj,4)*cuv;

      d5u += v5*cvdu;
      d5v += v5*cudv;
      v5n += coeff (sp,ii,jj,6)*cuv;

      d7u += v7*cvdu;
      d7v += v7*cudv;
      v7n += coeff (sp,ii,jj,8)*cuv;

      var5 += v5*cuv;
      var7 += v7*cuv;
      var11 += coeff (sp,ii,jj,11)*cuv;
      var12 += coeff (sp,ii,jj,12)*cuv;
      var23 += coeff (sp,ii,jj,23)*cuv;
    }
    istart++;
    istart_x++;
  }

 // Position in inertial reference frame
 Point p_inertial = hull_transformed_point (sim->hull, p);
 
 gsl_matrix_free (Bu);
 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.x /= J; N.y /= J; N.z /= J;
 gdouble det = xu.x*(xv.y*N.z-xv.z*N.y)
   - xu.y*(N.z*xv.x-xv.z*N.x)
   + xu.z*(xv.x*N.y-xv.y*N.x);
 det = 1./det;
 gdouble c1 = (xv.y*N.z-xv.z*N.y)*det;
 gdouble c2 = (xu.z*N.y-xu.y*N.z)*det;
 gdouble c3 = (xv.z*N.x-xv.x*N.z)*det;
 gdouble c4 = (xu.x*N.z-xu.z*N.x)*det;
 gdouble c5 = (xv.x*N.y-xv.y*N.x)*det;
 gdouble c6 = (N.x*xu.y-xu.x*N.y)*det;

 gradPhi.x = c1*d3u + c2*d3v + v3n*N.x;
 gradPhi.y = c3*d3u + c4*d3v + v3n*N.y;
 gradPhi.z = c5*d3u + c6*d3v + v3n*N.z;

 gradphi.x = c1*d5u + c2*d5v + v5n*N.x;
 gradphi.y = c3*d5u + c4*d5v + v5n*N.y;
 gradphi.z = c5*d5u + c6*d5v + v5n*N.z;

 gradPhi2.x = c1*d7u + c2*d7v + v7n*N.x;
 gradPhi2.y = c3*d7u + c4*d7v + v7n*N.y;
 gradPhi2.z = c5*d7u + c6*d7v + v7n*N.z;

 Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  
 gdouble dt = sim->time.dt;
 gdouble dtPhi = var11;
 gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);
 gdouble dtphi = (var5-var12)/dt;
 gdouble dtPhi2 = (var7-var23)/dt;

 Vector w = sim->U;
 w.x -= gradPhi.x; w.y -= gradPhi.y; w.z -= gradPhi.z;

 /* Memory flow pressure */
 Pm = -sim->rho*(dtPhi - vector_scalar_product (&w, &gradPhi)
		 -0.5*vector_scalar_product (&gradPhi, &gradPhi));

 w.x -= gradphi0.x; w.y -= gradphi0.y; w.z -= gradphi0.z;

 Pm -= sim->rho*(- vector_scalar_product (&w, &gradphi0));

#if 0
 sim->rho*0.5*vector_scalar_product (&gradphi0, &gradphi0);
#endif

 w.x -= gradphi.x; w.y -= gradphi.y; w.z -= gradphi.z;

 Pm -= sim->rho*(dtPhi2 - vector_scalar_product (&w, &gradPhi2));
  
 /* Local flow pressure */
 Pl = -sim->rho*(dtphi - vector_scalar_product (&w, &gradphi));

#if 0
 Pl += sim->rho*0.5*vector_scalar_product (&gradphi, &gradphi);
#endif

 /* Hydrostatic pressure */
 Ph = -sim->rho*sim->g*(p_inertial.z-hz(p_inertial.x, p_inertial.y, t, hz_data));
 /* Ph = 1.; */
 J *= weight;

 /* Froude Krylov-Forces */
 Pfk = -sim->rho*dtphi0;

 /* Forces */
 forces_add_contribution_forces (f, &N, Pm*J, Pl*J, Ph*J, Pfk*J, Pr*J);
    
 /* Moments */
 Vector x;
 Point xg = sim->hull->xg;
 x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z;
 x = vector_vector_product (&x, &N);

 forces_add_contribution_moments (f, &x, Pm*J, Pl*J, Ph*J, Pfk*J, Pr*J);
}

static Pressure local_pressure_gauss (SPPanel * spp, gint m, gint n, Simulation * sim,
				      HeightCurve hz, gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  Vector force;

  gdouble dt = sim->time.dt;
  gint gindex = m + n*ng;
  Vector N = g_array_index (gp->Ni, Vector, gindex);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
  Point p = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t);
  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p, t);

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gsl_matrix * Bux = g_ptr_array_index (gp->Bux, m);
  gint ustart_x = gp->istart_x;
  gint ustart = sp->periodic ? gp->istart - sp->k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble phin = 0., Phin = 0., Phi2n = 0., dtPhi = 0.;
  gdouble phi = 0., old_phi = 0., Phi2 = 0., old_Phi2 = 0.;
  gdouble dphidu = 0., dPhidu = 0., dPhi2du = 0.;
  gdouble dphidv = 0., dPhidv = 0., dPhi2dv = 0.;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      gdouble cudv = cu*cdv;
      gdouble cvdu = cv*cdu;
      jj = (vstart+j);

      dphidu += coeff (sp,ii,jj, 5)*cvdu;
      dphidv += coeff (sp,ii,jj, 5)*cudv;
      phin += coeff (sp,ii,jj, 6)*cuv;
      dPhidu += coeff (sp,ii,jj, 3)*cvdu;
      dPhidv += coeff (sp,ii,jj, 3)*cudv;
      Phin += coeff (sp,ii,jj, 4)*cuv;
      dPhi2du += coeff (sp,ii,jj, 7)*cvdu;
      dPhi2dv += coeff (sp,ii,jj, 7)*cudv;
      Phi2n += coeff (sp,ii,jj, 8)*cuv;
      dtPhi += coeff (sp,ii,jj, 11)*cuv;
      phi += coeff (sp,ii,jj, 5)*cuv;
      old_phi += coeff (sp,ii,jj, 12)*cuv;
      Phi2 += coeff (sp,ii,jj, 7)*cuv;
      old_Phi2 += coeff (sp,ii,jj, 23)*cuv;
    }
  }
   
  Vector gradphi;
  gradphi.x = phin*N.x + c1*dphidu + c2*dphidv;
  gradphi.y = phin*N.y + c3*dphidu + c4*dphidv;
  gradphi.z = phin*N.z + c5*dphidu + c6*dphidv;

  Vector gradPhi;
  gradPhi.x = Phin*N.x + c1*dPhidu + c2*dPhidv;
  gradPhi.y = Phin*N.y + c3*dPhidu + c4*dPhidv;
  gradPhi.z = Phin*N.z + c5*dPhidu + c6*dPhidv;

  Vector gradPhi2;
  gradPhi2.x = Phi2n*N.x + c1*dPhi2du + c2*dPhi2dv;
  gradPhi2.y = Phi2n*N.y + c3*dPhi2du + c4*dPhi2dv;
  gradPhi2.z = Phi2n*N.z + c5*dPhi2du + c6*dPhi2dv;

  gdouble dtphi = (phi-old_phi)/dt;
  gdouble dtPhi2 = (Phi2-old_Phi2)/dt;

  Vector w = sim->U;
  w.x -= gradPhi.x; w.y -= gradPhi.y; w.z -= gradPhi.z;

  /* Memory flow pressure */
  pressure.Pm = -sim->rho*(dtPhi - vector_scalar_product (&w, &gradPhi) 
			  -0.5*vector_scalar_product (&gradPhi, &gradPhi));

  w.x -= gradphi0.x; w.y -= gradphi0.y; w.z -= gradphi0.z;

  pressure.Pm -= sim->rho*(- vector_scalar_product (&w, &gradphi0)
		  -0.5*vector_scalar_product (&gradphi0, &gradphi0));

  w.x -= gradphi.x; w.y -= gradphi.y; w.z -= gradphi.z;

  pressure.Pm -= sim->rho*(dtPhi2 - vector_scalar_product (&w, &gradPhi2));
  
  /* Local flow pressure */
  pressure.Pl =  -sim->rho*(dtphi - vector_scalar_product (&w, &gradphi)
			    -0.5*vector_scalar_product (&gradphi, &gradphi));

  /* Hydrostatic pressure */
  pressure.Ph = -sim->rho*sim->g *( p.z - hz(p.x, p.y, t, hz_data));
  // pressure.Ph = 1.;

  /* Non-linear Froude-Krylov forces */
  pressure.Pfk = -sim->rho*dtphi0;

  /* Non-linear restoring forces */
  pressure.Pr = 0.;

  return pressure;
}

static void sppanel_pressure_force_integral_gauss (SPPanel * spp,
						   Simulation * sim,
						   gpointer data,
						   gint m, gint n,
						   HeightCurve hz,
						   gdouble t,
						   gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /* if (sim->time.itime == 0) */
  /*   sppanel_print (spp, stdout); */

  /** Gauss Action **/
  Pressure lp = local_pressure_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector Ni = g_array_index (gp->Ni, Vector, m + n*ng);

  forces_add_contribution_forces (f, &Ni, wij*lp.Pm, wij*lp.Pl, wij*lp.Ph, wij*lp.Pfk, wij*lp.Pr);

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &Ni);

  forces_add_contribution_moments (f, &x, wij*lp.Pm, wij*lp.Pl, wij*lp.Ph, wij*lp.Pfk, wij*lp.Pr);

  /*********************/

}

static void sppanel_integral_gauss (SPPanel * spp, Simulation * sim, gpointer int_data,
				    LocalGaussIntegrationFunc local_gauss_integration_func,	    
				    HeightCurve hz, gdouble t, gpointer hz_data)
{
  gint ng = spp->sp->nouter;
  gint m, n;

  for ( m = 0; m < ng; m++)
    for ( n = 0; n < ng; n++)
      local_gauss_integration_func (spp, sim, int_data, m, n, hz, t, hz_data);
}

CornerPoint * corner_point_new (Spline2D * sp, Hull * h, 
				gdouble u, gdouble v,
				HeightCurve hz, double t, gpointer data)
{
  CornerPoint * cp = g_malloc (sizeof(CornerPoint));
  //Point p = spline2d_hull_eval_point (sp, h, u, v);
  Point p = hull_transformed_eval_point (h, sp, u, v);

  cp->u = u;
  cp->v = v;
  cp->p = p;

  if ( (p.z - hz (p.x, p.y, t, data)) < 0.) {
    cp->is_wet = TRUE;
  }
  else
    cp->is_wet = FALSE;

  return cp;
}

CornerPoint * corner_point_new_uv (Spline2D * sp, Hull * h, 
				   gdouble u, gdouble v,
				   HeightCurve hz, double t, gpointer data)
{
  CornerPoint * cp = g_malloc (sizeof(CornerPoint));
  //Point p = spline2d_hull_eval_point (sp, h, u, v);
  Point p = hull_transformed_eval_point (h, sp, u, v);

  cp->u = u;
  cp->v = v;
  cp->p = p;

  if ( (p.z - hz (u, v, t, sp)) < 0.) {
    cp->is_wet = TRUE;
  }
  else
    cp->is_wet = FALSE;

  return cp;
}

CornerPoint * corner_point_new_uv_linear (Spline2D * sp, Hull * h, 
					  gdouble u, gdouble v,
					  HeightCurve hz, double t, gpointer data)
{
  CornerPoint * cp = g_malloc (sizeof(CornerPoint));
  Point p = spline2d_eval_point (sp, u, v);

  cp->u = u;
  cp->v = v;
  cp->p = p;

  if ( (p.z - /* flat_sea (u, v, t, sp) */0.) < 0.) {
    cp->is_wet = TRUE;
  }
  else
    cp->is_wet = FALSE;

  return cp;
}

void corner_point_destroy (CornerPoint * cp)
{
  g_free (cp);
}

static void sppanel_pressure_force_integral (Forces * f,
					     Spline2D * sp,
					     gdouble u0, gdouble u1,
					     gdouble v0, gdouble v1,
					     Simulation * sim,
					     HeightCurve hz,
					     gdouble t,
					     gpointer hz_data)
{
  /* if (sim->time.itime == 0) { */
  /*   /\* g_assert_not_reached (); *\/ */
  /*   Point p = spline2d_eval_point (sp, u0, v0); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u1, v0); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u1, v1); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u0, v1); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u0, v0); */
  /*   fprintf(stdout, "%f %f %f \n\n\n", p.x, p.y, p.z); */
  /* } */

  gint ng =  sp->nouter;
  gint i, m, n;
  gsl_integration_glfixed_table * itable =  gsl_integration_glfixed_table_alloc (ng);
  gsl_integration_glfixed_table * jtable =  gsl_integration_glfixed_table_alloc (ng);
  gdouble ui[ng], wi[ng];
  gdouble vj[ng], wj[ng];

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (u0, u1, i, &ui[i], &wi[i], itable);
    gsl_integration_glfixed_point (v0, v1, i, &vj[i], &wj[i], jtable);
  }

  for ( m = 0; m < ng; m++)
    for ( n = 0; n < ng; n++)
      local_pressure_forces_contribution (sp, sim, f, ui[m], vj[n], wi[m]*wj[n], hz, t, hz_data);
      /* local_pressure_forces_contribution (f, sp, ui[m], vj[n], wi[m]*wj[n], sim, hz, t, hz_data); */

  gsl_integration_glfixed_table_free (itable);
  gsl_integration_glfixed_table_free (jtable);
}

static void sub_sppanel_integral (gpointer int_data,
				  Spline2D * sp,
				  gdouble u0, gdouble u1,
				  gdouble v0, gdouble v1,
				  Simulation * sim,
				  LocalIntegrationFunc local_int_func,
				  HeightCurve hz,
				  gdouble t,
				  gpointer hz_data)
{
  /* if (sim->time.itime == 0) { */
  /*   /\* g_assert_not_reached (); *\/ */
  /*   Point p = spline2d_eval_point (sp, u0, v0); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u1, v0); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u1, v1); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u0, v1); */
  /*   fprintf(stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   p = spline2d_eval_point (sp, u0, v0); */
  /*   fprintf(stdout, "%f %f %f \n\n\n", p.x, p.y, p.z); */
  /* } */

  gint ng =  sp->nouter;
  gint i, m, n;
  gsl_integration_glfixed_table * itable =  gsl_integration_glfixed_table_alloc (ng);
  gsl_integration_glfixed_table * jtable =  gsl_integration_glfixed_table_alloc (ng);
  gdouble ui[ng], wi[ng];
  gdouble vj[ng], wj[ng];

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (u0, u1, i, &ui[i], &wi[i], itable);
    gsl_integration_glfixed_point (v0, v1, i, &vj[i], &wj[i], jtable);
  }

  for ( m = 0; m < ng; m++)
    for ( n = 0; n < ng; n++)
      local_int_func (sp, sim, int_data, ui[m], vj[n], wi[m]*wj[n], hz, t, hz_data);

  gsl_integration_glfixed_table_free (itable);
  gsl_integration_glfixed_table_free (jtable);
}

static CornerPoint * intersection_u (Spline2D * sp, Hull * h, CornerPoint * p0, CornerPoint * p1,
				     HeightCurve hz, gdouble t, gpointer hz_data)
{
  gdouble tolerance = 1e-3;
  CornerPoint * cp;

  g_assert (!(p0->is_wet && p1->is_wet));

  g_assert_not_reached ();
  // Might want to use the function pointer to create the point
  CornerPoint * pm = corner_point_new (sp, h, (p0->u+p1->u)/2., p0->v, hz, t, hz_data);

  if (fabs(p1->u-p0->u) < tolerance)
    return pm;

  if ( p0->is_wet != pm->is_wet )
    cp = intersection_u (sp, h, p0, pm, hz, t, hz_data);
  else
    cp = intersection_u (sp, h, pm, p1, hz, t, hz_data);
  
  corner_point_destroy (pm);
  return cp;
}

static CornerPoint * intersection_v (Spline2D * sp, Hull * h, CornerPoint * p0, CornerPoint * p1,
				     HeightCurve hz, gdouble t, gpointer hz_data)
{
  gdouble tolerance = 1e-3;
  CornerPoint * cp;

  g_assert (!(p0->is_wet && p1->is_wet));

  CornerPoint * pm = corner_point_new (sp, h, p0->u, (p0->v+p1->v)/2., hz, t, hz_data);

  if (fabs(p1->v-p0->v) < tolerance)
    return pm;

  if ( p0->is_wet != pm->is_wet )
    cp = intersection_v (sp, h, p0, pm, hz, t, hz_data);
  else
    cp = intersection_v (sp, h, pm, p1, hz, t, hz_data);
  
  corner_point_destroy (pm);
  return cp;
}

static void integrate_quadrilateral (Forces * f,
				     Spline2D * sp,
				     CornerPoint * p00, CornerPoint * p01,
				     CornerPoint * p11, CornerPoint * p10,
				     Simulation * sim, HeightCurve hz, gdouble t,
				     gpointer hz_data)
{
  gint i, j, ng = sp->nouter;
  gsl_integration_glfixed_table * itable =  gsl_integration_glfixed_table_alloc (ng);
  gdouble ui[ng], wi[ng];

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (0, 1., i, &ui[i], &wi[i], itable);
  }

  // Mapping to a square

  gdouble du1 = p01->u-p00->u;
  gdouble du2 = p11->u-p10->u;
  gdouble dv1 = p01->v-p00->v;
  gdouble dv2 = p11->v-p10->v;

  for ( i = 0; i < ng; i++ ) {
    for ( j = 0; j < ng; j++ ) {
      gdouble u = (p00->u+du1*ui[i])*(1-ui[j]) + (p10->u+ui[i]*du2)*ui[j];
      gdouble v = (p00->v+dv1*ui[i])*(1-ui[j]) + (p10->v+dv2*ui[i])*ui[j];
      gdouble J = (du1*(1-ui[j]) + du2*ui[j])*( (p10->v+dv2*ui[i]) - (p00->v+dv1*ui[i]) ) - ( (p10->u+ui[i]*du2) - (p00->u+du1*ui[i]) )*( dv1*(1-ui[j]) + dv2*ui[j] );
      local_pressure_forces_contribution (sp, sim, f, u, v, wi[i]*wi[j]*J, hz, t, hz_data);
    }
  }
 
  gsl_integration_glfixed_table_free (itable);
}

static void test_quadrilateral ()
{
  gint i, j, ng = 4;
  gsl_integration_glfixed_table * itable =  gsl_integration_glfixed_table_alloc (ng);
  gdouble ui[ng], wi[ng];

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (0, 1., i, &ui[i], &wi[i], itable);
  }

  // Mapping to a square

  gdouble p00u, p01u, p11u, p10u;
  gdouble p00v, p01v, p11v, p10v;

  p00u = 0;
  p00v = 0;

  p01u = 6;
  p01v = 0.;

  p11u = 5.5;
  p11v = 2.;

  p10u = 4.;
  p10v = 2.;

  gdouble du1 = p01u-p00u;
  gdouble du2 = p11u-p10u;
  gdouble dv1 = p01v-p00v;
  gdouble dv2 = p11v-p10v;

  gdouble val = 0.;

  for ( i = 0; i < ng; i++ ) {
    for ( j = 0; j < ng; j++ ) {
      gdouble u = (p00u+du1*ui[i])*(1-ui[j]) + (p10u+ui[i]*du2)*ui[j];
      gdouble v = (p00v+dv1*ui[i])*(1-ui[j]) + (p10v+dv2*ui[i])*ui[j];
      gdouble J = (du1*(1-ui[j]) + du2*ui[j])*( (p10v+dv2*ui[i]) - (p00v+dv1*ui[i]) ) - ( (p10u+ui[i]*du2) - (p00u+du1*ui[i]) )*( dv1*(1-ui[j]) + dv2*ui[j] );

      val += wi[i]*wi[j]*J;

      // local_pressure_forces_contribution (f, sp, u, v, wi[i]*wi[j]*J, sim);
    }
  }
 
  fprintf (stderr, "%f \n", val);
  
  gsl_integration_glfixed_table_free (itable);
  g_assert_not_reached ();
}

static void integrate_triangle (Forces * f,
				Spline2D * sp,
				CornerPoint * c,
				CornerPoint * pu, CornerPoint * pv,
				Simulation * sim, HeightCurve hz,
				gdouble t,
				gpointer hz_data,
				gdouble weight)
{
  gint i, j, ng = sp->nouter;
  gsl_integration_glfixed_table * itable =  gsl_integration_glfixed_table_alloc (ng);
  gdouble ui[ng], wi[ng];

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (0, 1., i, &ui[i], &wi[i], itable);
  }

  // MAYBE
  gdouble du = (pu->u - c->u);
  gdouble dv = (pv->v - c->v);

  for ( j = 0; j < ng; j++) {
    gdouble v = c->v + dv*ui[j];
    for ( i = 0; i < ng; i++) {
      gdouble u = c->u + du*ui[i]*(1.-ui[j]);
      local_pressure_forces_contribution (sp, sim, f, u, v, wi[i]*wi[j]*weight*du*dv*(1-ui[j]), hz, t, hz_data);
    }
  }

  gsl_integration_glfixed_table_free (itable);
}

static void test_triangle ()
{
  gint i, j, ng = 3;
  gsl_integration_glfixed_table * itable =  gsl_integration_glfixed_table_alloc (ng);
  gdouble ui[ng], wi[ng];

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (0, 1., i, &ui[i], &wi[i], itable);
  }

  gdouble cu, cv, pu, pv;
  cu = 0.;
  cv = 0.;
  pu = 3.;
  pv = 1.;

  // MAYBE
  gdouble du = (pu - cu);
  gdouble dv = (pv - cv);
  gdouble val = 0.;

  for ( j = 0; j < ng; j++) {
    gdouble v = cv + dv*ui[j];
    for ( i = 0; i < ng; i++) {
      gdouble u = cu + du*ui[i]*(1.-ui[j]);
      //local_pressure_forces_contribution (f, sp, u, v, wi[i]*wi[j]*weight*du*dv*(1-ui[j]), sim);
      val += wi[i]*wi[j]*du*dv*(1-ui[j]);
    }
  }

  fprintf (stderr, " %f \n", val);

  gsl_integration_glfixed_table_free (itable);
  g_assert_not_reached ();
}

/**
 * This is the start of the second order algorithm.
 * It needs to be fixed. First the "corners" needs to be found.
 * Then the integration should be adapted 
 **/
static void sppanel_pressure_force_integral_second_order (Forces * f,
							  Spline2D * sp,
							  CornerPoint * p00, CornerPoint * p10,
							  CornerPoint * p01, CornerPoint * p11,
							  Simulation * sim, HeightCurve hz, gdouble t,
							  gpointer hz_data)
{
  gint n_wet_corner = 0.;

  // Find number of wet corners
  if ( p00->is_wet )
    n_wet_corner++;
  if ( p01->is_wet )
    n_wet_corner++;
  if ( p10->is_wet )
    n_wet_corner++;
  if ( p11->is_wet )
    n_wet_corner++;

  g_assert ( n_wet_corner > 0 && n_wet_corner < 4);
  if ( n_wet_corner == 1 ) { // Triangle
    if ( p00->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p00, p01, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p00, p10, hz, t, hz_data);
      // + integrate triangle
      integrate_triangle (f, sp, p00, pu, pv, sim, hz, t, hz_data, 1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
    if ( p01->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p00, p01, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p01, p11, hz, t, hz_data);
      integrate_triangle (f, sp, p01, pu, pv, sim, hz, t, hz_data, 1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
    if ( p10->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p10, p11, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p00, p10, hz, t, hz_data);
      integrate_triangle (f, sp, p10, pu, pv, sim, hz, t, hz_data, 1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
    if ( p11->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p10, p11, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p01, p11, hz, t, hz_data);
      integrate_triangle (f, sp, p11, pu, pv, sim, hz, t, hz_data, 1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
  }

  if ( n_wet_corner == 2 ) { // Quadrilateral
    if ( p00->is_wet && p01->is_wet ) {
      CornerPoint * p0 = intersection_v (sp, sim->hull, p00, p10, hz, t, hz_data);
      CornerPoint * p1 = intersection_v (sp, sim->hull, p01, p11, hz, t, hz_data);
      //integrate_quadrilateral (p00, p01, p1, p0);
      integrate_quadrilateral (f, sp, p00, p01, p1, p0, sim, hz, t, hz_data);
      corner_point_destroy (p0);
      corner_point_destroy (p1);
      return;
    }
    if ( p10->is_wet && p11->is_wet ) {
      CornerPoint * p0 = intersection_v (sp, sim->hull, p00, p10, hz, t, hz_data);
      CornerPoint * p1 = intersection_v (sp, sim->hull, p01, p11, hz, t, hz_data);
      //integrate_quadrilateral (p0, p1, p11, p10);
      integrate_quadrilateral (f, sp, p0, p1, p11, p10, sim, hz, t, hz_data);
      corner_point_destroy (p0);
      corner_point_destroy (p1);
      return;
    }
     if ( p00->is_wet && p10->is_wet ) {
      CornerPoint * p0 = intersection_u (sp, sim->hull, p00, p01, hz, t, hz_data);
      CornerPoint * p1 = intersection_u (sp, sim->hull, p10, p11, hz, t, hz_data);
      //integrate_quadrilateral (p00, p0, p1, p10);
      integrate_quadrilateral (f, sp, p00, p0, p1, p10, sim, hz, t, hz_data);
      corner_point_destroy (p0);
      corner_point_destroy (p1);
      return;
    }
    if ( p01->is_wet && p11->is_wet ) {
      CornerPoint * p0 = intersection_u (sp, sim->hull, p00, p01, hz, t, hz_data);
      CornerPoint * p1 = intersection_v (sp, sim->hull, p10, p11, hz, t, hz_data);
      //integrate_quadrilateral (p0, p01, p11, p1);
      integrate_quadrilateral (f, sp, p0, p01, p11, p1, sim, hz, t, hz_data);
      corner_point_destroy (p0);
      corner_point_destroy (p1);
      return;
    }
  }

  if ( n_wet_corner == 3 ) { // Rectangle - triangle
    sppanel_pressure_force_integral (f, sp, p00->u, p11->u, p00->v, p11->v, sim, hz, t, hz_data);
    if ( !p00->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p00, p01, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p00, p10, hz, t, hz_data);
      // MINUS integrate triangle
      integrate_triangle (f, sp, p00, pu, pv, sim, hz, t, hz_data, -1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
    if ( !p01->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p00, p01, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p01, p11, hz, t, hz_data);
      integrate_triangle (f, sp, p01, pu, pv, sim, hz, t, hz_data, -1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
    if ( !p10->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p10, p11, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p00, p10, hz, t, hz_data);
      integrate_triangle (f, sp, p10, pu, pv, sim, hz, t, hz_data, -1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
    if ( !p11->is_wet ) {
      CornerPoint * pu = intersection_u (sp, sim->hull, p10, p11, hz, t, hz_data);
      CornerPoint * pv = intersection_v (sp, sim->hull, p01, p11, hz, t, hz_data);
      integrate_triangle (f, sp, p11, pu, pv, sim, hz, t, hz_data, -1.);
      corner_point_destroy (pu);
      corner_point_destroy (pv);
      return;
    }
  }
  g_assert_not_reached ();
}

gboolean sppanel_is_wet (CornerPoint * p00, CornerPoint * p01,
			  CornerPoint * p10, CornerPoint * p11,
			  gboolean * intersect)
{
  *intersect = FALSE;

  if ( (p00->is_wet || p01->is_wet || p10->is_wet || p11->is_wet) ) {
    if ( !(p00->is_wet && p01->is_wet && p10->is_wet && p11->is_wet)) {
      * intersect = TRUE;
    }
    return TRUE;
  }

  return FALSE;
}

gboolean pressure_force_integration_tolerance (CornerPoint * p00,
					       CornerPoint * p10,
					       CornerPoint * p11,
					       CornerPoint * p01,
					       gpointer data)
{
  gdouble tolerance = 1.e-2/* 1.e-3 */;

  if ( MAX(fabs(p11->u-p00->u), fabs(p11->v-p00->v)) < tolerance)
    return TRUE;

  return FALSE;
}

static void adaptive_below_curve_integral (gpointer int_data,
					   Spline2D * sp,
					   CornerPoint * p00, CornerPoint * p10,
					   CornerPoint * p01, CornerPoint * p11,
					   ToleranceIntegrationFunc tol_func,
					   LocalIntegrationFunc local_int_func,
					   CornerPointNewFunc corner_point_new_func,
					   Simulation * sim,
					   HeightCurve hz, gdouble t,
					   gpointer hz_data)
{
  gboolean intersect = TRUE;

  if (! sppanel_is_wet (p00, p01, p10, p11, &intersect)) { // If dry return 0.
    return;
  }

  if ( !intersect ) {// If fully wet return integral
    sub_sppanel_integral (int_data, sp, p00->u, p11->u, p00->v, p11->v, sim, local_int_func, hz, t, hz_data);
    return;
  }

  if ( tol_func (p00, p10, p11, p01, NULL)) {

    CornerPoint * pmm = corner_point_new_func (sp, sim->hull, (p00->u + p11->u)/2.,
					       (p00->v + p11->v)/2., hz, t, hz_data);

    if (pmm->is_wet) // If center if wet, we consider the whole panel as wet
      sub_sppanel_integral (int_data, sp, p00->u, p11->u, p00->v, p11->v, sim, local_int_func, hz, t, hz_data);

    corner_point_destroy (pmm);
					      
    return;
  }

  gdouble um = (p00->u + p11->u)/2.;
  gdouble vm = (p00->v + p11->v)/2.;

  CornerPoint * pmm = corner_point_new_func (sp, sim->hull, um, vm, hz, t, hz_data);
  CornerPoint * p0m = corner_point_new_func (sp, sim->hull, p00->u, vm, hz, t, hz_data);
  CornerPoint * p1m = corner_point_new_func (sp, sim->hull, p11->u, vm, hz, t, hz_data);
  CornerPoint * pm0 = corner_point_new_func (sp, sim->hull, um, p00->v, hz, t, hz_data);
  CornerPoint * pm1 = corner_point_new_func (sp, sim->hull, um, p11->v, hz, t, hz_data);

  adaptive_below_curve_integral (int_data, sp, p00, pm0, p0m, pmm, tol_func, local_int_func,
				 corner_point_new_func, sim, hz, t, hz_data);
  adaptive_below_curve_integral (int_data, sp, pm0, p10, pmm, p1m, tol_func, local_int_func,
				 corner_point_new_func, sim, hz, t, hz_data);
  adaptive_below_curve_integral (int_data, sp, p0m, pmm, p01, pm1, tol_func, local_int_func,
				 corner_point_new_func, sim, hz, t, hz_data);
  adaptive_below_curve_integral (int_data, sp, pmm, p1m, pm1, p11, tol_func, local_int_func,
				 corner_point_new_func, sim, hz, t, hz_data);

  corner_point_destroy (pmm);
  corner_point_destroy (p0m);
  corner_point_destroy (p1m);
  corner_point_destroy (pm0);
  corner_point_destroy (pm1);
}

/**
 * General integration routine for surface integrals below an analytic free-surface.
 * The results of the integration can be stored in the structure passed as the pointer
 * data. Three methods are required.
 * @local_integration_func: The contribution to the integral of a gauss point
 * for one of the subdivided surface.
 * @local_gauss_integration_func: The contribution to the integral of a gauss point
 * of a whole panel calculated used the store GaussPoints data.
 * @tolerance_integration_func: The criteria were adaptive refining stops
 **/
static void wet_hull_integration (Hull * hull, Simulation * sim, gpointer int_data,
				  LocalIntegrationFunc local_integration_func,
				  LocalGaussIntegrationFunc local_gauss_integration_func,
				  ToleranceIntegrationFunc tolerance_integration_func,
				  CornerPointNewFunc corner_point_new_func,
				  HeightCurve hz, gdouble t,
				  gpointer hz_data)
{
  if (sim->verbose)
    g_test_timer_start ();
  gint ii;
  GSList * patches = hull->patches;
  
  // Loop over all the patches of the hull
  while (patches) {
    Spline2D * sp = patches->data;

    while (sp) {
      // Loop over the panels of the patch
      for ( ii = 0; ii < sp->M*sp->N; ii++ ) {
	SPPanel * spp = g_ptr_array_index (sp->panels, ii);
	gboolean intersect;

	CornerPoint * p00 = corner_point_new_func (sp, hull, spp->u0, spp->v0, hz, t, hz_data);
	CornerPoint * p01 = corner_point_new_func (sp, hull, spp->u0, spp->v1, hz, t, hz_data);
	CornerPoint * p10 = corner_point_new_func (sp, hull, spp->u1, spp->v0, hz, t, hz_data);
	CornerPoint * p11 = corner_point_new_func (sp, hull, spp->u1, spp->v1, hz, t, hz_data);
      
	if (sppanel_is_wet (p00, p01, p10, p11, &intersect)) {

	  if ( !intersect ) // Panel is fully wet
	    sppanel_integral_gauss (spp, sim, int_data,
	  			    local_gauss_integration_func,
	  			    hz, t, hz_data);
	  else if (intersect) {// Panel is partially wet
	    adaptive_below_curve_integral (int_data, spp->sp,
	  				   p00, p10, p01, p11,
	  				   tolerance_integration_func,
	  				   local_integration_func,
					   corner_point_new_func,
	  				   sim, hz, t, hz_data);
	  }
	}

	corner_point_destroy (p00);
	corner_point_destroy (p01);
	corner_point_destroy (p10);
	corner_point_destroy (p11);

      }
      sp = sp->next;
    }
    patches = patches->next;
  }

  if (sim->verbose)
    fprintf (stderr, "   Wet_hull_pressure_force_integration : %f \n", g_test_timer_elapsed());
}

static void whole_hull_integration (Hull * hull, Simulation * sim, gpointer int_data,
				    LocalGaussIntegrationFunc local_gauss_integration_func,
				    HeightCurve hz, gdouble t,
				    gpointer hz_data)
{
  if (sim->verbose)
    g_test_timer_start ();
  gint ii;
  GSList * patches = hull->wet_patches;
  
  // Loop over all the patches of the hull
  while (patches) {
    Spline2D * sp = patches->data;

    while (sp) {
      // Loop over the panels of the patch
      for ( ii = 0; ii < sp->M*sp->N; ii++ ) {
	SPPanel * spp = g_ptr_array_index (sp->panels, ii);

	sppanel_integral_gauss (spp, sim, int_data,
	  			    local_gauss_integration_func,
	  			    hz, t, hz_data);
      }
      sp = sp->next;
    }
    patches = patches->next;
  }

  if (sim->verbose)
    fprintf (stderr, "   Whole_hull_pressure_force_integration : %f \n", g_test_timer_elapsed());
}

Forces * wet_hull_pressure_force_integration (Hull * hull,
					      Simulation * sim,
					      HeightCurve hz, gdouble t,
					      gpointer hz_data)
{
  Forces * forces = g_malloc (sizeof(Forces));

  forces_set_to_zero (forces);

  wet_hull_integration (hull, sim, forces,
			local_pressure_forces_contribution,
			sppanel_pressure_force_integral_gauss,
			pressure_force_integration_tolerance,
			corner_point_new,
			hz, t, hz_data);

  return forces;
}

static void add_pressure_forces (Simulation * sim, Forces * f, gdouble t, gdouble u[6], gdouble x[6])
{
  wet_hull_integration (sim->hull, sim, f,
			local_pressure_forces_contribution,
			sppanel_pressure_force_integral_gauss,
			pressure_force_integration_tolerance,
			corner_point_new,
			sim->wp.wave_elevation, t, &sim->wp);
}

void add_hydrostatic_restoring_force_1 (Simulation * sim,
					Forces * f,
					gdouble t,
					Motion m,
					gboolean prediction)
{
  gint i, j;

  for ( i = 0; i < 6; i++ )
    f->forces_h1[i] = 0.;


  for ( i = 0; i < 6; i++) {
    for ( j = 0; j < 6; j++) {
      f->forces_h1[i] -= sim->hull->R[i][j]*m.x1[j];
    }
  }

}

void add_hydrostatic_restoring_forces (Simulation * sim, Forces * f, gdouble t, gdouble u[6], gdouble x[6])
{
  gint i, j;
  for ( i = 0; i < 6; i++)
    f->forces_h[i] = 0.;

  for ( i = 0; i < 6; i++) {
    for ( j = 0; j < 6; j++) {
      f->forces_h[i] -= sim->hull->R[i][j]*x[j];
    }
  }
}

static void local_fh_fk_forces_contribution (Spline2D * sp,
					     Simulation * sim,
					     gpointer data,
					     gdouble u, gdouble v,
					     gdouble weight, 
					     HeightCurve hz,
					     gdouble t,
					     gpointer hz_data)
{
  //Forces * f = (Forces *) data;
  gdouble * f = (gdouble *) data;
  gdouble Ph = 0., Pfk = 0.;
  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  /* gdouble v5n = 0., v3n = 0., v7n = 0.; */
  /* gdouble d5u = 0., d3u = 0., d7u = 0.; */
  /* gdouble d5v = 0., d3v = 0., d7v = 0.; */
  /* Vector gradphi, gradPhi, gradPhi2; */

  /* gdouble var5 = 0., var7 = 0., var11 = 0., var12 = 0., var23 = 0.; */

  gint  i, j;
  size_t /* istart, */ iend, jstart, jend, istart_x;
  /* gsl_matrix * Bu = gsl_matrix_alloc (k, 2); */
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  /* gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bu, &istart, &iend, sp->w_u, sp->wd_u); */
  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */v/* ) */, 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */u/* ) */, 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  /* if (sp->periodic) */
  /*   istart -= sp->k-1; */

  for ( i = 0; i < k; i++) {
    /* gdouble cu = gsl_matrix_get (Bu, i, 0); */
    /* gdouble cdu = gsl_matrix_get (Bu, i, 1); */
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    /* gint ii = istart; */
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      /* gdouble cudv = cu*cdv; */
      /* gdouble cvdu = cv*cdu; */
      /* gdouble cuv = cu*cv; */
      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
      /* gdouble v3 = coeff (sp,ii,jj,3); */
      /* gdouble v5 = coeff (sp,ii,jj,5); */
      /* gdouble v7 = coeff (sp,ii,jj,7); */

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;

      /* d3u += v3*cvdu; */
      /* d3v += v3*cudv; */
      /* v3n += coeff (sp,ii,jj,4)*cuv; */

      /* d5u += v5*cvdu; */
      /* d5v += v5*cudv; */
      /* v5n += coeff (sp,ii,jj,6)*cuv; */

      /* d7u += v7*cvdu; */
      /* d7v += v7*cudv; */
      /* v7n += coeff (sp,ii,jj,8)*cuv; */

      /* var5 += v5*cuv; */
      /* var7 += v7*cuv; */
      /* var11 += coeff (sp,ii,jj,11)*cuv; */
      /* var12 += coeff (sp,ii,jj,12)*cuv; */
      /* var23 += coeff (sp,ii,jj,23)*cuv; */
    }
    /* istart++; */
    istart_x++;
  }

 // Position in inertial reference frame
 Point p_inertial = hull_transformed_point (sim->hull, p);
 
 /* gsl_matrix_free (Bu); */
 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.x /= J; N.y /= J; N.z /= J;



 Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  
 gdouble dt = sim->time.dt;

 gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);






 /* Hydrostatic pressure */
 Ph = -sim->rho*sim->g*(p_inertial.z-hz(p_inertial.x, p_inertial.y, t, hz_data));
 /* Ph = 1.; */
 J *= weight;

 /* Froude Krylov-Forces */
 Pfk = -sim->rho*dtphi0;

 /* Forces */
 /* forces_add_contribution_forces (f, &N, 0., 0., Ph*J, Pfk*J, 0.); */

 gdouble wh = J*Ph;
 gdouble wfk = J*Pfk;

 *(f + 0) += wh*N.x;
 *(f + 1) += wh*N.y;
 *(f + 2) += wh*N.z;
 *(f + 3) += wfk*N.x;
 *(f + 4) += wfk*N.y;
 *(f + 5) += wfk*N.z;
    
 /* Moments */
 Vector x;
 Point xg = sim->hull->xg;
 x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z;
 x = vector_vector_product (&x, &N);

 *(f + 6) += wh*x.x;
 *(f + 7) += wh*x.y;
 *(f + 8) += wh*x.z;
 *(f + 9) += wfk*x.x;
 *(f + 10) += wfk*x.y;
 *(f + 11) += wfk*x.z;

}

static Vector local_fh_fk_gauss (SPPanel * spp, gint m, gint n, Simulation * sim,
				      HeightCurve hz, gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Spline2D * sp = spp->sp;
  Vector pressure;
  Vector force;

  gdouble dt = sim->time.dt;
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  /* Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t); */

  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  /* /\** This can still probably be improved **\/ */
  /* gint  i, j, k = sp->k, ii, jj, iix, jjx; */
  /* gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m); */
  /* gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n); */
  /* gsl_matrix * Bux = g_ptr_array_index (gp->Bux, m); */
  /* gint ustart_x = gp->istart_x; */
  /* gint ustart = sp->periodic ? gp->istart - sp->k + 1: gp->istart; */
  /* gint vstart = gp->jstart; */

  /* gdouble phin = 0., Phin = 0., Phi2n = 0., dtPhi = 0.; */
  /* gdouble phi = 0., old_phi = 0., Phi2 = 0., old_Phi2 = 0.; */
  /* gdouble dphidu = 0., dPhidu = 0., dPhi2du = 0.; */
  /* gdouble dphidv = 0., dPhidv = 0., dPhi2dv = 0.; */
  /* Vector xu, xv; */
  /* xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.; */

  /* for ( i = 0; i < k; i++) { */
  /*   gdouble cu = gsl_matrix_get (Bu, i, 0); */
  /*   gdouble cdu = gsl_matrix_get (Bu, i, 1); */
  /*   gdouble cux = gsl_matrix_get (Bux, i, 0); */
  /*   gdouble cdux = gsl_matrix_get (Bux, i, 1); */
  /*   ii = (ustart+i); */
  /*   iix = (ustart_x+i); */
  /*   for ( j = 0; j < k; j++) { */
  /*     gdouble cv = gsl_matrix_get (Bv, j, 0); */
  /*     gdouble cdv = gsl_matrix_get (Bv, j, 1); */
  /*     gdouble cuv = cu*cv; */
  /*     gdouble cudv = cu*cdv; */
  /*     gdouble cvdu = cv*cdu; */
  /*     gdouble cuvx = cux*cv; */
  /*     gdouble cudvx = cux*cdv; */
  /*     gdouble cvdux = cv*cdux; */
  /*     jj = (vstart+j); */
  /*     xu.x += coeff (sp,iix,jj, 0)*cvdux; */
  /*     xu.y += coeff (sp,iix,jj, 1)*cvdux; */
  /*     xu.z += coeff (sp,iix,jj, 2)*cvdux; */
  /*     xv.x += coeff (sp,iix,jj, 0)*cudvx; */
  /*     xv.y += coeff (sp,iix,jj, 1)*cudvx; */
  /*     xv.z += coeff (sp,iix,jj, 2)*cudvx; */
  /*     dphidu += coeff (sp,ii,jj, 5)*cvdu; */
  /*     dphidv += coeff (sp,ii,jj, 5)*cudv; */
  /*     phin += coeff (sp,ii,jj, 6)*cuv; */
  /*     dPhidu += coeff (sp,ii,jj, 3)*cvdu; */
  /*     dPhidv += coeff (sp,ii,jj, 3)*cudv; */
  /*     Phin += coeff (sp,ii,jj, 4)*cuv; */
  /*     dPhi2du += coeff (sp,ii,jj, 7)*cvdu; */
  /*     dPhi2dv += coeff (sp,ii,jj, 7)*cudv; */
  /*     Phi2n += coeff (sp,ii,jj, 8)*cuv; */
  /*     dtPhi += coeff (sp,ii,jj, 11)*cuv; */
  /*     phi += coeff (sp,ii,jj, 5)*cuv; */
  /*     old_phi += coeff (sp,ii,jj, 12)*cuv; */
  /*     Phi2 += coeff (sp,ii,jj, 7)*cuv; */
  /*     old_Phi2 += coeff (sp,ii,jj, 23)*cuv; */
  /*   } */
  /* } */
   
  /* /\* Inverse Lame coefficients squared *\/ */
  /* gdouble h1_2 = 1./(xu.x*xu.x + xu.y*xu.y + xu.z*xu.z); */
  /* gdouble h2_2 = 1./(xv.x*xv.x + xv.y*xv.y + xv.z*xv.z); */

  /* Vector gradphi; */
  /* gradphi.x = phin*N.x + h1_2*dphidu*xu.x + h2_2*dphidv*xv.x; */
  /* gradphi.y = phin*N.y + h1_2*dphidu*xu.y + h2_2*dphidv*xv.y; */
  /* gradphi.z = phin*N.z + h1_2*dphidu*xu.z + h2_2*dphidv*xv.z; */

  /* Vector gradPhi; */
  /* gradPhi.x = Phin*N.x + h1_2*dPhidu*xu.x + h2_2*dPhidv*xv.x; */
  /* gradPhi.y = Phin*N.y + h1_2*dPhidu*xu.y + h2_2*dPhidv*xv.y; */
  /* gradPhi.z = Phin*N.z + h1_2*dPhidu*xu.z + h2_2*dPhidv*xv.z; */

  /* Vector gradPhi2; */
  /* gradPhi2.x = Phi2n*N.x + h1_2*dPhi2du*xu.x + h2_2*dPhi2dv*xv.x; */
  /* gradPhi2.y = Phi2n*N.y + h1_2*dPhi2du*xu.y + h2_2*dPhi2dv*xv.y; */
  /* gradPhi2.z = Phi2n*N.z + h1_2*dPhi2du*xu.z + h2_2*dPhi2dv*xv.z; */

  /* gdouble dtphi = (phi-old_phi)/dt; */
  /* gdouble dtPhi2 = (Phi2-old_Phi2)/dt; */

  /* Vector w = sim->U; */
  /* w.x -= gradPhi.x; w.y -= gradPhi.y; w.z -= gradPhi.z; */

  /* /\* Memory flow pressure *\/ */
  /* pressure.Pm = -sim->rho*(dtPhi - vector_scalar_product (&w, &gradPhi) */
  /* 			  -0.5*vector_scalar_product (&gradPhi, &gradPhi)); */

  /* w.x -= gradphi0.x; w.y -= gradphi0.y; w.z -= gradphi0.z; */

  /* pressure.Pm -= sim->rho*(- vector_scalar_product (&w, &gradphi0) */
  /* 		  -0.5*vector_scalar_product (&gradphi0, &gradphi0)); */

  /* w.x -= gradphi.x; w.y -= gradphi.y; w.z -= gradphi.z; */

  /* pressure.Pm -= sim->rho*(dtPhi2 - vector_scalar_product (&w, &gradPhi2)); */
  
  /* /\* Local flow pressure *\/ */
  /* pressure.Pl =  -sim->rho*(dtphi - vector_scalar_product (&w, &gradphi) */
  /* 			    -0.5*vector_scalar_product (&gradphi, &gradphi)); */

  /* Hydrostatic pressure */
  /* pressure.Ph */pressure.x = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data));
  // pressure.Ph = 1.;

  /* Non-linear Froude-Krylov forces */
  /* pressure.Pfk  */pressure.y = -sim->rho*dtphi0;

  /* /\* Non-linear restoring forces *\/ */
  /* pressure.Pr = 0.; */

  return pressure;
}

static void sppanel_fh_fk_forces_integral_gauss (SPPanel * spp,
						 Simulation * sim,
						 gpointer data,
						 gint m, gint n,
						 HeightCurve hz,
						 gdouble t,
						 gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Vector lp = local_fh_fk_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.x;
  gdouble wfk = wij*lp.y;

  *(f + 0) += wh*N.x;
  *(f + 1) += wh*N.y;
  *(f + 2) += wh*N.z;
  *(f + 3) += wfk*N.x;
  *(f + 4) += wfk*N.y;
  *(f + 5) += wfk*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  *(f + 6) += wh*x.x;
  *(f + 7) += wh*x.y;
  *(f + 8) += wh*x.z;
  *(f + 9) += wfk*x.x;
  *(f + 10) += wfk*x.y;
  *(f + 11) += wfk*x.z;
}

static void add_fh_fk_forces (Simulation * sim, Forces * f, gdouble t
			      , gdouble u[6], gdouble x[6])
{
  /* gdouble ff[12]; */
  gint i;
  /* for ( i = 0; i < 12; i++) */
  /*   ff[i] = 0.; */

  /* wet_hull_integration (sim->hull, sim, &ff[0], */
  /* 			local_fh_fk_forces_contribution, */
  /* 			sppanel_fh_fk_forces_integral_gauss, */
  /* 			pressure_force_integration_tolerance, */
  /* 			corner_point_new, */
  /* 			sim->wp.wave_elevation, t, &sim->wp); */

  //gdouble ramp = (1.-exp(-t/40.));

  /* f->forces_h[0] += ff[0]; */
  /* f->forces_h[1] += ff[1]; */
  /* f->forces_h[2] += ff[2]; */

  /* f->forces_fk[0] += ff[3]; */
  /* f->forces_fk[1] += ff[4]; */
  /* f->forces_fk[2] += ff[5]; */


  /* f->forces_h[3] += ff[6]; */
  /* f->forces_h[4] += ff[7]; */
  /* f->forces_h[5] += ff[8]; */

  /* f->forces_fk[3] += ff[9]; */
  /* f->forces_fk[4] += ff[10]; */
  /* f->forces_fk[5] += ff[11]; */
  gint j;
  for ( i = 0; i < 6; i++ ) {
    for (  j = 0; j < 6; j++ ) {
      f->forces_h[i] += sim->hull->R[i][j]*x[j];
    }
  }

  /* f->forces_h[0] += ff[0]; */
  /* f->forces_h[1] += ff[1]; */
  /* f->forces_h[2] += ff[2]; */

  /* f->forces_h[3] += ff[6]; */
  /* f->forces_h[4] += ff[7]; */
  /* f->forces_h[5] += ff[8]; */

}

static void add_fh_forces (Simulation * sim, Forces * f, gdouble t
			      , gdouble u[6], gdouble x[6])
{
  gdouble ff[12];
  gint i;
  for ( i = 0; i < 12; i++)
    ff[i] = 0.;

  wet_hull_integration (sim->hull, sim, &ff[0],
			local_fh_fk_forces_contribution,
			sppanel_fh_fk_forces_integral_gauss,
			pressure_force_integration_tolerance,
			corner_point_new,
			sim->wp.wave_elevation, t, &sim->wp);

  f->forces_h[0] += ff[0];
  f->forces_h[1] += ff[1];
  f->forces_h[2] += ff[2];

  f->forces_h[3] += ff[6];
  f->forces_h[4] += ff[7];
  f->forces_h[5] += ff[8];

}

static void add_fk_forces (Simulation * sim, Forces * f, gdouble t,
			   gdouble u[6], gdouble x[6])
{
  gdouble ff[12];
  gint i;
  for ( i = 0; i < 12; i++)
    ff[i] = 0.;

  wet_hull_integration (sim->hull, sim, &ff[0],
			local_fh_fk_forces_contribution,
			sppanel_fh_fk_forces_integral_gauss,
			pressure_force_integration_tolerance,
			corner_point_new,
			sim->wp.wave_elevation, t, &sim->wp);

  f->forces_fk[0] += ff[3];
  f->forces_fk[1] += ff[4];
  f->forces_fk[2] += ff[5];

  f->forces_fk[3] += ff[9];
  f->forces_fk[4] += ff[10];
  f->forces_fk[5] += ff[11];
}

/*************************************************************************************/

static Vector local_fh_fk_uv_gauss (SPPanel * spp, gint m, gint n, Simulation * sim,
				    HeightCurve hz, gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  //gint ng = spp->sp->nouter;
  Spline2D * sp = spp->sp;
  Vector pressure;
  //Vector force;

  //gdouble dt = sim->time.dt;
  //Vector N = g_array_index (gp->Ni, Vector, m + n*ng);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  /* Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t); */

  //gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  gdouble dtphi0 = spline2d_eval_gauss_point (sp, gp, m, n, 30);

  gdouble elevation = spline2d_eval_gauss_point (sp, gp, m, n, 31);

  /* Hydrostatic pressure */
  pressure.x = -sim->rho*sim->g *( p_inertial.z - elevation);

  /* Non-linear Froude-Krylov forces */
  pressure.y = -sim->rho*dtphi0;

  return pressure;
}

static void sppanel_fh_fk_uv_forces_integral_gauss (SPPanel * spp,
						    Simulation * sim,
						    gpointer data,
						    gint m, gint n,
						    HeightCurve hz,
						    gdouble t,
						    gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Vector lp = local_fh_fk_uv_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.x;
  gdouble wfk = wij*lp.y;

  *(f + 0) += wh*N.x;
  *(f + 1) += wh*N.y;
  *(f + 2) += wh*N.z;
  *(f + 3) += wfk*N.x;
  *(f + 4) += wfk*N.y;
  *(f + 5) += wfk*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  *(f + 6) += wh*x.x;
  *(f + 7) += wh*x.y;
  *(f + 8) += wh*x.z;
  *(f + 9) += wfk*x.x;
  *(f + 10) += wfk*x.y;
  *(f + 11) += wfk*x.z;
}

static void local_fh_fk_uv_forces_contribution (Spline2D * sp,
						Simulation * sim,
						gpointer data,
						gdouble u, gdouble v,
						gdouble weight, 
						HeightCurve hz,
						gdouble t,
						gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  gdouble Ph = 0., Pfk = 0.;
  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  gdouble dtphi0 = 0., elevation = 0.;

  gint  i, j;
  size_t istart, iend, jstart, jend, istart_x;
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */v/* ) */, 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */u/* ) */, 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  /* if (sp->periodic) */
  /*   istart -= sp->k-1; */

  for ( i = 0; i < k; i++) {
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    /* gint ii = istart; */
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      /* gdouble cudv = cu*cdv; */

      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
      /* gdouble v3 = coeff (sp,ii,jj,3); */
      /* gdouble v5 = coeff (sp,ii,jj,5); */
      /* gdouble v7 = coeff (sp,ii,jj,7); */

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;

      dtphi0 += coeff (sp,iix,jj,30)*cuvx;
      elevation += coeff (sp,iix,jj,31)*cuvx;
    }
    //istart++;
    istart_x++;
  }

 // Position in inertial reference frame
 Point p_inertial = hull_transformed_point (sim->hull, p);
 
 /* gsl_matrix_free (Bu); */
 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.x /= J; N.y /= J; N.z /= J;



 /* Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t); */
  
 gdouble dt = sim->time.dt;

 /* gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t); */




 /* Hydrostatic pressure */
 /* Ph = -sim->rho*sim->g*(p_inertial.z-hz(p_inertial.x, p_inertial.y, t, hz_data)); */
 Ph = -sim->rho*sim->g*(p_inertial.z-elevation);
 /* Ph = 1.; */
 J *= weight;

 /* Froude Krylov-Forces */
 Pfk = -sim->rho*dtphi0;

 /* Forces */
 /* forces_add_contribution_forces (f, &N, 0., 0., Ph*J, Pfk*J, 0.); */

 gdouble wh = J*Ph;
 gdouble wfk = J*Pfk;

 *(f + 0) += wh*N.x;
 *(f + 1) += wh*N.y;
 *(f + 2) += wh*N.z;
 *(f + 3) += wfk*N.x;
 *(f + 4) += wfk*N.y;
 *(f + 5) += wfk*N.z;
    
 /* Moments */
 Vector x;
 Point xg = sim->hull->xg;
 x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z;
 x = vector_vector_product (&x, &N);

 *(f + 6) += wh*x.x;
 *(f + 7) += wh*x.y;
 *(f + 8) += wh*x.z;
 *(f + 9) += wfk*x.x;
 *(f + 10) += wfk*x.y;
 *(f + 11) += wfk*x.z;

}

gdouble uv_elevation (gdouble x, gdouble y, gdouble t, gpointer data)
{
  Spline2D * sp = (Spline2D *) data;

  return spline2d_eval (sp, x, y, 31);
}

static void add_fh_fk_uv_forces (Simulation * sim, Forces * f, gdouble t,
				 gdouble u[6], gdouble x[6])
{
  gdouble ff[12];
  gint i;
  for ( i = 0; i < 12; i++)
    ff[i] = 0.;
  
  wet_hull_integration (sim->hull, sim, &ff[0],
  			local_fh_fk_uv_forces_contribution,
  			sppanel_fh_fk_uv_forces_integral_gauss,
  			pressure_force_integration_tolerance,
  			corner_point_new_uv,
  			uv_elevation, t, &sim->wp);

  gdouble ramp = (1-exp(-t/40.));

  f->forces_h[0] += ff[0];
  f->forces_h[1] += ff[1];
  f->forces_h[2] += ff[2];

  f->forces_fk[0] += ff[3]*ramp;
  f->forces_fk[1] += ff[4]*ramp;
  f->forces_fk[2] += ff[5]*ramp;


  f->forces_h[3] += ff[6];
  f->forces_h[4] += ff[7];
  f->forces_h[5] += ff[8];

  f->forces_fk[3] += ff[9]*ramp;
  f->forces_fk[4] += ff[10]*ramp;
  f->forces_fk[5] += ff[11]*ramp;
}



/*************************************************************************************/

gdouble flat_sea (gdouble x, gdouble y, gdouble t, gpointer data)
{
  WaveParams * wp = (WaveParams *) data;

  return 1.e-11;
}

static void local_cob_contribution (Spline2D * sp,
				    Simulation * sim,
				    gpointer data,
				    gdouble u, gdouble v,
				    gdouble weight, 
				    HeightCurve hz,
				    gdouble t,
				    gpointer hz_data)
{
  Point * cob = (Point *) data;

  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;

  gint  i, j;
  size_t jstart, jend, istart_x, iend;
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,v), 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  for ( i = 0; i < k; i++) {
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);

      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
 

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;
    }
    istart_x++;
  }

 // Position in inertial reference frame
 Point p_inertial = hull_transformed_point (sim->hull, p);

 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.x /= J; N.y /= J; N.z /= J;

 
 cob->x += weight*J*N.x*p_inertial.x*p_inertial.x;
 cob->y += weight*J*N.y*p_inertial.y*p_inertial.y;
 cob->z += weight*J*N.z*p_inertial.z*p_inertial.z;
}

static void gauss_cob_contribution (SPPanel * spp,
				    Simulation * sim,
				    gpointer data,
				    gint m, gint n,
				    HeightCurve hz,
				    gdouble t,
				    gpointer hz_data)
{
  Point * cob = (Point *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);
  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  Point p_inertial = hull_transformed_point (sim->hull, p);

  cob->x += wij*N.x*p_inertial.x*p_inertial.x;
  cob->y += wij*N.y*p_inertial.y*p_inertial.y;
  cob->z += wij*N.z*p_inertial.z*p_inertial.z;
}

gboolean cob_tolerance (CornerPoint * p00,
			CornerPoint * p10,
			CornerPoint * p11,
			CornerPoint * p01,
			gpointer data)
{
  gdouble tolerance = 1.e-3;

  if ( MAX(fabs(p11->u-p00->u), fabs(p11->v-p00->v)) < tolerance)
    return TRUE;

  return FALSE;
}

Point find_center_of_buoyancy (Hull * hull,
			       Simulation * sim,
			       HeightCurve hz, gdouble t,
			       gpointer hz_data)
{
  Point cob;
  cob.x = cob.y = cob.z = 0.;
  
  /* wet_hull_integration (hull, sim, &cob, */
  /* 			local_cob_contribution, */
  /* 			gauss_cob_contribution, */
  /* 			cob_tolerance, */
  /* 			corner_point_new, */
  /* 			hz, t, hz_data); */

  whole_hull_integration (hull, sim, &cob,
			  gauss_cob_contribution,
			  hz, t, hz_data);

  gdouble hull_volume = hull->mg/sim->rho;

  cob.x /= -2.*hull_volume;
  cob.y /= -2.*hull_volume;
  cob.z /= -2.*hull_volume;

  fprintf (stderr, "Center of Buoyancy: %e %e %e \n", cob.x, cob.y, cob.z);

  return cob;
}

static void local_hrc_contribution (Spline2D * sp,
				    Simulation * sim,
				    gpointer data,
				    gdouble u, gdouble v,
				    gdouble weight, 
				    HeightCurve hz,
				    gdouble t,
				    gpointer hz_data)
{
  gdouble * hrc = (gdouble *) data;

  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;

  gint  i, j;
  size_t jstart, jend, istart_x, iend;
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,v), 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  for ( i = 0; i < k; i++) {
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);

      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
 

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;
    }
    istart_x++;
  }

 // Position in inertial reference frame
 Point p_inertial = hull_transformed_point (sim->hull, p);

 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.z /= J;

 gdouble wij = weight*J*N.z;

 *( hrc + 2*6 + 2) += wij;
 *( hrc + 2*6 + 3) += p_inertial.y*wij;
 *( hrc + 2*6 + 4) += -p_inertial.x*wij;
 
 *( hrc + 3*6 + 3) += p_inertial.y*p_inertial.y*wij;
 *( hrc + 3*6 + 4) += p_inertial.x*p_inertial.y*wij;
 
 *( hrc + 4*6 + 4) += p_inertial.x*p_inertial.x*wij;
}

static void gauss_hrc_contribution (SPPanel * spp,
				    Simulation * sim,
				    gpointer data,
				    gint m, gint n,
				    HeightCurve hz,
				    gdouble t,
				    gpointer hz_data)
{
  gdouble * hrc = (gdouble *) data;

  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);
  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  // Position in inertial reference frame
  Point p_inertial = hull_transformed_point (sim->hull, p);

  p_inertial.x -= sim->hull->xg.x;
  p_inertial.y -= sim->hull->xg.y;
  p_inertial.z -= sim->hull->xg.z;

  //  g_assert_not_reached ();

  *( hrc + 2*6 + 2) +=   wij*N.z;
  *( hrc + 2*6 + 3) +=   p_inertial.y*wij*N.z;
  *( hrc + 2*6 + 4) +=   -p_inertial.x*wij*N.z;

  *( hrc + 3*6 + 3) +=   p_inertial.y*p_inertial.y*wij*N.z;
  *( hrc + 3*6 + 4) +=   -p_inertial.x*p_inertial.y*wij*N.z;
  
  *( hrc + 4*6 + 4) +=   p_inertial.x*p_inertial.x*wij*N.z;
}

gboolean hrc_tolerance (CornerPoint * p00,
			CornerPoint * p10,
			CornerPoint * p11,
			CornerPoint * p01,
			gpointer data)
{
  gdouble tolerance = 1.e-3;

  if ( MAX(fabs(p11->u-p00->u), fabs(p11->v-p00->v)) < tolerance)
    return TRUE;

  return FALSE;
}

void calculate_hydrostatic_restoring_coeffs (Hull * hull,
					     Simulation * sim,
					     HeightCurve hz, gdouble t,
					     gpointer hz_data)
{
  // Set to zero
  gint i, j;
  for ( i = 0; i < 6; i++) {
    for ( j = 0; j < 6; j++) {
      hull->R[i][j] = 0.;
    }
  }
 
  Point cob = find_center_of_buoyancy (sim->hull, sim, flat_sea, sim->time.t, NULL);
  sim->hull->xg.x = cob.x;

  /* wet_hull_integration (hull, sim, &hull->R[0][0], */
  /* 			local_hrc_contribution, */
  /* 			gauss_hrc_contribution, */
  /* 			hrc_tolerance, */
  /* 			corner_point_new, */
  /* 			hz, t, hz_data); */

  whole_hull_integration (hull, sim, &hull->R[0][0],
			  gauss_hrc_contribution,
			  hz, t, hz_data);

  gdouble mg = hull->mg*sim->g;
  gdouble rhog = sim->rho*sim->g;
  

  fprintf (stderr, "xg %e %e %e \n", sim->hull->xg.x, sim->hull->xg.y, sim->hull->xg.z);

  hull->R[2][2] *= rhog;
  hull->R[3][3] = hull->R[3][3]*rhog - mg*(sim->hull->xg.z - cob.z)/* + mg*(cob.z - sim->hull->xg.z) */;
  hull->R[4][4] = hull->R[4][4]*rhog - mg*(sim->hull->xg.z - cob.z)/* + mg*(cob.z - sim->hull->xg.z) */;
  hull->R[2][4] *= rhog;


  /* hull->R[2][3] *= rhog; */
  /* hull->R[3][4] = hull->R[3][4]*rhog - mg*(cob.x - sim->hull->xg.x); // Should be zero ? */
  /* hull->R[3][5] = -mg*(cob.x - sim->hull->xg.x); //Should be zero ? */
  
  fprintf (stdout, "cob %e %e %e \n", cob.x, cob.y, cob.z);
  /* hull->R[4][5] = -mg*(cob.y - sim->hull->xg.y); // Should be zero ? */

  // Symmetry
  hull->R[3][2] = hull->R[2][3];
  hull->R[4][2] = hull->R[2][4];
  hull->R[4][3] = hull->R[3][4];

  for ( i = 0; i < 6; i++) {
    fprintf (stderr, "C: %e %e %e %e %e %e \n", hull->R[i][0], hull->R[i][1], hull->R[i][2],
  	     hull->R[i][3], hull->R[i][4], hull->R[i][5]);
  }
  //  g_assert_not_reached ();
  // The centre of gravity in the longitudinal directional has the same abscissa as the centre of buoyancy
  
}

/**
 * This works only is the boat is placed at its equilibrium position.
 * i.e. if the waterline at equilibrium for undisturbed sea  conditions
 * is known.
 **/
gdouble calculate_mass_from_position_at_rest (Hull * hull,
					      Simulation * sim)
{
  gdouble mass = 0.;

  gpointer tmp_func = sim->wp.wave_elevation;
  sim->wp.wave_elevation = flat_sea;

  // Calculates the hydrostatic forces given the position of the hull
  // and assuming a flat free-surface. For those the mass of the hull
  // can be derived
  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, sim->wp.wave_elevation, sim->time.t, &sim->wp);

  hull->mg = sqrt(/* f->forces_h[0]*f->forces_h[0] */
		  /* + f->forces_h[1]*f->forces_h[1] */
		  /* +  */f->forces_h[2]*f->forces_h[2])/sim->g;
  
  fprintf (stderr, "Mass of the hull: %e kg \n", hull->mg);

  sim->wp.wave_elevation = tmp_func;
  return mass;
}

/**
 * Solves the equation of motion for the hull using a fourth
 * order Runge-Kutta method. This method is expensive and
 * should only be used for the first 4 time-steps of the simulation
 **/
void rk_hull_motion (Hull * hull, Simulation * sim)
{
  gdouble F0[12], F[12], k1[12], k2[12], k3[12], k4[12], Y0[12], Y[12];
  gint i;

  // k1 = dt*f(t0, y0)
  for ( i = 0; i < 12; i++)
    k1[i] = sim->time.dt*F0[i];

  // k2 = dt*f(t0+dt/2, y0)
  for ( i = 0; i < 12; i++)
    k2[i] = sim->time.dt*F0[i];

  // k3 = dt*f(t0+dt/2, y0+k2/2)


  // k4 = dt*f(t0+dt, y0+k3)
  

  // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6
  for ( i = 0; i < 12; i++)
    Y[i] = Y0[i] + k1[i]/6. + k2[i]/3. + k3[i]/3. + k4[i]/6.;
}

/**
 * Solves the equation of motion for the hull using a fourth
 * order Adam-Bashford-Moulton method. This methods requires
 * 4 time-steps of time history of the hull and can only be
 * used from time-step 4. A fourth order Runge-Kutta method 
 * can be used for earlier time steps.
 **/
void abm_hull_motion (Hull * hull, Simulation * sim)
{
  gint i;

  /* Predictor */
  /* for ( i = 0; i < 12; i++); */

  /* Corrector */
  
}

/**
 * 
 **/
void hull_equation_of_motion (Hull * hull, Simulation * sim)
{
  /* if (sim->Time.itime < 4) */
  /*   rk_hull_motion (hull, sim); */
  /* else */
  /*   abm_hull_motion (hull, sim); */
}

void print_var (Spline2D * sp, gint var)
{
  FILE * fp = fopen ("var.tmp","w");

  gdouble i, j;

  for ( i = 0.; i <= 1.; i += 0.05 )
    for ( j = 0.; j <= 1.; j += 0.05 ) {
      /* Vector g = potential_gradient_on_surface (sp, i, j, 3); */
      /* fprintf (fp, "%f %f %f %f %e \n", i, j, spline2d_eval (sp, i, j, 0), spline2d_eval (sp, i, j, 1), vector_norm(g)); */
      fprintf (fp, "%f %f %f %f %e %e \n", i, j, spline2d_eval (sp, i, j, 0), spline2d_eval (sp, i, j, 1),
	       spline2d_eval (sp, i, j, var), spline2d_eval (sp, i, j, var+1));
    }

  fclose (fp);
}

static gdouble gaussian_shape (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  Point p = spline2d_eval_point (sp, u, v);

  return 0.6*exp(-4*(p.x-3.)*(p.x-3.))*exp(-4.*p.y*p.y);

  return (p.x*cos(2*p.x+p.y));

  return 0.6*exp(-p.x*p.x/* /20. */)*exp(-p.y*p.y/* /5. */);
}

static gdouble gaussian_shape2 (Spline2D * sp, gint m, gint n, gpointer data)
{
  Point p = g_array_index (sp->gr->Pi, Point, m + n*sp->NU);

  return 0.6*exp(-4*(p.x/* -3. */)*(p.x/* -3. */))*exp(-4.*p.y*p.y);

  return (p.x*cos(2*p.x+p.y));

  return 0.6*exp(-p.x*p.x/* /20. */)*exp(-p.y*p.y/* /5. */);
}

static gdouble gaussian_shape3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  return 0.6*exp(-5*(p.x - 2.)*(p.x - 2.))*exp(-5.*p.y*p.y);

  return 0.6*exp(-5*(p.x/* -2.5 */)*(p.x/* -2.5 */))*exp(-5.*p.y*p.y);

  return (p.x*cos(2*p.x+p.y));

  return 0.6*exp(-p.x*p.x/* /20. */)*exp(-p.y*p.y/* /5. */);
}

/* static gdouble numerical_beaches (Spline2D * sp, gdouble u, gdouble v, gpointer data) */
/* { */
/*   Point p = spline2d_eval_point (sp, u, v); */
/*   gdouble Cs = 1.; */

/*   gdouble nu = 0.; */
/*   if ( p.x > 25. && fabs(p.y) > 20 ) { */
/*     gdouble r = sqrt (pow(fabs(p.x-25.), 2.) + pow(fabs(p.y)-20, 2.)); */
/*     return 3./pow(10, 3.)*r*r; */
/*   } */
/*   else if ( p.x > 25 ) */
/*     return 3./pow(10, 3.)*pow(fabs(p.x-25), 2.); */
/*   else if ( fabs(p.y) > 20 ) */
/*     return 3./pow(10, 3.)*pow(fabs(p.y)-20, 2.); */
/*   else */
/*     return 0.; */

  
/*   /\* gdouble nu = 0.; *\/ */
/*   /\* if ( p.x < -25. && fabs(p.y) > 20 ) { *\/ */
/*   /\*   gdouble r = sqrt (pow(fabs(p.x+25), 2.) + pow(fabs(p.y)-20, 2.)); *\/ */
/*   /\*   nu = 3.*Cs/pow(10, 3.)*r*r; *\/ */
/*   /\* } *\/ */
/*   /\* else if ( p.x < -25 ) *\/ */
/*   /\*   nu = 3.*Cs/pow(10, 3.)*pow(fabs(p.x+25), 2.); *\/ */
/*   /\* else if ( fabs(p.y) > 20 ) *\/ */
/*   /\*   nu = 3.*Cs/pow(10, 3.)*pow(fabs(p.y)-20, 2.); *\/ */
/*   /\* else *\/ */
/*   /\*   nu = 0.; *\/ */

/*   return nu; */
/* } */

gdouble sphere_x (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return 0.5*cos(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
  return -0.5*cos(M_PI*v);
  return -1.*cos(M_PI*v);
}

gdouble sphere_y (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return 0.125*sin(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
  return /* 0.125 */0.5*sin(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 1.*sin(2.*M_PI*u)*sin(M_PI*v);
}

gdouble sphere_z (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return /* 1e-8 */ - 0.05*cos(M_PI/2.*(1.-v));
  return 1e-8+0.05*cos(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 0.5*cos(2.*M_PI*u)*sin(M_PI*v);
}

gdouble sphere_xp (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 0.5*cos(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
  return -0.5*cos(M_PI*v);
  return -1.*cos(M_PI*v);
}

gdouble sphere_yp (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 0.125*sin(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
  return /* 0.125 */0.5*sin(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 1.*sin(2.*M_PI*u)*sin(M_PI*v);
}

gdouble sphere_zp (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return /* 1e-8 */ - 0.05*cos(M_PI/2.*(1.-v));
  return 1e-8+0.05*cos(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 0.5*cos(2.*M_PI*u)*sin(M_PI*v);
}

Spline2D * spheroid_surface (gint M, gint N/* , gdouble l1, gdouble l2, gdouble l3 */)
{
  Spline2D * grid =  spline2d_new (N-1, M-1, 3, 4, 3);

  coeff_set_var_to_zero (grid, 0);
  coeff_set_var_to_zero (grid, 1);
  coeff_set_var_to_zero (grid, 2);

  spline2d_init_panels (grid);

  /* if (0) { */
  /*   spline2d_fit_greville (grid, sphere_x, NULL, 0); */
  /*   spline2d_fit_greville (grid, sphere_y, NULL, 1); */
  /*   spline2d_fit_greville (grid, sphere_z, NULL, 2); */
  /* } */
  /* else { */
    spline2d_fit_greville_border (grid, sphere_x, NULL, 0);
    spline2d_fit_greville_border (grid, sphere_y, NULL, 1);
    spline2d_fit_greville_border (grid, sphere_z, NULL, 2);
  /* } */

  spline2d_reinit_panels_physical_quantities (grid);

  return grid;
}

Spline2D * periodic_spheroid_surface (gint M, gint N/* , gdouble l1, gdouble l2, gdouble l3 */)
{
  Spline2D * grid =  periodic_fs_new (N-1, M/* -1 */, 3, 4, 3);

  grid->noflux = FALSE;

  coeff_set_var_to_zero (grid, 0);
  coeff_set_var_to_zero (grid, 1);
  coeff_set_var_to_zero (grid, 2);

  periodic_fs_init_panels (grid);

  CCSProblem * fit = periodic_fs_build_galerkin_fit_matrix_no_metric (grid);

  gsl_vector * rhs_x = periodic_fs_build_galerkin_rhs_gauss_no_metric (grid, sphere_xp, NULL, NULL, NULL);
  gsl_vector * rhs_y = periodic_fs_build_galerkin_rhs_gauss_no_metric (grid, sphere_yp, NULL, NULL, NULL);
  gsl_vector * rhs_z = periodic_fs_build_galerkin_rhs_gauss_no_metric (grid, sphere_zp, NULL, NULL, NULL);
  /* if (0) { */
  /*   spline2d_fit_greville (grid, sphere_x, NULL, 0); */
  /*   spline2d_fit_greville (grid, sphere_y, NULL, 1); */
  /*   spline2d_fit_greville (grid, sphere_z, NULL, 2); */
  /* } */
  /* else { */
    /* spline2d_fit_greville_border (grid, sphere_x, NULL, 0); */
    /* spline2d_fit_greville_border (grid, sphere_y, NULL, 1); */
    /* spline2d_fit_greville_border (grid, sphere_z, NULL, 2); */
  /* } */

  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);

  periodic_fs_copy_problem_solution_no_metric (grid, rhs_x, 0);
  periodic_fs_copy_problem_solution_no_metric (grid, rhs_y, 1);
  periodic_fs_copy_problem_solution_no_metric (grid, rhs_z, 2);

  periodic_fs_reinit_panels_physical_quantities (grid);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  periodic_fs_numbering (grid);

  return grid;
}

Spline2D * standard_spheroid_surface (gint M, gint N)
{
  Spline2D * grid =  spline2d_new (M, N, 3, 4, 3);
  grid->noflux = FALSE;

  coeff_set_var_to_zero (grid, 0);
  coeff_set_var_to_zero (grid, 1);
  coeff_set_var_to_zero (grid, 2);

  spline2d_init_panels (grid);

  CCSProblem * fit = spline2d_build_galerkin_fit_matrix_no_metric (grid);

  gsl_vector * rhs_x = build_galerkin_rhs_gauss_no_metric (grid, sphere_xp, NULL, NULL, NULL);
  gsl_vector * rhs_y = build_galerkin_rhs_gauss_no_metric (grid, sphere_yp, NULL, NULL, NULL);
  gsl_vector * rhs_z = build_galerkin_rhs_gauss_no_metric (grid, sphere_zp, NULL, NULL, NULL);

  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);

  spline2d_copy_problem_solution (grid, rhs_x, 0);
  spline2d_copy_problem_solution (grid, rhs_y, 1);
  spline2d_copy_problem_solution (grid, rhs_z, 2);

  spline2d_reinit_panels_physical_quantities (grid);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  return grid;
}

gdouble c1_x (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return 1.0-2.*v;
}
gdouble c1_y (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return -1.00*cos(2.*M_PI*u);
}
gdouble c1_z (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return -1.00*sin(2.*M_PI*u);
}

gdouble c2_x (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return -1.0;
}
gdouble c2_y (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return 1.00*cos(2.*M_PI*u)*v;
}
gdouble c2_z (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return -1.00*sin(2.*M_PI*u)*v;
}

gdouble c3_x (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return 1.0;
}
gdouble c3_y (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return -1.00*cos(2.*M_PI*u)*v;
}
gdouble c3_z (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  return -1.00*sin(2.*M_PI*u)*v;
}


GSList * cylinder_surface (gint M, gint N/* , gdouble l1, gdouble l2, gdouble l3 */)
{
  GSList * list = NULL;;
  Spline2D * grid =  spline2d_new (N-1, M-1, 3, 3, 3);

  coeff_set_var_to_zero (grid, 0);
  coeff_set_var_to_zero (grid, 1);
  coeff_set_var_to_zero (grid, 2);

  spline2d_init_panels (grid);

  /* if (0) { */
  /*   spline2d_fit_greville (grid, sphere_x, NULL, 0); */
  /*   spline2d_fit_greville (grid, sphere_y, NULL, 1); */
  /*   spline2d_fit_greville (grid, sphere_z, NULL, 2); */
  /* } */
  /* else { */
    spline2d_fit_greville_border (grid, c1_x, NULL, 0);
    spline2d_fit_greville_border (grid, c1_y, NULL, 1);
    spline2d_fit_greville_border (grid, c1_z, NULL, 2);
  /* } */

  spline2d_reinit_panels_physical_quantities (grid);

  list = g_slist_append (list, grid);

  grid = spline2d_new (N-1, M-1, 3, 3, 3);
  coeff_set_var_to_zero (grid, 0);
  coeff_set_var_to_zero (grid, 1);
  coeff_set_var_to_zero (grid, 2);
  spline2d_init_panels (grid);
  spline2d_fit_greville_border (grid, c2_x, NULL, 0);
  spline2d_fit_greville_border (grid, c2_y, NULL, 1);
  spline2d_fit_greville_border (grid, c2_z, NULL, 2);
  spline2d_reinit_panels_physical_quantities (grid);

  list = g_slist_append (list, grid);

  grid = spline2d_new (N-1, M-1, 3, 3, 3);
  coeff_set_var_to_zero (grid, 0);
  coeff_set_var_to_zero (grid, 1);
  coeff_set_var_to_zero (grid, 2);
  spline2d_init_panels (grid);
  spline2d_fit_greville_border (grid, c3_x, NULL, 0);
  spline2d_fit_greville_border (grid, c3_y, NULL, 1);
  spline2d_fit_greville_border (grid, c3_z, NULL, 2);
  spline2d_reinit_panels_physical_quantities (grid);

  list = g_slist_append (list, grid);

  return list;
}

static gdouble circular_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);

  return (1.+/* 1.5 */4.*v) * cos (2. * M_PI * u +  M_PI);
}

static gdouble circular_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);

  return -(1+/* 1.5 */4.*v)*sin(2.*M_PI*u +  M_PI);
}

static gdouble circular_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);

  //return (0.5+1.5*(1-cos(v*M_PI/2)))* cos (2. * M_PI * u +  M_PI/2.);
  //return (0.5+1.5*v)* cos (2. * M_PI * u +  M_PI/4.);
  return (1.+/* 4. /* 1.5 */4.*v) * cos (2. * M_PI * u +  M_PI/2.);
}

static gdouble circular_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  
  //return -(0.0504 + 1.9499*(1-cos(v*M_PI/2)))*sin(2.*M_PI*u +  M_PI/2.);
  //return -(0.0501 + 1.9499*v)*sin(2.*M_PI*u +  M_PI/4.);
  return -(1+/* 4. *//* 1.5 */4.*v)*sin(2.*M_PI*u +  M_PI/2.);
}

static gdouble wild_grid_x (Spline2D * sp, gint m, gint n, gpointer data)
{
  Surface * s = (Surface *) data;
  Boundaries * b = s->b;
  GrevillePoints * gr = sp->gr;
  gdouble u = g_array_index (gr->ui, gdouble, m);
  gdouble v = g_array_index (gr->vj, gdouble, n);

  Point p0 = g_array_index (b->dcb->p, Point, m);

  return p0.x + (-4.5*cos (2. * M_PI * u) - p0.x)*v;
}

static gdouble wild_grid_y (Spline2D * sp, gint m, gint n, gpointer data)
{
  Surface * s = (Surface *) data;
  Boundaries * b = s->b;
  GrevillePoints * gr = sp->gr;
  gdouble u = g_array_index (gr->ui, gdouble, m);
  gdouble v = g_array_index (gr->vj, gdouble, n);

  Point p0 = g_array_index (b->dcb->p, Point, m);
  return p0.y + (4.5*sin (2. * M_PI * u) - p0.y)*v;
}

static gdouble circular_z2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  /* gdouble u = g_array_index (gp->ui, gdouble, m); */
  /* gdouble v = g_array_index (gp->vj, gdouble, n); */
  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  //return 0.;
  return cos(3*p.x)*sin(5*(p.x+p.y));
    //  return -(1+1.5*v)*sin(2.*M_PI*u);
}

static gdouble wigley_x1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble l = 1.; 

  return -l/2.*cos(u*M_PI);
  return l*(u-0.5);
}

static gdouble wigley_y1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  
  gdouble l = 1.; 
  gdouble b = l/10.;
  gdouble h = b/1.6;

  gdouble x = l*(u-0.5);
  x = -l/2*cos(u*M_PI);
  gdouble z = -h*v;
  z = -h*sin(M_PI/2*v);

  gdouble xi = 2.*x/l;
  gdouble zeta = z/h;
  gdouble eta = (1.-zeta*zeta)*(1-xi*xi)*(1+0.2*xi*xi) + zeta*zeta*(1-pow(zeta,8.))*pow(1-pow(xi,2.),4.);


  return -b/2.*eta;

  return -b/2.*(1-(2*x/l)*(2*x/l))*(1-(z/h)*(z/h));
}

static gdouble wigley_z1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble v = g_array_index (gp->vj, gdouble, n);
  
  gdouble l = 1.; 
  gdouble b = l/10.;
  gdouble h = b/1.6;

  return -h*sin(M_PI/2*v);
  return -h*v;
}

static gdouble wigley_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);

  gdouble l = 1.; 

  return l/2.*cos(u*M_PI);
  return -l*(u-0.5);
}

static gdouble wigley_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  
  gdouble l = 1.; 
  gdouble b = l/10.;
  gdouble h = b/1.6;

  gdouble x = -l*(u-0.5);
  x = l/2.*cos(u*M_PI);
  gdouble z = -h*v;
  z = -h*sin(M_PI/2*v);

  gdouble xi = 2.*x/l;
  gdouble zeta = z/h;
  gdouble eta = (1.-zeta*zeta)*(1-xi*xi)*(1+0.2*xi*xi) + zeta*zeta*(1-pow(zeta,8.))*pow(1-pow(xi,2.),4.);


  return b/2.*eta;

  return b/2.*(1-(2*x/l)*(2*x/l))*(1-(z/h)*(z/h));
}

static gdouble wigley_z2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble v = g_array_index (gp->vj, gdouble, n);
  
  gdouble l = 1.; 
  gdouble b = l/10.;
  gdouble h = b/1.6;

  return -h*sin(M_PI/2*v);
  return -h*v;
}

static gdouble wigleyfs_x1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);

  //return (1.5*(1-cos(v*M_PI/2)) + 0.5)*cos(2. * M_PI * u);
  return -1. + 2*u;
}

static gdouble wigleyfs_y1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  
  gdouble x = -1+2*u;

  if (fabs(x) > 0.5)
    return v;

  gdouble y0 = 0.05*(1.-4.*x*x);

  return y0 + (1-y0)*v;

  /* gdouble x = 0.5* cos (2. * M_PI *u); */
  
  /* // return sin (2. * M_PI *u)/fabs(sin (2. * M_PI *u))*0.05*(1.-4.*x*x) + 1.5*(1-cos(v*M_PI/2))*sin (2. * M_PI *u); */
  /* return sin (2. * M_PI *u)/fabs(sin (2. * M_PI *u))*0.05*(1.-4.*x*x) + 1.5*v*sin (2. * M_PI *u); */
}

static gdouble wigleyfs_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);

  //return (1.5*(1-cos(v*M_PI/2)) + 0.5)*cos(2. * M_PI * u);
  return -1. + 2*u;
}

static gdouble wigleyfs_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  
  gdouble x = -1+2*u;

  if (fabs(x) > 0.5)
    return -v;

  gdouble y0 = 0.05*(1.-4.*x*x);

  return -(y0 + (1-y0)*v);

  /* gdouble x = 0.5* cos (2. * M_PI *u); */
  
  /* // return sin (2. * M_PI *u)/fabs(sin (2. * M_PI *u))*0.05*(1.-4.*x*x) + 1.5*(1-cos(v*M_PI/2))*sin (2. * M_PI *u); */
  /* return sin (2. * M_PI *u)/fabs(sin (2. * M_PI *u))*0.05*(1.-4.*x*x) + 1.5*v*sin (2. * M_PI *u); */
}

static gdouble testfs_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
 
  v = v < 0.6 ? v*0.4/0.6 : 0.4 + (v-0.6)*0.6/0.4;

  return (9.5*v+0.5)*cos (2. * M_PI * u);
}

static gdouble testfs_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  v = v < 0.6 ? v*0.4/0.6 : 0.4 + (v-0.6)*0.6/0.4;
  
  return (9.875*v+0.125)*sin (2. * M_PI * u);
}

static gdouble sphere_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = 1.-g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  /* if (spp->sp->next == NULL) */
  /*   u = 3./4.+u/4.;/\* u = 0.5+u*0.5; *\/ */
  /* else */
  /*   u = u*3./4.;/\* u*0.5 ;*\/ */

  if (spp->sp->next == NULL)
    u = 0.5+u*0.5;
  else
    u = u*0.5 ;

  u = 1.-u;

  return  *r*cos (2. * M_PI * u)*sin (M_PI*v) /* - 1e-10 */;
}

static gdouble sphere_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = 1.-g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  /* if (spp->sp->next == NULL) */
  /*   u = 3./4.+u/4.; */
  /* else */
  /*   u = u*3./4.; */

  if (spp->sp->next == NULL)
    u = 0.5+u*0.5;
  else
    u = u*0.5 ;

  u = 1.-u;

  return *r*sin (2. * M_PI * u)*sin (M_PI*v) ;
}

static gdouble sphere_z2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble v = 1.-g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return *r*cos(M_PI*v);
}

static gdouble sphere_x3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*cos (2. * M_PI * u)*sin (M_PI*v) /* - 1e-10 */;
}

static gdouble sphere_y3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return *r*sin (2. * M_PI * u)*sin (M_PI*v) ;
}

static gdouble sphere_z3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return *r*cos(M_PI*v);
}

static gdouble sphere_x3_bc (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  /* GaussPoints * gp = spp->outer; */
  /* gdouble u = g_array_index (gp->ui, gdouble, m); */
  /* gdouble v = g_array_index (gp->vj, gdouble, n); */
  gdouble * r = data;

  return  *r*cos (2. * M_PI * u)*sin (M_PI*v) /* - 1e-10 */;
}

static gdouble sphere_y3_bc (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  /* GaussPoints * gp = spp->outer; */
  /* gdouble u = g_array_index (gp->ui, gdouble, m); */
  /* gdouble v = g_array_index (gp->vj, gdouble, n); */
  gdouble * r = data;

  return *r*sin (2. * M_PI * u)*sin (M_PI*v) ;
}

static gdouble sphere_z3_bc (Spline2D * sp, gdouble u, gdouble v, gpointer data)
{
  gdouble * r = data;

  return *r*cos(M_PI*v);
}

/*************************************************************/

void add_gravity_force (Simulation * sim, Forces * f, gdouble t,
			gdouble u[6], gdouble x[6])
{
  // Here the forces should be expressed in the reference frame of the ship
  // Moments are given at G
  /* f->forces_ext [0] = 0.; */
  /* f->forces_ext [1] = 0.; */
  /* f->forces_ext [2] = 0.; */
  /* f->forces_ext [3] = 0.; */
  /* f->forces_ext [4] = 0.; */
  /* f->forces_ext [5] = 0.; */

  // Those forces will be transformed from the inertial frame of reference
  // to that of the boat. Moments are given at G
  Motion * m = &sim->hull->m;
  /* Vector f_inertial, m_inertial; */
  /* f_inertial.x = 0.; */
  /* f_inertial.y = 0.; */
  /* f_inertial.z = -sim->hull->mg*sim->g- 10000*sim->hull->m.v[2]*fabs(sim->hull->m.v[2]); */

  /* m_inertial.x = 0.; */
  /* m_inertial.y = 0.; */
  /* m_inertial.z = 0.; */

  // Transform and add to the forces initially expressed in the inertial frame of reference
  
  f->forces_ext[0] = -m->euler_m.a[2][0]*sim->hull->mg*sim->g;
  f->forces_ext[1] = -m->euler_m.a[2][1]*sim->hull->mg*sim->g;
  f->forces_ext[2] = -m->euler_m.a[2][2]*sim->hull->mg*sim->g;
  f->forces_ext [3] = 0.;
  f->forces_ext [4] = 0.;
  f->forces_ext [5] = 0.;

  /* f->forces_h[0] = -m->euler_m.a[2][0]*sim->hull->mg*sim->g; */
  /* f->forces_h[1] = -m->euler_m.a[2][1]*sim->hull->mg*sim->g; */
  /* f->forces_h[2] = -m->euler_m.a[2][2]*sim->hull->mg*sim->g; */
  /* f->forces_h[3] = 0.; */
  /* f->forces_h[4] = 0.; */
  /* f->forces_h[5] = 0.; */

  /* f->forces_ext[3] += m->euler_m.a[0][0]*m_inertial.x + m->euler_m.a[1][0]*m_inertial.y + m->euler_m.a[2][0]*m_inertial.z; */
  /* f->forces_ext[4] += m->euler_m.a[0][1]*m_inertial.x + m->euler_m.a[1][1]*m_inertial.y + m->euler_m.a[2][1]*m_inertial.z; */
  /* f->forces_ext[5] += m->euler_m.a[0][2]*m_inertial.x + m->euler_m.a[1][2]*m_inertial.y + m->euler_m.a[2][2]*m_inertial.z; */
}

static void add_hydrostatic_restoring_force (Simulation * sim,
					     Forces * f,
					     gdouble t,
					     gdouble u[6],
					     gdouble x[6])
{
  gint i, j;
  gdouble fr[6];

  for ( i = 0; i < 6; i++ )
    fr[i] = 0.;

  for ( i = 0; i < 6; i++) {
    for ( j = 0; j < 6; j++) {
      fr[i] -= sim->hull->R[j][i]*x[j];
    }
  }

  // If expressed in the frame of reference of the boat
  /* for ( i = 0; i < 6; i++ ) */
  /*   f->forces_h [i] = fr[i]; */

  // If expressed in the inertial frame of reference
  Motion * m = &sim->hull->m; 

  // Transform and add to the forces initially expressed in the inertial frame of reference
  f->forces_h[0] = m->euler_m.a[0][0]*fr[0] + m->euler_m.a[1][0]*fr[1] + m->euler_m.a[2][0]*fr[2];
  f->forces_h[1] = m->euler_m.a[0][1]*fr[0] + m->euler_m.a[1][1]*fr[1] + m->euler_m.a[2][1]*fr[2];
  f->forces_h[2] = m->euler_m.a[0][2]*fr[0] + m->euler_m.a[1][2]*fr[1] + m->euler_m.a[2][2]*fr[2];

  f->forces_h[3] = m->euler_m.a[0][0]*fr[3] + m->euler_m.a[1][0]*fr[4] + m->euler_m.a[2][0]*fr[5];
  f->forces_h[4] = m->euler_m.a[0][1]*fr[3] + m->euler_m.a[1][1]*fr[4] + m->euler_m.a[2][1]*fr[5];
  f->forces_h[5] = m->euler_m.a[0][2]*fr[3] + m->euler_m.a[1][2]*fr[4] + m->euler_m.a[2][2]*fr[5];

#if 0
  for ( i = 0; i < 4; i++ )
     f->forces_l[i] = f->forces_m[i] = f->forces_ext[i] = f->forces_fk[i] =  f->forces_h[i] = 0.;

  for ( i = 4; i < 5; i++ )
     f->forces_l[i] /* = f->forces_m[i] */ /* = f->forces_ext[i] */ /* = f->forces_h[i]  */ = 0.;

  for ( i = 5; i < 6; i++ )
     f->forces_l[i] = f->forces_m[i] = f->forces_ext[i] = f->forces_fk[i] =  f->forces_h[i] = 0.;
#endif
  for ( i = 0; i < 6; i++ )
    f->forces_l[i] = 0.;
  /* for ( i = 0; i < 6; i++ ) */
  /*    f->forces_l[i] = f->forces_m[i] = f->forces_ext[i] = f->forces_fk[i] =  f->forces_h[i] = 0.; */

  /* for ( i = 0; i < 6; i++ ) */
  /*   f->forces_l[i] = 0.; */

  /* for ( i = 3; i < 6; i++ ) */
  /*   f->forces_h[i] = 0.; */

  /* f->forces_h[3] = 0.; */
  /* f->forces_h[5] = 0.; */

  /* f->forces_ext[0] = 10*cos(2.*M_PI*t/3.); */
  /* f->forces_ext [5] = /\* -M_PI*m->x[5] *\/-M_PI*M_PI/4.*sin(sqrt(M_PI/5.)*(t)); */
  /* for ( i = 0; i < 6; i++ ) */
  /*   f->forces_m[i] = 0.; */

  /* if (t>1) */
  /*   g_assert_not_reached (); */
}

void add_roll_damping_force (Simulation * sim, Forces * f, gdouble t,
			     gdouble u[6], gdouble x[6])
{
  // Here the forces should be expressed in the reference frame of the ship
  // Moments are given at G
  /* f->forces_ext [0] = 0.; */
  /* f->forces_ext [1] = 0.; */
  /* f->forces_ext [2] = 0.; */
  /* f->forces_ext [3] = 0.; */
  /* f->forces_ext [4] = 0.; */
  /* f->forces_ext [5] = 0.; */

  // Those forces will be transformed from the inertial frame of reference
  // to that of the boat. Moments are given at G
  Motion * m = &sim->hull->m; 
  Vector f_inertial, m_inertial;

  /* if ( t > 150.) { */
  /*   f_inertial.x = -/\* 0.052 *\/0.01*sim->hull->mg*sim->hull->m.v[0]; */
  /*   f_inertial.y = -/\* 0.052 *\/0.01*sim->hull->mg*sim->hull->m.v[1]; */
  /*   f_inertial.z = -/\* 0.052 *\/0.01*sim->hull->mg*sim->hull->m.v[2]; */

  /*   m_inertial.x = -0.052*sqrt(sim->hull->R[3][3]*sim->hull->M[3][3])*sim->hull->m.v[3]; */
  /*   m_inertial.y = -0.01*sqrt(sim->hull->R[4][4]*sim->hull->M[4][4])*sim->hull->m.v[4]; */
  /*   m_inertial.z = -0.01*sqrt(sim->hull->R[5][5]*sim->hull->M[5][5])*sim->hull->m.v[5]; */
  /* } */
  /* else { // Heavy damping for first 100s aimed at helping getting rid of transient state */
  /*   f_inertial.x = -/\* 0.052 *\/0.5*sim->hull->mg*sim->hull->m.v[0]; */
  /*   f_inertial.y = -/\* 0.052 *\/0.5*sim->hull->mg*sim->hull->m.v[1]; */
  /*   f_inertial.z = -/\* 0.052 *\/0.5*sim->hull->mg*sim->hull->m.v[2]; */

  /*   m_inertial.x = -0.5*sqrt(sim->hull->R[3][3]*sim->hull->M[3][3])*sim->hull->m.v[3]; */
  /*   m_inertial.y = -0.5*sqrt(sim->hull->R[4][4]*sim->hull->M[4][4])*sim->hull->m.v[4]; */
  /*   m_inertial.z = -0.5*sqrt(sim->hull->R[5][5]*sim->hull->M[5][5])*sim->hull->m.v[5];  */
  /* } */
  
  /* f_inertial.x = -/\* 0.052 *\/0.5*sim->hull->mg*sim->hull->m.v[0]; */
  /* f_inertial.y = -/\* 0.052 *\/0.5*sim->hull->mg*sim->hull->m.v[1]; */
  /* f_inertial.z = -/\* 0.052 *\/0.5*sim->hull->mg*sim->hull->m.v[2]; */
  
  m_inertial.x = -0.052*sqrt(sim->hull->R[3][3]*sim->hull->M[3][3])*sim->hull->m.v[3];
  /* m_inertial.y = -0.5*sqrt(sim->hull->R[4][4]*sim->hull->M[4][4])*sim->hull->m.v[4]; */
  /* m_inertial.z = -0.5*sqrt(sim->hull->R[5][5]*sim->hull->M[5][5])*sim->hull->m.v[5]; */

  // Transform and add to the forces initially expressed in the inertial frame of reference
  
  /* f->forces_ext[0] = -m->euler_m.a[2][0]*sim->hull->mg*0.1*u[2]; */
  /* f->forces_ext[1] = -m->euler_m.a[2][1]*sim->hull->mg*0.1*u[2]; */
  /* f->forces_ext[2] = -m->euler_m.a[2][2]*sim->hull->mg*0.1*u[2]; */
  /* f->forces_ext [3] = 0.; */
  /* f->forces_ext [4] = 0.; */
  /* f->forces_ext [5] = 0.; */

  f->forces_ext[0] += m->euler_m.a[0][0]*f_inertial.x + m->euler_m.a[1][0]*f_inertial.y + m->euler_m.a[2][0]*f_inertial.z;
  f->forces_ext[1] += m->euler_m.a[0][1]*f_inertial.x + m->euler_m.a[1][1]*f_inertial.y + m->euler_m.a[2][1]*f_inertial.z;
  f->forces_ext[2] += m->euler_m.a[0][2]*f_inertial.x + m->euler_m.a[1][2]*f_inertial.y + m->euler_m.a[2][2]*f_inertial.z;

  
  f->forces_ext[3] += m->euler_m.a[0][0]*m_inertial.x + m->euler_m.a[1][0]*m_inertial.y + m->euler_m.a[2][0]*m_inertial.z;
  f->forces_ext[4] += m->euler_m.a[0][1]*m_inertial.x + m->euler_m.a[1][1]*m_inertial.y + m->euler_m.a[2][1]*m_inertial.z;
  f->forces_ext[5] += m->euler_m.a[0][2]*m_inertial.x + m->euler_m.a[1][2]*m_inertial.y + m->euler_m.a[2][2]*m_inertial.z;
}

/**
 * This is a prototype that contains all you needs to add a simple
 * external force.
 **/
static void add_viscous_drag_forces (Simulation * sim, Forces * f, gdouble t,
				     gdouble u[6], gdouble x[6])
{
  // Here the forces should be expressed in the reference frame of the ship
  // Moments are given at G
  /* f->forces_ext [0] = 0.; */
  /* f->forces_ext [1] = 0.; */
  /* f->forces_ext [2] = 0.; */
  /* f->forces_ext [3] = 0.; */
  /* f->forces_ext [4] = 0.; */
  /* f->forces_ext [5] = 0.; */

  // Those forces will be transformed from the inertial frame of reference
  // to that of the boat. Moments are given at G
  Motion * m = &sim->hull->m; 
  Vector f_inertial, m_inertial;
  // Viscous drag: 0.5*rho*v*v*Cd*A
  gdouble v = sqrt(sim->hull->m.v[0]*sim->hull->m.v[0]
		   +sim->hull->m.v[1]*sim->hull->m.v[1]
		   +sim->hull->m.v[2]*sim->hull->m.v[2]);
  f_inertial.x = -0.5*1000.*M_PI*0.45*sim->hull->m.v[0]*v;
  f_inertial.y = -0.5*1000.*M_PI*0.45*sim->hull->m.v[1]*v;
  f_inertial.z = -0.5*1000.*M_PI*0.45*sim->hull->m.v[2]*v/* M_PI*1000.*9.81*(pow(1-m->x[2],2) - pow (1-m->x[2],3)/3.) *//* -sim->hull->mg*sim->g- 10000*sim->hull->m.v[2]*fabs(sim->hull->m.v[2]) */;

  m_inertial.x = 0.;
  m_inertial.y = 0.;
  m_inertial.z = 0.;

  // Transform and add to the forces initially expressed in the inertial frame of reference
  
  f->forces_ext[0] += m->euler_m.a[0][0]*f_inertial.x + m->euler_m.a[1][0]*f_inertial.y + m->euler_m.a[2][0]*f_inertial.z;
  f->forces_ext[1] += m->euler_m.a[0][1]*f_inertial.x + m->euler_m.a[1][1]*f_inertial.y + m->euler_m.a[2][1]*f_inertial.z;
  f->forces_ext[2] += m->euler_m.a[0][2]*f_inertial.x + m->euler_m.a[1][2]*f_inertial.y + m->euler_m.a[2][2]*f_inertial.z;
  f->forces_ext[3] += m->euler_m.a[0][0]*m_inertial.x + m->euler_m.a[1][0]*m_inertial.y + m->euler_m.a[2][0]*m_inertial.z;
  f->forces_ext[4] += m->euler_m.a[0][1]*m_inertial.x + m->euler_m.a[1][1]*m_inertial.y + m->euler_m.a[2][1]*m_inertial.z;
  f->forces_ext[5] += m->euler_m.a[0][2]*m_inertial.x + m->euler_m.a[1][2]*m_inertial.y + m->euler_m.a[2][2]*m_inertial.z;
}

static Forces forces_interpolation_new (Hull * hull,
					gdouble t,
					Time * time,
					Forces * f0, Forces * f1,
					gdouble u[6], gdouble x[6],
					Simulation * sim,
					GSList * forces,
					gboolean prediction)
{
  Forces f;
  gint i, j;

  forces_set_to_zero (&f);

  update_rotation_matrix (&hull->m, x, u);

  gdouble t0 = sim->time.t;
  sim->time.t = t; // Allows potential evaluation at right time
  // Estimate forces
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &f, t, u, x, prediction);
    forces = forces->next;
  }
  sim->time.t = t0;

  update_rotation_matrix (&hull->m, hull->m.x, hull->m.u);

  // Calculate entrainement forces
  // m omega x u
  f.forces_e[0] = 0./* -hull->mg*(u[4]*u[2] - u[5]*u[1]) */;
  f.forces_e[1] = 0./* -hull->mg*(u[5]*u[0] - u[3]*u[2]) */;
  f.forces_e[2] = 0./* -hull->mg*(u[3]*u[1] - u[4]*u[0]) */;

  // omega x Ig omega
  gdouble tmp2[3];
  tmp2[0] = tmp2[1] = tmp2[2] = 0.;

  for ( i = 0; i < 3; i++) {
    for ( j = 0; j < 3; j++) {
      tmp2[i] += hull->Ig[j][i]*u[3+j];
    }
  }

  f.forces_e[3] = 0./* -(u[4]*tmp2[2] - u[5]*tmp2[1]) */;
  f.forces_e[4] = 0./* -(u[5]*tmp2[0] - u[3]*tmp2[2]) */;
  f.forces_e[5] = 0./* -(u[3]*tmp2[1] - u[4]*tmp2[0]) */;

  return f;
}

void update_rotation_matrix (Motion * m, gdouble x[6], gdouble u[6])
{
  gdouble c1 = cos(x[3]), c2 = cos(x[4]), c3 = cos(x[5]);
  gdouble s1 = sin(x[3]), s2 = sin(x[4]), s3 = sin(x[5]);
  gdouble t2 = tan(x[4]);

  // For small angles could be replaced by identity
  // This is complex and given by the euler angles this is the inverse of the 
  // Matrix defined by formula (2.25) of (Shao, 2010)
  // Transports angular momentum from boat to inertial frame of reference
  m->euler_r.a[0][0] = 1.; m->euler_r.a[0][1] = s1*t2; m->euler_r.a[0][2] = c1*t2;
  m->euler_r.a[1][0] = 0.; m->euler_r.a[1][1] = c1;    m->euler_r.a[1][2] = -s1;
  m->euler_r.a[2][0] = 0.; m->euler_r.a[2][1] = s1/c2; m->euler_r.a[2][2] = c1/c2;

  // Could be linearized for small angles
  m->euler_m.a[0][0] = c2*c3; m->euler_m.a[0][1] = s1*s2*c3-c1*s3; m->euler_m.a[0][2] = c1*s2*c3+s1*s3;
  m->euler_m.a[1][0] = c2*s3; m->euler_m.a[1][1] = s1*s2*s3+c1*c3; m->euler_m.a[1][2] = c1*s2*s3-s1*c3;
  m->euler_m.a[2][0] = -s2;   m->euler_m.a[2][1] = s1*c2;          m->euler_m.a[2][2] = c1*c2;

  gint i, j;
  for ( i = 0; i < 6; i++)
    m->v[i] = 0;

  for ( i = 0; i < 3; i++)
    for ( j = 0; j < 3; j++)
      m->v[i] += m->euler_m.a[i][j]*u[j];

  for ( i = 3; i < 6; i++)
    for ( j = 3; j < 6; j++)
      m->v[i] += m->euler_r.a[i-3][j-3]*u[j];
  
  m->t.x = x[0];
  m->t.y = x[1];
  m->t.z = x[2];
}

Motion motion_RK4_time_integration_new  (Hull * hull,
					 Time * time,
					 Motion m0, Forces * f0,
					 Forces * f1,
					 Simulation * sim,
					 GSList * forces)
{
  Motion m1 = m0, k1, k2, k3, k4;
  gdouble utmp[6], xtmp[6];
  Forces ftmp;
  gdouble t = time->t;
  gdouble dt = time->dt;
  gint i, j;

  gsl_vector * dy = gsl_vector_alloc (6);

  if (sim->mass_lu == NULL) {
    gsl_matrix * M = gsl_matrix_alloc (6,6);
    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++)
	gsl_matrix_set (M, i, j, /* hull->M[j][i] */hull->M[i][j]); // M is generaly mass + added_mass
    sim->mass_lu = sim->lu_factorise (M);
    // No free of M as it is included in mass_lu
  }

  // k1 = dt*f(t0, y0)
  for ( i = 0; i < 6; i++) {
    k1.x[i] = 0.;
  }

  if ( t == 0.) {
    ftmp = forces_interpolation_new (hull, t, time, f0, f1, m0.u, m0.x, sim, forces, FALSE);
    
    /* g_assert_not_reached (); */

    for ( i = 0; i < 6; i++) {
      k1.u[i] = dt*(ftmp.forces_m[i] + ftmp.forces_l[i] + ftmp.forces_h[i] +
		    ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i]
		    + ftmp.forces_ext[i]);
    }
  }
  else {
    for ( i = 0; i < 6; i++) {
      k1.u[i] = dt*(f0->forces_m[i] + f0->forces_l[i] + f0->forces_h[i] +
		    f0->forces_fk[i] + f0->forces_r[i] + f0->forces_e[i]
		    + f0->forces_ext[i]);
    }
  }

  for ( j = 0; j < 3; j++) {
    gdouble du = dt*m0.u[j];
    for ( i = 0; i < 3; i++) {
      k1.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  for ( j = 3; j < 6; j++) {
    gdouble du  = dt*m0.u[j];
    for ( i = 3; i < 6; i++) {
      k1.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }
  
  // k2 = dt*f(t0+dt/2, y0)
  for ( i = 0; i < 6; i++)
    k2.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+0.5*time->dt, time, f0, f1, m0.u, m0.x, sim, forces, /* FALSE */TRUE);

  for ( i = 0; i < 6; i++) {
    k2.u[i] = dt*(ftmp.forces_m[i] +ftmp.forces_l[i] +ftmp.forces_h[i] +
		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i]
		  + ftmp.forces_ext[i]);
  }

  for ( j = 0; j < 3; j++) {
    gdouble du = dt*0.5*(m0.u[j]+m1.u[j]);
    for ( i = 0; i < 3; i++) {
      k2.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  for ( j = 3; j < 6; j++) {
    gdouble du = dt*0.5*(m0.u[j]+m1.u[j]);
    for ( i = 3; i < 6; i++) {
      k2.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }
  
  // k3 = dt*f(t0+dt/2, y0+k2/2)
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (dy, i, k2.u[i]/2.);

  sim->lu_factorised_solve (sim->mass_lu, dy);

  for ( i = 0; i < 6; i++)
    utmp[i] = m0.u[i] + gsl_vector_get (dy, i);

  for ( i = 0; i < 6; i++)
    xtmp[i] = m0.x[i] + 0.5*k2.x[i];
  //g_assert_not_reached ();
  update_rotation_matrix (&m1, xtmp, utmp);
  //g_assert_not_reached ();
  update_rotation_matrix (&hull->m, xtmp, utmp);
  //g_assert_not_reached ();
  for ( i = 0; i < 6; i++)
    k3.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+0.5*dt, time, f0, f1, utmp, xtmp, sim, forces, FALSE);
  for ( i = 0; i < 6; i++) {
    k3.u[i] = dt*(ftmp.forces_m[i] +ftmp.forces_l[i] + ftmp.forces_h[i] +
		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i]
		  + ftmp.forces_ext[i]);
  }

  for ( j = 0; j < 3; j++) {
    gdouble du = 0.5*dt*(m0.u[j]+m1.u[j]);
    for ( i = 0; i < 3; i++) {
      k3.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  for ( j = 3; j < 6; j++) {
    gdouble du = 0.5*dt*(m0.u[j]+m1.u[j]);
    for ( i = 3; i < 6; i++) {
      k3.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }

  // k4 = dt*f(t0+dt, y0+k3)
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (dy, i, k3.u[i]);

  sim->lu_factorised_solve (sim->mass_lu, dy);

  for ( i = 0; i < 6; i++)
    utmp[i] = m0.u[i] + gsl_vector_get (dy, i);

  for ( i = 0; i < 6; i++)
    xtmp[i] = m0.x[i] + k3.x[i];

  update_rotation_matrix (&m1, xtmp, utmp);
  update_rotation_matrix (&hull->m, xtmp, utmp);

  for ( i = 0; i < 6; i++)
    k4.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+time->dt, time,
				   f0, f1, utmp, xtmp, sim, forces, FALSE);

  for ( i = 0; i < 6; i++) {
    k4.u[i] = dt*(ftmp.forces_m[i] + ftmp.forces_l[i] + ftmp.forces_h[i] +
		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i]
		  + ftmp.forces_ext[i]);
  }

  for ( j = 0; j < 3; j++) {
    gdouble du = dt*m1.u[j];
    for ( i = 0; i < 3; i++) {
      k4.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  for ( j = 3; j < 6; j++) {
    gdouble du = dt*m1.u[j];
    for ( i = 3; i < 6; i++) {
      k4.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }

  // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (dy, i, (k1.u[i] + 2.*k2.u[i] + 2.*k3.u[i] + k4.u[i])/6.);

  sim->lu_factorised_solve (sim->mass_lu, dy);

  // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6
  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] + gsl_vector_get (dy, i);

  for ( i = 0; i < 6; i++) {
    m1.x[i] = m0.x[i] + (k1.x[i] + 2.*k2.x[i] + 2.*k3.x[i] + k4.x[i])/6.;
  }

  gsl_vector_free (dy);

  m1.t.x = m1.x[0];
  m1.t.y = m1.x[1];
  m1.t.z = m1.x[2];

  //  update_rotation_matrix (&m1, m1.x, m1.u);
  update_rotation_matrix (&hull->m, m1.x, m1.u);

  // Forces that are stored
  *f1 = forces_interpolation_new (hull, t+time->dt, time,
  				  f0, f1, m1.u, m1.x, sim, forces, FALSE);
  //g_assert_not_reached ();
  return m1;
}

Motion motion_1dof_RK4_time_integration_new  (Hull * hull,
					      Time * time,
					      Motion m0, Forces * f0,
					      Forces * f1,
					      Simulation * sim,
					      GSList * forces,
					      gint d)
{
  Motion m1 = m0, k1, k2, k3, k4;
  gdouble utmp[6], xtmp[6];
  Forces ftmp;
  gdouble t = time->t;
  gdouble dt = time->dt;
  gint i, j;

  gsl_vector * dy = gsl_vector_alloc (6);

  if (sim->mass_lu == NULL) {
    gsl_matrix * M = gsl_matrix_alloc (6,6);
    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++)
	gsl_matrix_set (M, i, j, /* hull->M[j][i] */hull->M[i][j]); // M is generaly mass + added_mass
    sim->mass_lu = sim->lu_factorise (M);
    // No free of M as it is included in mass_lu
  }


  // k1 = dt*f(t0, y0)
  for ( i = 0; i < 6; i++) {
    k1.x[i] = 0.;
  }

  /* for ( i = 0; i < 6; i++) { */
  /*   k1.u[i] = dt*(f0->forces_m[i] + f0->forces_l[i] + f0->forces_h[i] + */
  /* 		  f0->forces_fk[i] + f0->forces_r[i] + f0->forces_e[i] */
  /* 		  + f0->forces_ext[i]); */
  /* } */
  k1.u[d] = dt*(f0->forces_m[d] + f0->forces_l[d] + f0->forces_h[d] +
		  f0->forces_fk[d] + f0->forces_r[d] + f0->forces_e[d]
		  + f0->forces_ext[d]);

  /* if ( d < 3 ) { */
  /*   for ( j = 0; j < 3; j++) { */
  /*     gdouble du = dt*m0.u[j]; */
  /*     k1.x[d] += m1.euler_m.a[d][j]*du; */
  /*   } */
  /* } */
  /* else { */
  /*   for ( j = 3; j < 6; j++) { */
  /*     gdouble du  = dt*m0.u[j]; */
  /* 	k1.x[d] += m1.euler_r.a[d-3][j-3]*du; */
  /*     } */
  /* } */

  for ( j = 0; j < 3; j++) {
    gdouble du = dt*m0.u[j];
    for ( i = 0; i < 3; i++) {
      k1.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  for ( j = 3; j < 6; j++) {
    gdouble du  = dt*m0.u[j];
    for ( i = 3; i < 6; i++) {
      k1.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }

  //  g_assert_not_reached ();
  
  // k2 = dt*f(t0+dt/2, y0)
  for ( i = 0; i < 6; i++)
    k2.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+0.5*time->dt, time, f0, f1, m0.u, m0.x, sim, forces, TRUE);
  /* for ( i = 0; i < 6; i++) { */
  /*   k2.u[i] = dt*(ftmp.forces_m[i] +ftmp.forces_l[i] +ftmp.forces_h[i] + */
  /* 		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i] */
  /* 		  + ftmp.forces_ext[i]); */
  /* } */
  k2.u[d] = dt*(ftmp.forces_m[d] +ftmp.forces_l[d] +ftmp.forces_h[d] +
		ftmp.forces_fk[d] + ftmp.forces_r[d] + ftmp.forces_e[d]
		+ ftmp.forces_ext[d]);

  for ( j = 0; j < 3; j++) {
    gdouble du = dt*0.5*(m0.u[j]+m1.u[j]);
    for ( i = 0; i < 3; i++) {
      k2.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  /* if ( d < 3 ) { */
  /*   for ( j = 0; j < 3; j++) { */
  /*     gdouble du = dt*0.5*(m0.u[j]+m1.u[j]); */
  /*     k2.x[d] += m1.euler_m.a[d][j]*du; */
  /*   } */
  /* } */
  /* else { */
  /*   for ( j = 3; j < 6; j++) { */
  /*     gdouble du = dt*0.5*(m0.u[j]+m1.u[j]); */
  /*     k2.x[d] += m1.euler_r.a[d-3][j-3]*du; */
  /*   } */
  /* } */

  for ( j = 3; j < 6; j++) {
    gdouble du = dt*0.5*(m0.u[j]+m1.u[j]);
    for ( i = 3; i < 6; i++) {
      k2.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }
  
  // k3 = dt*f(t0+dt/2, y0+k2/2)
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (dy, i, k2.u[i]/2.);

  sim->lu_factorised_solve (sim->mass_lu, dy);

  for ( i = 0; i < 6; i++)
    utmp[i] = m0.u[i] + gsl_vector_get (dy, i);

  for ( i = 0; i < 6; i++)
    xtmp[i] = m0.x[i] + 0.5*k2.x[i];
  update_rotation_matrix (&m1, xtmp, utmp);
  update_rotation_matrix (&hull->m, xtmp, utmp);

  for ( i = 0; i < 6; i++)
    k3.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+0.5*dt, time, f0, f1, utmp, xtmp, sim, forces, FALSE);
  /* for ( i = 0; i < 6; i++) { */
  /*   k3.u[i] = dt*(ftmp.forces_m[i] +ftmp.forces_l[i] + ftmp.forces_h[i] + */
  /* 		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i] */
  /* 		  + ftmp.forces_ext[i]); */
  /* } */

  k3.u[d] = dt*(ftmp.forces_m[d] +ftmp.forces_l[d] + ftmp.forces_h[d] +
		ftmp.forces_fk[d] + ftmp.forces_r[d] + ftmp.forces_e[d]
		+ ftmp.forces_ext[d]);

  for ( j = 0; j < 3; j++) {
    gdouble du = 0.5*dt*(m0.u[j]+m1.u[j]);
    for ( i = 0; i < 3; i++) {
      k3.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  for ( j = 3; j < 6; j++) {
    gdouble du = 0.5*dt*(m0.u[j]+m1.u[j]);
    for ( i = 3; i < 6; i++) {
      k3.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }

  // k4 = dt*f(t0+dt, y0+k3)
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (dy, i, k3.u[i]);

  sim->lu_factorised_solve (sim->mass_lu, dy);

  for ( i = 0; i < 6; i++)
    utmp[i] = m0.u[i] + gsl_vector_get (dy, i);

  for ( i = 0; i < 6; i++)
    xtmp[i] = m0.x[i] + k3.x[i];

  update_rotation_matrix (&m1, xtmp, utmp);
  update_rotation_matrix (&hull->m, xtmp, utmp);

  for ( i = 0; i < 6; i++)
    k4.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+time->dt, time,
				   f0, f1, utmp, xtmp, sim, forces, FALSE);

  /* for ( i = 0; i < 6; i++) { */
  /*   k4.u[i] = dt*(ftmp.forces_m[i] + ftmp.forces_l[i] + ftmp.forces_h[i] + */
  /* 		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i] */
  /* 		  + ftmp.forces_ext[i]); */
  /* } */

  k4.u[d] = dt*(ftmp.forces_m[d] + ftmp.forces_l[d] + ftmp.forces_h[d] +
		ftmp.forces_fk[d] + ftmp.forces_r[d] + ftmp.forces_e[d]
		+ ftmp.forces_ext[d]);

  for ( j = 0; j < 3; j++) {
    gdouble du = dt*m1.u[j];
    for ( i = 0; i < 3; i++) {
      k4.x[i] += m1.euler_m.a[i][j]*du;
    }
  }

  for ( j = 3; j < 6; j++) {
    gdouble du = dt*m1.u[j];
    for ( i = 3; i < 6; i++) {
      k4.x[i] += m1.euler_r.a[i-3][j-3]*du;
    }
  }

  // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (dy, i, (k1.u[i] + 2.*k2.u[i] + 2.*k3.u[i] + k4.u[i])/6.);

  sim->lu_factorised_solve (sim->mass_lu, dy);

  // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6
  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] + gsl_vector_get (dy, i);

  for ( i = 0; i < 6; i++) {
    m1.x[i] = m0.x[i] + (k1.x[i] + 2.*k2.x[i] + 2.*k3.x[i] + k4.x[i])/6.;
  }

  gsl_vector_free (dy);

  m1.t.x = m1.x[0];
  m1.t.y = m1.x[1];
  m1.t.z = m1.x[2];

  //  update_rotation_matrix (&m1, m1.x, m1.u);
  update_rotation_matrix (&hull->m, m1.x, m1.u);

  // Forces that are stored
  *f1 = forces_interpolation_new (hull, t+time->dt, time,
  				  f0, f1, m1.u, m1.x, sim, forces, FALSE);

  return m1;
}

Motion no_motion_RK4_time_integration_new  (Hull * hull,
					    Time * time,
					    Motion m0, Forces * f0,
					    Forces * f1,
					    Simulation * sim,
					    GSList * forces)
{
  Motion m1 = m0, k1, k2, k3, k4;
  gdouble utmp[6], xtmp[6];
  Forces ftmp;
  gdouble t = time->t;
  gdouble dt = time->dt;
  gint i, j;

  gsl_vector * dy = gsl_vector_alloc (6);

  if (sim->mass_lu == NULL) {
    gsl_matrix * M = gsl_matrix_alloc (6,6);
    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++)
	gsl_matrix_set (M, i, j, /*hull->M[j][i]*/hull->M[i][j]); // M is generaly mass + added_mass
    sim->mass_lu = sim->lu_factorise (M);
    // No free of M as it is included in mass_lu
  }


  // k1 = dt*f(t0, y0)
  for ( i = 0; i < 6; i++) {
    k1.x[i] = 0.;
  }

  /* for ( i = 0; i < 6; i++) { */
  /*   k1.u[i] = dt*(f0->forces_m[i] + f0->forces_l[i] + f0->forces_h[i] + */
  /* 		  f0->forces_fk[i] + f0->forces_r[i] + f0->forces_e[i] */
  /* 		  + f0->forces_ext[i]); */
  /* } */

  /* for ( j = 0; j < 3; j++) { */
  /*   gdouble du = dt*m0.u[j]; */
  /*   for ( i = 0; i < 3; i++) { */
  /*     k1.x[i] += m1.euler_m.a[i][j]*du; */
  /*   } */
  /* } */

  /* for ( j = 3; j < 6; j++) { */
  /*   gdouble du  = dt*m0.u[j]; */
  /*   for ( i = 3; i < 6; i++) { */
  /*     k1.x[i] += m1.euler_r.a[i-3][j-3]*du; */
  /*   } */
  /* } */

  //  g_assert_not_reached ();
  
  // k2 = dt*f(t0+dt/2, y0)
  for ( i = 0; i < 6; i++)
    k2.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+0.5*time->dt, time, f0, f1, m0.u, m0.x, sim, forces, TRUE);
  /* for ( i = 0; i < 6; i++) { */
  /*   k2.u[i] = dt*(ftmp.forces_m[i] +ftmp.forces_l[i] +ftmp.forces_h[i] + */
  /* 		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i] */
  /* 		  + ftmp.forces_ext[i]); */
  /* } */

  /* for ( j = 0; j < 3; j++) { */
  /*   gdouble du = dt*0.5*(m0.u[j]+m1.u[j]); */
  /*   for ( i = 0; i < 3; i++) { */
  /*     k2.x[i] += m1.euler_m.a[i][j]*du; */
  /*   } */
  /* } */

  /* for ( j = 3; j < 6; j++) { */
  /*   gdouble du = dt*0.5*(m0.u[j]+m1.u[j]); */
  /*   for ( i = 3; i < 6; i++) { */
  /*     k2.x[i] += m1.euler_r.a[i-3][j-3]*du; */
  /*   } */
  /* } */
  
  /* // k3 = dt*f(t0+dt/2, y0+k2/2) */
  /* for ( i = 0; i < 6; i++ ) */
  /*   gsl_vector_set (dy, i, k2.u[i]/2.); */

  /* sim->lu_factorised_solve (sim->mass_lu, dy); */

  /* for ( i = 0; i < 6; i++) */
  /*   utmp[i] = m0.u[i] + gsl_vector_get (dy, i); */

  for ( i = 0; i < 6; i++)
    xtmp[i] = m0.x[i] + 0.5*k2.x[i];
  update_rotation_matrix (&m1, xtmp, utmp);
  update_rotation_matrix (&hull->m, xtmp, utmp);

  for ( i = 0; i < 6; i++)
    k3.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t/* +0.5*dt */, time, f0, f1, utmp, xtmp, sim, forces, FALSE);
  /* for ( i = 0; i < 6; i++) { */
  /*   k3.u[i] = dt*(ftmp.forces_m[i] +ftmp.forces_l[i] + ftmp.forces_h[i] + */
  /* 		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i] */
  /* 		  + ftmp.forces_ext[i]); */
  /* } */

  /* for ( j = 0; j < 3; j++) { */
  /*   gdouble du = 0.5*dt*(m0.u[j]+m1.u[j]); */
  /*   for ( i = 0; i < 3; i++) { */
  /*     k3.x[i] += m1.euler_m.a[i][j]*du; */
  /*   } */
  /* } */

  /* for ( j = 3; j < 6; j++) { */
  /*   gdouble du = 0.5*dt*(m0.u[j]+m1.u[j]); */
  /*   for ( i = 3; i < 6; i++) { */
  /*     k3.x[i] += m1.euler_r.a[i-3][j-3]*du; */
  /*   } */
  /* } */

  /* // k4 = dt*f(t0+dt, y0+k3) */
  /* for ( i = 0; i < 6; i++ ) */
  /*   gsl_vector_set (dy, i, k3.u[i]); */

  /* sim->lu_factorised_solve (sim->mass_lu, dy); */

  for ( i = 0; i < 6; i++)
    utmp[i] = m0.u[i] /* + gsl_vector_get (dy, i) */;

  for ( i = 0; i < 6; i++)
    xtmp[i] = m0.x[i] /* + k3.x[i] */;

  update_rotation_matrix (&m1, xtmp, utmp);
  update_rotation_matrix (&hull->m, xtmp, utmp);

  for ( i = 0; i < 6; i++)
    k4.x[i] = 0.;

  ftmp = forces_interpolation_new (hull, t+time->dt, time,
				   f0, f1, utmp, xtmp, sim, forces, FALSE);

  /* for ( i = 0; i < 6; i++) { */
  /*   k4.u[i] = dt*(ftmp.forces_m[i] + ftmp.forces_l[i] + ftmp.forces_h[i] + */
  /* 		  ftmp.forces_fk[i] + ftmp.forces_r[i] + ftmp.forces_e[i] */
  /* 		  + ftmp.forces_ext[i]); */
  /* } */

  /* for ( j = 0; j < 3; j++) { */
  /*   gdouble du = dt*m1.u[j]; */
  /*   for ( i = 0; i < 3; i++) { */
  /*     k4.x[i] += m1.euler_m.a[i][j]*du; */
  /*   } */
  /* } */

  /* for ( j = 3; j < 6; j++) { */
  /*   gdouble du = dt*m1.u[j]; */
  /*   for ( i = 3; i < 6; i++) { */
  /*     k4.x[i] += m1.euler_r.a[i-3][j-3]*du; */
  /*   } */
  /* } */

  /* // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6 */
  /* for ( i = 0; i < 6; i++ ) */
  /*   gsl_vector_set (dy, i, (k1.u[i] + 2.*k2.u[i] + 2.*k3.u[i] + k4.u[i])/6.); */

  /* sim->lu_factorised_solve (sim->mass_lu, dy); */

  // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6
  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] /* + gsl_vector_get (dy, i) */;

  for ( i = 0; i < 6; i++) {
    m1.x[i] = m0.x[i] /* + (k1.x[i] + 2.*k2.x[i] + 2.*k3.x[i] + k4.x[i])/6. */;
  }

  gsl_vector_free (dy);

  m1.t.x = m1.x[0];
  m1.t.y = m1.x[1];
  m1.t.z = m1.x[2];

  //  update_rotation_matrix (&m1, m1.x, m1.u);
  update_rotation_matrix (&hull->m, m1.x, m1.u);

  // Forces that are stored
  *f1 = forces_interpolation_new (hull, t+time->dt, time,
  				  f0, f1, m1.u, m1.x, sim, forces, FALSE);

  return m1;
}

Motion motion_ABM4_time_integration_new (Hull * hull, Time * time,
					 Motion m0, ForcesHistory * fh, Forces * f1,
					 Simulation * sim,
					 GSList * forces)
{
  gint i = 0, j;
  gdouble t = time->t;
  gdouble dt = time->dt;
  Forces f[4];

  GSList * fl = fh->f;
  while (fl) {
    f[i] = *(Forces *) fl->data;
    fl = fl->next;
    i++;
  }

  Motion m1 = m0;
  gsl_vector * du = gsl_vector_alloc (6);

  /* Equation of motion in the reference frame of the boat */
  /* Prediction */
  gdouble utmp[6]/* , xtmp[6] */;

  for ( i = 0; i < 6; i++) {
    gsl_vector_set (du, i,
		    dt/24.*( -9.*(f[0].forces_m[i] + f[0].forces_l[i]
				  +f[0].forces_h[i] + f[0].forces_fk[i]
				  + f[0].forces_r[i] + f[0].forces_e[i]
				  + f[0].forces_ext[i])
			     + 37.*(f[1].forces_m[i] + f[1].forces_l[i]
				    + f[1].forces_h[i] + f[1].forces_fk[i]
				    + f[1].forces_r[i] + f[1].forces_e[i]
				    + f[1].forces_ext[i])
			     - 59.*(f[2].forces_m[i] + f[2].forces_l[i]
				    + f[2].forces_h[i] + f[2].forces_fk[i]
				    + f[2].forces_r[i] + f[2].forces_e[i]
				    + f[2].forces_ext[i])
			     + 55.*(f[3].forces_m[i] + f[3].forces_l[i]
				    + f[3].forces_h[i] + f[3].forces_fk[i]
				    + f[3].forces_r[i] + f[3].forces_e[i]
				    + f[3].forces_ext[i])));
  }

  for ( i = 0; i < 6; i++)
    utmp[i] = dt/24.*( -9.*f[0].u[i] + 37.*f[1].u[i]
		       - 59.*f[2].u[i] + 55.*f[3].u[i] );

  /* gsl_matrix * M = gsl_matrix_alloc (6,6); */
  /* for ( i = 0; i < 6; i++ ) */
  /*   for ( j = 0; j < 6; j++) */
  /*     gsl_matrix_set (M, i, j, hull->M[j][i]); // M is generaly mass + added_mass */

  sim->lu_factorised_solve (sim->mass_lu, du);

  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] + gsl_vector_get (du, i);
  
  for ( i = 0; i < 3; i++)
    for ( j = 0; j < 3; j++)
      m1.x[i] += hull->m.euler_m.a[i][j]*utmp[j];
  for ( i = 3; i < 6; i++)
    for ( j = 3; j < 6; j++)
      m1.x[i] += hull->m.euler_r.a[i-3][j-3]*utmp[j];

  update_rotation_matrix (&hull->m, m1.x, m1.u);


  /* Correction */
  Forces f4 = forces_interpolation_new (hull, t+time->dt, time,
					&f[3], f1, m1.u, m1.x, sim, forces, TRUE);

  for ( i = 0; i < 6; i++)
    m1.x[i] = m0.x[i];

  for ( i = 0; i < 6; i++) {
    gsl_vector_set (du, i,
		    dt/24.*( (f[1].forces_m[i] + f[1].forces_l[i]
			      + f[1].forces_h[i] + f[1].forces_fk[i]
			      + f[1].forces_r[i] + f[1].forces_e[i]
			      + f[1].forces_ext[i])
			     - 5.*(f[2].forces_m[i] + f[2].forces_l[i]
				   + f[2].forces_h[i] + f[2].forces_fk[i]
				   + f[2].forces_r[i] + f[2].forces_e[i]
				   + f[2].forces_ext[i])
			     + 19.*(f[3].forces_m[i] + f[3].forces_l[i]
				    + f[3].forces_h[i] + f[3].forces_fk[i]
				    + f[3].forces_r[i] + f[3].forces_e[i]
				    + f[3].forces_ext[i])
			     + 9.*(f4.forces_m[i] + f4.forces_l[i]
				   + f4.forces_h[i] + f4.forces_fk[i]
				   + f4.forces_r[i] + f4.forces_e[i]
				   + f4.forces_ext[i])));
  }

  for ( i = 0; i < 6; i++)
    utmp[i] = dt/24.*( f[1].u[i] - 5.*f[2].u[i]
		       + 19.*f[3].u[i] + 9.*f[3].u[i] );

  sim->lu_factorised_solve (sim->mass_lu, du);

  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] + gsl_vector_get (du, i);

  for ( i = 0; i < 3; i++)
    for ( j = 0; j < 3; j++)
      m1.x[i] += hull->m.euler_m.a[i][j]*utmp[j];
  for ( i = 3; i < 6; i++)
    for ( j = 3; j < 6; j++)
      m1.x[i] += hull->m.euler_r.a[i-3][j-3]*utmp[j];

  update_rotation_matrix (&hull->m, m1.x, m1.u);

  // Recalculate the forces on the updated geometry for use
  // in following time-steps
  *f1 = forces_interpolation_new (hull, t+time->dt, time,
  				  &f[3], f1, m1.u, m1.x, sim, forces, FALSE);

  return m1;
}

Motion motion_1dof_ABM4_time_integration_new (Hull * hull, Time * time,
					      Motion m0, ForcesHistory * fh, Forces * f1,
					      Simulation * sim,
					      GSList * forces,
					      gint d)
{
  gint i = 0, j;
  gdouble t = time->t;
  gdouble dt = time->dt;
  Forces f[4];

  GSList * fl = fh->f;
  while (fl) {
    f[i] = *(Forces *) fl->data;
    fl = fl->next;
    i++;
  }

  Motion m1 = m0;
  gsl_vector * du = gsl_vector_alloc (6);

  /* Equation of motion in the reference frame of the boat */
  /* Prediction */
  gdouble utmp[6]/* , xtmp[6] */;

  for ( i = 0; i < 6; i++)
    gsl_vector_set (du, i, 0.);

  gsl_vector_set (du, d,
		  dt/24.*( -9.*(f[0].forces_m[d] + f[0].forces_l[d]
				+f[0].forces_h[d] + f[0].forces_fk[d]
				+ f[0].forces_r[d] + f[0].forces_e[d]
				+ f[0].forces_ext[d])
			   + 37.*(f[1].forces_m[d] + f[1].forces_l[d]
				  + f[1].forces_h[d] + f[1].forces_fk[d]
				  + f[1].forces_r[d] + f[1].forces_e[d]
				  + f[1].forces_ext[d])
			   - 59.*(f[2].forces_m[d] + f[2].forces_l[d]
				  + f[2].forces_h[d] + f[2].forces_fk[d]
				  + f[2].forces_r[d] + f[2].forces_e[d]
				  + f[2].forces_ext[d])
			   + 55.*(f[3].forces_m[d] + f[3].forces_l[d]
				  + f[3].forces_h[d] + f[3].forces_fk[d]
				  + f[3].forces_r[d] + f[3].forces_e[d]
				  + f[3].forces_ext[d])));

  for ( i = 0; i < 6; i++)
    utmp[i] = dt/24.*( -9.*f[0].u[i] + 37.*f[1].u[i]
		       - 59.*f[2].u[i] + 55.*f[3].u[i] );

  /* gsl_matrix * M = gsl_matrix_alloc (6,6); */
  /* for ( i = 0; i < 6; i++ ) */
  /*   for ( j = 0; j < 6; j++) */
  /*     gsl_matrix_set (M, i, j, hull->M[j][i]); // M is generaly mass + added_mass */

  sim->lu_factorised_solve (sim->mass_lu, du);

  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] + gsl_vector_get (du, i);
  
  for ( i = 0; i < 3; i++)
    for ( j = 0; j < 3; j++)
      m1.x[i] += hull->m.euler_m.a[i][j]*utmp[j];
  for ( i = 3; i < 6; i++)
    for ( j = 3; j < 6; j++)
      m1.x[i] += hull->m.euler_r.a[i-3][j-3]*utmp[j];

  update_rotation_matrix (&hull->m, m1.x, m1.u);


  /* Correction */
  Forces f4 = forces_interpolation_new (hull, t+time->dt, time,
					&f[3], f1, m1.u, m1.x, sim, forces, TRUE);

  for ( i = 0; i < 6; i++)
    m1.x[i] = m0.x[i];

  for ( i = 0; i < 6; i++)
    gsl_vector_set (du, i, 0.);

  gsl_vector_set (du, d,
		  dt/24.*( (f[1].forces_m[d] + f[1].forces_l[d]
			    + f[1].forces_h[d] + f[1].forces_fk[d]
			    + f[1].forces_r[d] + f[1].forces_e[d]
			    + f[1].forces_ext[d])
			   - 5.*(f[2].forces_m[d] + f[2].forces_l[d]
				 + f[2].forces_h[d] + f[2].forces_fk[d]
				 + f[2].forces_r[d] + f[2].forces_e[d]
				 + f[2].forces_ext[d])
			   + 19.*(f[3].forces_m[d] + f[3].forces_l[d]
				  + f[3].forces_h[d] + f[3].forces_fk[d]
				  + f[3].forces_r[d] + f[3].forces_e[d]
				  + f[3].forces_ext[d])
			   + 9.*(f4.forces_m[d] + f4.forces_l[d]
				 + f4.forces_h[d] + f4.forces_fk[d]
				 + f4.forces_r[d] + f4.forces_e[d]
				 + f4.forces_ext[d])));


  for ( i = 0; i < 6; i++)
    utmp[i] = dt/24.*( f[1].u[i] - 5.*f[2].u[i]
		       + 19.*f[3].u[i] + 9.*f[3].u[i] );

  sim->lu_factorised_solve (sim->mass_lu, du);

  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] + gsl_vector_get (du, i);

  for ( i = 0; i < 3; i++)
    for ( j = 0; j < 3; j++)
      m1.x[i] += hull->m.euler_m.a[i][j]*utmp[j];
  for ( i = 3; i < 6; i++)
    for ( j = 3; j < 6; j++)
      m1.x[i] += hull->m.euler_r.a[i-3][j-3]*utmp[j];

  update_rotation_matrix (&hull->m, m1.x, m1.u);

  // Recalculate the forces on the updated geometry for use
  // in following time-steps
  *f1 = forces_interpolation_new (hull, t+time->dt, time,
  				  &f[3], f1, m1.u, m1.x, sim, forces, FALSE);

  return m1;
}

Motion no_motion_ABM4_time_integration_new (Hull * hull, Time * time,
					 Motion m0, ForcesHistory * fh, Forces * f1,
					 Simulation * sim,
					 GSList * forces)
{
  gint i = 0, j;
  gdouble t = time->t;
  /* gdouble dt = time->dt; */
  Forces f[4];

  GSList * fl = fh->f;
  while (fl) {
    f[i] = *(Forces *) fl->data;
    fl = fl->next;
    i++;
  }

  Motion m1 = m0;
  gsl_vector * du = gsl_vector_alloc (6);

  /* Equation of motion in the reference frame of the boat */
  /* Prediction */
  gdouble utmp[6]/* , xtmp[6] */;

  /* for ( i = 0; i < 6; i++) { */
  /*   gsl_vector_set (du, i, */
  /* 		    dt/24.*( -9.*(f[0].forces_m[i] + f[0].forces_l[i] */
  /* 				  +f[0].forces_h[i] + f[0].forces_fk[i] */
  /* 				  + f[0].forces_r[i] + f[0].forces_e[i] */
  /* 				  + f[0].forces_ext[i]) */
  /* 			     + 37.*(f[1].forces_m[i] + f[1].forces_l[i] */
  /* 				    + f[1].forces_h[i] + f[1].forces_fk[i] */
  /* 				    + f[1].forces_r[i] + f[1].forces_e[i] */
  /* 				    + f[1].forces_ext[i]) */
  /* 			     - 59.*(f[2].forces_m[i] + f[2].forces_l[i] */
  /* 				    + f[2].forces_h[i] + f[2].forces_fk[i] */
  /* 				    + f[2].forces_r[i] + f[2].forces_e[i] */
  /* 				    + f[2].forces_ext[i]) */
  /* 			     + 55.*(f[3].forces_m[i] + f[3].forces_l[i] */
  /* 				    + f[3].forces_h[i] + f[3].forces_fk[i] */
  /* 				    + f[3].forces_r[i] + f[3].forces_e[i] */
  /* 				    + f[3].forces_ext[i]))); */
  /* } */

  /* for ( i = 0; i < 6; i++) */
  /*   utmp[i] = 0./\* dt/24.*( -9.*f[0].u[i] + 37.*f[1].u[i] *\/ */
  /* 	      /\* 	       - 59.*f[2].u[i] + 55.*f[3].u[i] ) *\/; */

  /* gsl_matrix * M = gsl_matrix_alloc (6,6); */
  /* for ( i = 0; i < 6; i++ ) */
  /*   for ( j = 0; j < 6; j++) */
  /*     gsl_matrix_set (M, i, j, hull->M[j][i]); // M is generaly mass + added_mass */

  /* sim->lu_factorised_solve (sim->mass_lu, du); */

  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] /* + gsl_vector_get (du, i) */;
  
  /* for ( i = 0; i < 3; i++) */
  /*   for ( j = 0; j < 3; j++) */
  /*     m1.x[i] += hull->m.euler_m.a[i][j]*utmp[j]; */
  /* for ( i = 3; i < 6; i++) */
  /*   for ( j = 3; j < 6; j++) */
  /*     m1.x[i] += hull->m.euler_r.a[i-3][j-3]*utmp[j]; */

  update_rotation_matrix (&hull->m, m1.x, m1.u);


  /* Correction */
  Forces f4 = forces_interpolation_new (hull, t+time->dt, time,
					&f[3], f1, m1.u, m1.x, sim, forces, TRUE);

  for ( i = 0; i < 6; i++)
    m1.x[i] = m0.x[i];

  /* for ( i = 0; i < 6; i++) { */
  /*   gsl_vector_set (du, i, */
  /* 		    dt/24.*( (f[1].forces_m[i] + f[1].forces_l[i] */
  /* 			      + f[1].forces_h[i] + f[1].forces_fk[i] */
  /* 			      + f[1].forces_r[i] + f[1].forces_e[i] */
  /* 			      + f[1].forces_ext[i]) */
  /* 			     - 5.*(f[2].forces_m[i] + f[2].forces_l[i] */
  /* 				   + f[2].forces_h[i] + f[2].forces_fk[i] */
  /* 				   + f[2].forces_r[i] + f[2].forces_e[i] */
  /* 				   + f[2].forces_ext[i]) */
  /* 			     + 19.*(f[3].forces_m[i] + f[3].forces_l[i] */
  /* 				    + f[3].forces_h[i] + f[3].forces_fk[i] */
  /* 				    + f[3].forces_r[i] + f[3].forces_e[i] */
  /* 				    + f[3].forces_ext[i]) */
  /* 			     + 9.*(f4.forces_m[i] + f4.forces_l[i] */
  /* 				   + f4.forces_h[i] + f4.forces_fk[i] */
  /* 				   + f4.forces_r[i] + f4.forces_e[i] */
  /* 				   + f4.forces_ext[i]))); */
  /* } */

  /* for ( i = 0; i < 6; i++) */
  /*   utmp[i] = dt/24.*( f[1].u[i] - 5.*f[2].u[i] */
  /* 		       + 19.*f[3].u[i] + 9.*f[3].u[i] ); */

  /* sim->lu_factorised_solve (sim->mass_lu, du); */

  for ( i = 0; i < 6; i++)
    m1.u[i] = m0.u[i] /* + gsl_vector_get (du, i) */;

  /* for ( i = 0; i < 3; i++) */
  /*   for ( j = 0; j < 3; j++) */
  /*     m1.x[i] += hull->m.euler_m.a[i][j]*utmp[j]; */
  /* for ( i = 3; i < 6; i++) */
  /*   for ( j = 3; j < 6; j++) */
  /*     m1.x[i] += hull->m.euler_r.a[i-3][j-3]*utmp[j]; */

  update_rotation_matrix (&hull->m, m1.x, m1.u);

  // Recalculate the forces on the updated geometry for use
  // in following time-steps
  *f1 = forces_interpolation_new (hull, t+time->dt, time,
  				  &f[3], f1, m1.u, m1.x, sim, forces, FALSE);

  return m1;
}

void solve_equation_of_motion_pure_RK4 (Hull * hull,
					Time * time,
					Simulation * sim,
					Forces * f1,
					GSList * forces)
{
  // Initialise with 3 steps of RK4
  g_assert (hull->fh);
  
  // Finds the latest forces in history records
  Forces * f0 = g_slist_last (hull->fh->f)->data;
  hull->m = motion_RK4_time_integration_new  (hull, time, hull->m, f0, f1, sim, forces);

  update_rotation_matrix (&hull->m, hull->m.x, hull->m.u);

  // The integration method requires storage of the first derivatives
  gint i;
  for ( i = 0; i < 6; i++) {
    f1->u[i] = hull->m.u[i];
    f1->x[i] = hull->m.x[i];
  }
  add_force_to_history (hull->fh, *f1);
  g_free (f1);
}

Forces * solve_equation_of_motion_RK4_ABM4 (Hull * hull,
					    Time * time,
					    Simulation * sim,
					    Forces * f1,
					    GSList * forces)
{
  // Initialise with 3 steps of RK4
  g_assert (hull->fh);

  if (time->itime < 4 ) {
    // Finds the latest forces in history records
    Forces * f0 = g_slist_last (hull->fh->f)->data;
    hull->m = motion_RK4_time_integration_new (hull, time, hull->m, f0, f1, sim, forces);
  }
  else {
    hull->m = motion_ABM4_time_integration_new (hull, time, hull->m, hull->fh, f1, sim, forces);
  }

  // Update rotation matrix according to new ship position
  update_rotation_matrix (&hull->m, hull->m.x, hull->m.u);

  // The integration method requires storage of the first derivatives
  gint i;
  for ( i = 0; i < 6; i++) {
    f1->u[i] = hull->m.u[i];
    f1->x[i] = hull->m.x[i];
  }
  add_force_to_history (hull->fh, *f1);
  g_free (f1);

  // Returns pointer for output purposes
  return g_slist_last (hull->fh->f)->data;
}

Forces * solve_equation_of_motion_1dof_RK4_ABM4 (Hull * hull,
						 Time * time,
						 Simulation * sim,
						 Forces * f1,
						 GSList * forces,
						 gint d)
{
  // Initialise with 3 steps of RK4
  g_assert (hull->fh);

  if (time->itime < 4 ) {
    // Finds the latest forces in history records
    Forces * f0 = g_slist_last (hull->fh->f)->data;
    hull->m = motion_1dof_RK4_time_integration_new (hull, time, hull->m, f0, f1, sim, forces, d);
  }
  else {
    hull->m = motion_1dof_ABM4_time_integration_new (hull, time, hull->m, hull->fh, f1, sim, forces, d);
  }

  // Update rotation matrix according to new ship position
  update_rotation_matrix (&hull->m, hull->m.x, hull->m.u);

  // The integration method requires storage of the first derivatives
  gint i;
  for ( i = 0; i < 6; i++) {
    f1->u[i] = hull->m.u[i];
    f1->x[i] = hull->m.x[i];
  }
  add_force_to_history (hull->fh, *f1);
  g_free (f1);

  // Returns pointer for output purposes
  return g_slist_last (hull->fh->f)->data;
}

Forces * solve_no_motion_RK4_ABM4 (Hull * hull,
				   Time * time,
				   Simulation * sim,
				   Forces * f1,
				   GSList * forces)
{
  // Initialise with 3 steps of RK4
  g_assert (hull->fh);

  if (time->itime < 4 ) {
    // Finds the latest forces in history records
    Forces * f0 = g_slist_last (hull->fh->f)->data;
    hull->m = no_motion_RK4_time_integration_new (hull, time, hull->m, f0, f1, sim, forces);
  }
  else {
    hull->m = no_motion_ABM4_time_integration_new (hull, time, hull->m, hull->fh, f1, sim, forces);
  }

  // Update rotation matrix according to new ship position
  update_rotation_matrix (&hull->m, hull->m.x, hull->m.u);

  // The integration method requires storage of the first derivatives
  /* gint i; */
  /* for ( i = 0; i < 6; i++) { */
  /*   f1->u[i] = hull->m.u[i]; */
  /*   f1->x[i] = hull->m.x[i]; */
  /* } */
  add_force_to_history (hull->fh, *f1);
  g_free (f1);

  // Returns pointer for output purposes
  return g_slist_last (hull->fh->f)->data;
}

/*************************************************************/

typedef struct {
  Simulation * sim;
  gdouble total_length;
} GridgenData;

static gdouble gridgen_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  Spline2D * h = spp->sp->hull_patch;
  Simulation * sim = (Simulation *) data;

  gdouble r = 500.;
  
  //v = v < 0.7 ? 0.4*v/0.7 : 0.4+(v-0.7)/0.3*0.6 ;

  // Log scaling in radial direction
  gdouble a = 3.;
  //v = 1. -log(a*v+1.)/log(a+1.);
  //v = 1. -log(a*(1.-v)+1.)/log(a+1.);
  //v = v < 0.6 ? v*0.5/0.6 : 0.5 + (v-0.6)/0.4*0.5;

  //v = v < 0.2 ? v*0.0125/0.2 : 0.0125 + (v-0.2)/0.8*0.9875;

  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  //v = v < 0.2 ? 1.635*v*v+ 0.0125*v : v < 0.75 ? 0.06862 + (v-0.2)/0.55*(0.5-0.06862) : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  /* Point ph = spline2d_eval_point (h, u, 1); */
  /* Point p0 = spline2d_eval_point (h, 0, 1); */
  /* Point p1 = spline2d_eval_point (h, 1, 1); */

  Point ph = spline2d_eval_point (h, 1.-u, 0);
  Point p0 = spline2d_eval_point (h, 1.-0, 0);
  Point p1 = spline2d_eval_point (h, 1.-1, 0);

  /* if (fabs(p0.x - p1.x) < 1.e-5 && fabs(p0.y - p1.y) < 1.e-5 && fabs(p0.z - p1.z) < 1.e-5 ) { */
  /*   fprintf (stderr, "P0: %f %f %f \n", p0.x, p0.y, p0.z); */
  /*   fprintf (stderr, "P0: %f %f %f \n", p1.x, p1.y, p1.z); */
  /* } */
  /* g_assert_not_reached (); */

  Point xg = sim->hull->xg;

  Vector vh;
  vh.x = ph.x - xg.x;
  vh.y = ph.y - xg.y;
  vh.z = ph.z - xg.z;

  Vector v0;
  v0.x = p0.x - xg.x;
  v0.y = p0.y - xg.y;
  v0.z = p0.z - xg.z;

  Vector v1;
  v1.x = p1.x - xg.x;
  v1.y = p1.y - xg.y;
  v1.z = p1.z - xg.z;

  gdouble d = sqrt(vh.x*vh.x + vh.y*vh.y);
  gdouble d0 = sqrt(v0.x*v0.x + v0.y*v0.y);
  gdouble d1 = sqrt(v1.x*v1.x + v1.y*v1.y);

  gdouble theta0 = sign(v0.y)*acos(v0.x/d0);
  gdouble theta1 = sign(v1.y)*acos(v1.x/d1);

  if ((fabs(theta0) - M_PI) < 0.1) {
    theta0 = fabs(theta0)/* M_PI */;
  }

  if ((fabs(theta1) - M_PI) < 0.1) {
    theta1 = -fabs(theta1)/* M_PI; */;
  }

  if ( fabs(theta1) < 0.1 )
    theta1 = 0.;

  if ( fabs(theta0) < 0.1 )
    theta0 = 0.;


  /* if ((fabs(theta0) - M_PI) < 0.01) { */
  /*   theta0 = fabs(theta0); */
  /* } */

  /* if ((fabs(theta1) - M_PI) < 0.01) { */
  /*   theta1 = -fabs(theta1); */
  /* } */
  if ( fabs(theta0 - theta1) < 1e-2 ) {
    // fprintf (stderr, "theta: %e %e \n", theta0, theta1);
    theta1 = theta0 - 2.*M_PI;
    //fprintf (stderr, "theta: %e %e \n", theta0, theta1);
  }
  //g_assert_not_reached ();

  /* if ((fabs(theta0) - M_PI) < 0.1) { */
  /*   theta0 = M_PI; */
  /* } */

  /* if ((fabs(theta1) - M_PI) < 0.1) { */
  /*   theta1 = -M_PI; */
  /* } */

  if (fabs(theta0) < 0.1)
    theta0 = 0.;
  
  if (fabs(theta1) < 0.1)
    theta1 = 0.;
  
  if (fabs(fabs(theta0)-M_PI) < 0.1)
    theta0 = theta0/fabs(theta0)*M_PI;
  
  if (fabs(fabs(theta1)-M_PI) < 0.1)
    theta1 = theta1/fabs(theta1)*M_PI;

  fprintf (stdout, "alpha0: %f %f \n", theta0*180./M_PI, theta1*180./M_PI);

  gdouble theta = theta0 + (theta1-theta0)*(/* 1- */u);

  gdouble xx = sim->wp.r1*cos(theta)+xg.x;
  //xx = sim->wp.r1*(2.+cos(theta))/3.*cos(theta)+xg.x;
  /* gdouble yy = r*sin(theta)+xg.y; */

  //return ph.x + (1.-cos(v*M_PI/2.))*(xx - ph.x);

#if 0
  // First 20% of mesh point stick to the hull
  gdouble xinner = sim->wp.r1_inner*cos(theta)+xg.x;

  gdouble width = 0.2;

  if ( v < width )
    return ph.x + v/width*(xinner-ph.x);
  else 
    return /* ph.x + */ (xinner/* -ph.x */) + (v-width)/(1.-width)*(xx/* -ph.x */-xinner);
#endif

  /* v = v < 0.2 ? v*0.0125/0.2 : 0.0125 + (v-0.2)/0.8*0.9875; */

  return ph.x + (v+1.e-7)/(1.+1.e-7)*(xx - ph.x);
}

static gdouble gridgen_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  Spline2D * h = spp->sp->hull_patch;
  Simulation * sim = (Simulation *) data;

  //v = v < 0.7 ? 0.4*v/0.7 : 0.4+(v-0.7)/0.3*0.6 ;
  // Log scaling in radial direction
  gdouble a = 3.;
  //v = 1. -log(a*v+1.)/log(a+1.);
  //v = 1. -log(a*(1.-v)+1.)/log(a+1.);

  //v = v < 0.2 ? v*0.0125/0.2 : 0.0125 + (v-0.2)/0.8*0.9875;

  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));
  
  //  v = v < 0.2 ? 1.635*v*v+ 0.0125*v : v < 0.75 ? 0.06862 + (v-0.2)/0.55*(0.5-0.06862) : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  //  v = v < 0.6 ? v*0.5/0.6 : 0.5 + (v-0.6)/0.4*0.5;

  /* Point ph = spline2d_eval_point (h, u, 1); */
  /* Point p0 = spline2d_eval_point (h, 0, 1); */
  /* Point p1 = spline2d_eval_point (h, 1, 1); */

  Point ph = spline2d_eval_point (h, 1.-u, 0);
  Point p0 = spline2d_eval_point (h, 1.-0, 0);
  Point p1 = spline2d_eval_point (h, 1.-1, 0);

  Point xg = sim->hull->xg;

  Vector vh;
  vh.x = ph.x - xg.x;
  vh.y = ph.y - xg.y;
  vh.z = ph.z - xg.z;

  Vector v0;
  v0.x = p0.x - xg.x;
  v0.y = p0.y - xg.y;
  v0.z = p0.z - xg.z;

  Vector v1;
  v1.x = p1.x - xg.x;
  v1.y = p1.y - xg.y;
  v1.z = p1.z - xg.z;

  gdouble d = sqrt(vh.x*vh.x + vh.y*vh.y);
  gdouble d0 = sqrt(v0.x*v0.x + v0.y*v0.y);
  gdouble d1 = sqrt(v1.x*v1.x + v1.y*v1.y);

  /* fprintf (stdout, "%f %f %f %f\n", sign(v1.y)*acos(v1.x/d1), sign(v0.y)*acos(v0.x/d0), acos(1), acos(-1)); */

  gdouble theta0 = sign(v0.y)*acos(v0.x/d0);
  gdouble theta1 = sign(v1.y)*acos(v1.x/d1);

  if ((fabs(theta0) - M_PI) < 0.1) {
    theta0 = fabs(theta0)/* M_PI */;
  }

  if ((fabs(theta1) - M_PI) < 0.1) {
    theta1 = -fabs(theta1)/* M_PI */;
  }

  if ( fabs(theta1) < 0.1 )
    theta1 = 0.;

  if ( fabs(theta0) < 0.1 )
    theta0 = 0.;

  if ( fabs(theta0 - theta1) < 1e-2 ) {
    // fprintf (stderr, "theta: %e %e \n", theta0, theta1);
    theta1 = theta0 - 2.*M_PI;
    //fprintf (stderr, "theta: %e %e \n", theta0, theta1);
  }

  /* if ((fabs(theta0) - M_PI) < 0.1) { */
  /*   theta0 = M_PI; */
  /* } */

  /* if ((fabs(theta1) - M_PI) < 0.1) { */
  /*   theta1 = -M_PI; */
  /* } */

  // fprintf (stderr, "theta: %e %e \n", theta0, theta1);

  /* gdouble u2; */
  /* for (u2 = 0; u2 < 1.001; u2 += 0.05) { */
  /*   Point p = spline2d_eval_point (h, u2, 1); */

  /*   fprintf (stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   // fprintf (stdout, "%f %f \n", u, ); */
  /* } */

  /* fprintf (stderr, "%f %f \n", theta0, theta1); */
  /* g_assert_not_reached (); */

  //  gdouble thetacheck = sign(vh.y)*acos(vh.x/d);

  /* g_assert_not_reached (); */

  if (fabs(theta0) < 0.1)
    theta0 = 0.;
  
  if (fabs(theta1) < 0.1)
    theta1 = 0.;
  
  if (fabs(fabs(theta0)-M_PI) < 0.1)
    theta0 = theta0/fabs(theta0)*M_PI;
  
  if (fabs(fabs(theta1)-M_PI) < 0.1)
    theta1 = theta1/fabs(theta1)*M_PI;

  /* fprintf (stderr, "%f %f \n", theta0, theta1); */
  /* g_assert_not_reached (); */

  gdouble theta = theta0 + (theta1-theta0)*(/* 1- */u);

  /* gdouble xx = r*cos(theta)+xg.x; */
  gdouble yy = sim->wp.r2*sin(theta)+xg.y;
  gdouble xx = sim->wp.r2*cos(theta)+xg.y;
  
  gdouble sintheta = (yy-ph.y)/sqrt(pow(xx-ph.x,2.)+pow(yy-ph.y,2.));
  gdouble costheta = (xx-ph.x)/sqrt(pow(xx-ph.x,2.)+pow(yy-ph.y,2.));

#if 0
  gdouble yinner = sim->wp.r2_inner*sin(theta)/* +xg.y; */;

  gdouble width = 0.2;
  

  if ( v < width )
    return ph.y + v/width*(yinner-ph.y);
  else
    return /* ph.y + */ (yinner/* -ph.y */) + (v-width)/(1.-width)*(yy/* -ph.y */-yinner);
#endif

  //v = v < 0.2 ? v*0.0125/0.2 : 0.0125 + (v-0.2)/0.8*0.9875;

  //return ph.y + (1.-cos(v*M_PI/2.))*(yy - ph.y);
  return ph.y + (v+1.e-7)/(1.+1.e-7)*(yy - ph.y);
}

static gdouble gridgen_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  Spline2D * h = spp->sp->hull_patch;
  Simulation * sim = (Simulation *) data;


  

  // Log scaling in radial direction
  gdouble a = 3.;


  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));



  Point ph = spline2d_eval_point (h, 1.-u, 0);
  //Vector Nh = spline2d_normal (h, 1.-u, 0);
  Point p0 = spline2d_eval_point (h, 1.-0, 0);
  Point p1 = spline2d_eval_point (h, 1.-1, 0);



  Point xg = sim->hull->xg;

  Vector vh;
  vh.x = ph.x - xg.x;
  vh.y = ph.y - xg.y;
  vh.z = ph.z - xg.z;

  Vector v0;
  v0.x = p0.x - xg.x;
  v0.y = p0.y - xg.y;
  v0.z = p0.z - xg.z;

  Vector v1;
  v1.x = p1.x - xg.x;
  v1.y = p1.y - xg.y;
  v1.z = p1.z - xg.z;

  gdouble d = sqrt(vh.x*vh.x + vh.y*vh.y);
  gdouble d0 = sqrt(v0.x*v0.x + v0.y*v0.y);
  gdouble d1 = sqrt(v1.x*v1.x + v1.y*v1.y);

  gdouble theta0 = sign(v0.y)*acos(v0.x/d0);
  gdouble theta1 = sign(v1.y)*acos(v1.x/d1);

  //  fprintf (stdout, "tt %f %f \n", theta0*180./M_PI, theta1*180./M_PI);

  if (fabs(theta0) < 0.01)
    theta0 = 0.;

  if (fabs(theta1) < 0.01)
    theta1 = 0.;

  if (fabs(fabs(theta0) - M_PI) < 0.1)
    theta0 = sign(theta0)*M_PI;

  if (fabs(fabs(theta1) - M_PI) < 0.1)
    theta1 = sign(theta1)*M_PI;

  if (theta1 >= theta0)
    theta1 -= 2*M_PI;
  //fprintf (stdout, "tt2 %f %f \n", theta0*180./M_PI, theta1*180./M_PI);

  //fprintf (stdout, "alpha0: %f %f \n", theta0*180./M_PI, theta1*180./M_PI);

  gdouble theta = theta0 + (theta1-theta0)*(/* 1- */u);

  gdouble xx = sim->wp.r1*cos(theta)+xg.x;
  gdouble yy = sim->wp.r2*sin(theta)+xg.y;

  //g_assert_not_reached ();

  gdouble sintheta = (yy-ph.y)/sqrt(pow(xx-ph.x,2.)+pow(yy-ph.y,2.));
  gdouble costheta = (xx-ph.x)/sqrt(pow(xx-ph.x,2.)+pow(yy-ph.y,2.));


 #if 0
  // First 20% of mesh point stick to the hull
  gdouble rinner = 1./sqrt(pow(costheta/sim->wp.r1_inner,2.) + pow(sintheta/sim->wp.r2_inner,2.) );

  //  gdouble yinner = sim->wp.r2_inner*sin(theta)/* +xg.y; */;

  gdouble xinner = rinner*costheta;


  //gdouble xinner = sim->wp.r1_inner*cos(theta)+xg.x;

  gdouble width = 0.2;

  if ( v < width )
    return ph.x + v/width*(xinner-ph.x);
  else 
    return /* ph.x + */ (xinner/* -ph.x */) + (v-width)/(1.-width)*(xx/* -ph.x */-xinner);
#endif

  gdouble r1 = sim->wp.r1_inner;
  gdouble r2 = sim->wp.r2_inner;
  gdouble aa = ph.x;
  gdouble bb = xx-ph.x;
  gdouble cc = ph.y;
  gdouble dd = yy-ph.y;

  // solve ((a+b*v)/r1)^2 + ((c+d*v)/r2)^2 = 1

  gdouble x1 = -(r1*r2*sqrt(bb*bb*r2*r2+d*d*r1-aa*aa*dd*dd+2*aa*bb*cc*dd-bb*bb*cc*cc) + aa*bb*r2*r2+cc*dd*r1*r1)/(bb*bb*r2*r2+dd*dd*r1*r1);
  gdouble x2 = (r1*r2*sqrt(bb*bb*r2*r2+dd*dd*r1*r1-aa*aa*dd*dd+2*aa*bb*cc*dd-bb*bb*cc*cc)-aa*bb*r2*r2-cc*dd*r1*r1)/(bb*bb*r2*r2+dd*dd*r1*r1);

  x1 = - (r1*r2*sqrt(- bb*bb*xg.y*xg.y  + (2.*bb*dd*xg.x - 2*aa*bb*dd + 2*bb*bb*cc)*xg.y - dd*dd*xg.x*xg.x
 + (2*aa*dd*dd  - 2*bb *cc*dd)* xg.x + bb*bb*r2*r2  + dd*dd*r1*r1  - aa*aa*dd*dd  + 2*aa*bb*cc*dd - bb*bb*cc*cc )
     - dd*r1*r1*xg.y - bb*r2*r2*xg.x + aa*bb*r2*r2  + cc*dd*r1*r1 )/(bb*bb*r2*r2  + dd*dd*r1*r1 );

  x2 = (r1*r2*sqrt(-bb*bb*xg.y*xg.y  + (2*bb*dd*xg.x - 2*aa*bb*dd + 2*bb*bb*cc)*xg.y - dd*dd*xg.x*xg.x
   + (2*aa*dd*dd  - 2*bb*cc*dd)*xg.x + bb*bb*r2*r2  + dd*dd*r1*r1  - aa*aa*dd*dd  + 2*aa*bb*cc*dd - bb*bb*cc*cc )
	+ dd*r1*r1*xg.y + bb*r2*r2*xg.x - aa*bb*r2*r2  - cc*dd*r1*r1)/(bb*bb*r2*r2  + dd*dd*r1*r1 );


  gdouble vnew;
  if (v < 0.2)
    vnew=v/0.2*MAX(x1,x2);
  else 
    vnew=MAX(x1,x2)+(v-0.2)/0.8*(1-MAX(x1,x2));

  v = pow(v,1.2)*v + pow(1-v,1.2)*vnew;

  /* if (v < 0.6) */
  /*   v = pow(v/0.6,2)*v + pow(0.6-v,2)/0.6*vnew; */

  /* if (v < 0.4) */
  /*   v = pow(v/0.4,2)*v + pow(0.4-v,2)/0.4*vnew; */

  return ph.x + (v+1.e-7)/(1.+1.e-7)*(xx - ph.x);
}

static gdouble gridgen_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  Spline2D * h = spp->sp->hull_patch;
  Simulation * sim = (Simulation *) data;

  //v = v < 0.7 ? 0.4*v/0.7 : 0.4+(v-0.7)/0.3*0.6 ;
  // Log scaling in radial direction
  gdouble a = 3.;
  //v = 1. -log(a*v+1.)/log(a+1.);
  //v = 1. -log(a*(1.-v)+1.)/log(a+1.);

  //v = v < 0.2 ? v*0.0125/0.2 : 0.0125 + (v-0.2)/0.8*0.9875;

  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));
  
  //  v = v < 0.2 ? 1.635*v*v+ 0.0125*v : v < 0.75 ? 0.06862 + (v-0.2)/0.55*(0.5-0.06862) : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  //  v = v < 0.6 ? v*0.5/0.6 : 0.5 + (v-0.6)/0.4*0.5;

  /* Point ph = spline2d_eval_point (h, u, 1); */
  /* Point p0 = spline2d_eval_point (h, 0, 1); */
  /* Point p1 = spline2d_eval_point (h, 1, 1); */

  Point ph = spline2d_eval_point (h, 1.-u, 0);
  Point p0 = spline2d_eval_point (h, 1.-0, 0);
  Point p1 = spline2d_eval_point (h, 1.-1, 0);

  Point xg = sim->hull->xg;

  Vector vh;
  vh.x = ph.x - xg.x;
  vh.y = ph.y - xg.y;
  vh.z = ph.z - xg.z;

  Vector v0;
  v0.x = p0.x - xg.x;
  v0.y = p0.y - xg.y;
  v0.z = p0.z - xg.z;

  Vector v1;
  v1.x = p1.x - xg.x;
  v1.y = p1.y - xg.y;
  v1.z = p1.z - xg.z;

  gdouble d = sqrt(vh.x*vh.x + vh.y*vh.y);
  gdouble d0 = sqrt(v0.x*v0.x + v0.y*v0.y);
  gdouble d1 = sqrt(v1.x*v1.x + v1.y*v1.y);

  /* fprintf (stdout, "%f %f %f %f\n", sign(v1.y)*acos(v1.x/d1), sign(v0.y)*acos(v0.x/d0), acos(1), acos(-1)); */

  gdouble theta0 = sign(v0.y)*acos(v0.x/d0);
  gdouble theta1 = sign(v1.y)*acos(v1.x/d1);

  if (fabs(theta0) < 0.01)
    theta0 = 0.;

  if (fabs(theta1) < 0.01)
    theta1 = 0.;

  if (fabs(fabs(theta0) - M_PI) < 0.1)
    theta0 = sign(theta0)*M_PI;

  if (fabs(fabs(theta1) - M_PI) < 0.1)
    theta1 = sign(theta1)*M_PI;

  if (theta1 >= theta0)
    theta1 -= 2*M_PI;

#if 0
  if ((fabs(theta0) - M_PI) < 0.1) {
    theta0 = fabs(theta0)/* M_PI */;
  }

  if ((fabs(theta1) - M_PI) < 0.1) {
    theta1 = -fabs(theta1)/* M_PI */;
  }

  if ( fabs(theta1) < 0.1 )
    theta1 = 0.;

  if ( fabs(theta0) < 0.1 )
    theta0 = 0.;

  if ( fabs(theta0 - theta1) < 1e-2 ) {
    // fprintf (stderr, "theta: %e %e \n", theta0, theta1);
    theta1 = theta0 - 2.*M_PI;
    //fprintf (stderr, "theta: %e %e \n", theta0, theta1);
  }

  /* if ((fabs(theta0) - M_PI) < 0.1) { */
  /*   theta0 = M_PI; */
  /* } */

  /* if ((fabs(theta1) - M_PI) < 0.1) { */
  /*   theta1 = -M_PI; */
  /* } */

  // fprintf (stderr, "theta: %e %e \n", theta0, theta1);

  /* gdouble u2; */
  /* for (u2 = 0; u2 < 1.001; u2 += 0.05) { */
  /*   Point p = spline2d_eval_point (h, u2, 1); */

  /*   fprintf (stdout, "%f %f %f \n", p.x, p.y, p.z); */
  /*   // fprintf (stdout, "%f %f \n", u, ); */
  /* } */

  /* fprintf (stderr, "%f %f \n", theta0, theta1); */
  /* g_assert_not_reached (); */

  //  gdouble thetacheck = sign(vh.y)*acos(vh.x/d);

  /* g_assert_not_reached (); */

  if (fabs(theta0) < 0.1)
    theta0 = 0.;
  
  if (fabs(theta1) < 0.1)
    theta1 = 0.;
  
  if (fabs(fabs(theta0)-M_PI) < 0.1)
    theta0 = theta0/fabs(theta0)*M_PI;
  
  if (fabs(fabs(theta1)-M_PI) < 0.1)
    theta1 = theta1/fabs(theta1)*M_PI;
#endif
  /* fprintf (stderr, "%f %f \n", theta0, theta1); */
  /* g_assert_not_reached (); */

  gdouble theta = theta0 + (theta1-theta0)*(/* 1- */u);

  /* gdouble xx = r*cos(theta)+xg.x; */
  gdouble yy = sim->wp.r2*sin(theta)+xg.y;
  gdouble xx = sim->wp.r1*cos(theta)+xg.x;
  
  gdouble sintheta = (yy-ph.y)/sqrt(pow(xx-ph.x,2.)+pow(yy-ph.y,2.));
  gdouble costheta = (xx-ph.x)/sqrt(pow(xx-ph.x,2.)+pow(yy-ph.y,2.));

#if 0
  gdouble rinner = 1./sqrt(pow(costheta/sim->wp.r1_inner,2.) + pow(sintheta/sim->wp.r2_inner,2.) );

  //  gdouble yinner = sim->wp.r2_inner*sin(theta)/* +xg.y; */;

  gdouble yinner = rinner*sintheta;

  gdouble width = 0.2;
  

  if ( v < width )
    return ph.y + v/width*(yinner-ph.y);
  else
    return /* ph.y + */ (yinner/* -ph.y */) + (v-width)/(1.-width)*(yy/* -ph.y */-yinner);
#endif

  gdouble r1 = sim->wp.r1_inner;
  gdouble r2 = sim->wp.r2_inner;
  gdouble aa = ph.x;
  gdouble bb = xx-ph.x;
  gdouble cc = ph.y;
  gdouble dd = yy-ph.y;

  // solve ((a+b*v)/r1)^2 + ((c+d*v)/r2)^2 = 1
  gdouble x1 = -(r1*r2*sqrt(bb*bb*r2*r2+d*d*r1-aa*aa*dd*dd+2*aa*bb*cc*dd-bb*bb*cc*cc) + aa*bb*r2*r2+cc*dd*r1*r1)/(bb*bb*r2*r2+dd*dd*r1*r1);
  gdouble x2 = (r1*r2*sqrt(bb*bb*r2*r2+dd*dd*r1*r1-aa*aa*dd*dd+2*aa*bb*cc*dd-bb*bb*cc*cc)-aa*bb*r2*r2-cc*dd*r1*r1)/(bb*bb*r2*r2+dd*dd*r1*r1);

  x1 = - (r1*r2*sqrt(- bb*bb*xg.y*xg.y  + (2.*bb*dd*xg.x - 2*aa*bb*dd + 2*bb*bb*cc)*xg.y - dd*dd*xg.x*xg.x
 + (2*aa*dd*dd  - 2*bb *cc*dd)* xg.x + bb*bb*r2*r2  + dd*dd*r1*r1  - aa*aa*dd*dd  + 2*aa*bb*cc*dd - bb*bb*cc*cc )
     - dd*r1*r1*xg.y - bb*r2*r2*xg.x + aa*bb*r2*r2  + cc*dd*r1*r1 )/(bb*bb*r2*r2  + dd*dd*r1*r1 );

  x2 = (r1*r2*sqrt(-bb*bb*xg.y*xg.y  + (2*bb*dd*xg.x - 2*aa*bb*dd + 2*bb*bb*cc)*xg.y - dd*dd*xg.x*xg.x
   + (2*aa*dd*dd  - 2*bb*cc*dd)*xg.x + bb*bb*r2*r2  + dd*dd*r1*r1  - aa*aa*dd*dd  + 2*aa*bb*cc*dd - bb*bb*cc*cc )
	+ dd*r1*r1*xg.y + bb*r2*r2*xg.x - aa*bb*r2*r2  - cc*dd*r1*r1)/(bb*bb*r2*r2  + dd*dd*r1*r1 );

  gdouble vnew;
  if (v < 0.2)
    vnew=v/0.2*MAX(x1,x2);
  else 
    vnew=MAX(x1,x2)+(v-0.2)/0.8*(1-MAX(x1,x2));

  /* if (v < 0.6) */
    /* v = pow(v/0.6,2)*v + pow(0.6-v,2)/0.6*vnew; */
  v = pow(v,1.2)*v + pow(1-v,1.2)*vnew;
  

  /* if (v < 0.4) */
  /*   v = pow(v/0.4,2)*v + pow(0.4-v,2)/0.4*vnew; */

  //v = (v/0.4)*v + (0.4-v)/0.4*vnew;

  //v = v < 0.2 ? v*0.0125/0.2 : 0.0125 + (v-0.2)/0.8*0.9875;

  //return ph.y + (1.-cos(v*M_PI/2.))*(yy - ph.y);
  return ph.y + (v+1.e-7)/(1.+1.e-7)*(yy - ph.y + xg.y);
}

static gdouble gridgen_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  return  0.;
}

void build_free_surface (Simulation * sim,
			 gint k, gint ninner, gint nouter)
{

  // Build free surface from wet hull
  GSList * patches = sim->hull->wet_patches;

  Spline2D * fs = NULL;

  while (patches) {
    Spline2D * sp = patches->data;
    while (sp) {
      if (!sp->fully_submerged) {
	Spline2D * s = periodic_fs_new (sp->M, sim->N, k,
					ninner, nouter);

	coeff_set_var_to_zero (s, 0);
	coeff_set_var_to_zero (s, 1);
	coeff_set_var_to_zero (s, 2);

	s->noflux = FALSE;
	periodic_fs_init_panels (s);
	s->hull_patch = sp;
	
	if (fs == NULL)
	  fs = s;
	else {
	  Spline2D * end = fs;
	  
	  while (end->next != NULL)
	    end = end->next;
	  
	  end->next = s;
	}
      }
      sp = sp->next;
    }
    patches = patches->next;
  }

  CCSProblem * fit = periodic_fs_build_galerkin_fit_matrix_no_metric (fs);
  gsl_vector * rhs_x = periodic_fs_build_galerkin_rhs_gauss_no_metric (fs, gridgen_x/* 2 */, sim, NULL, NULL);
  gsl_vector * rhs_y = periodic_fs_build_galerkin_rhs_gauss_no_metric (fs, gridgen_y/* 2 */, sim, NULL, NULL);
  gsl_vector * rhs_z = periodic_fs_build_galerkin_rhs_gauss_no_metric (fs, gridgen_z, sim, NULL, NULL);
  
  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);

  periodic_fs_copy_problem_solution_no_metric (fs, rhs_x, 0);
  periodic_fs_copy_problem_solution_no_metric (fs, rhs_y, 1);
  periodic_fs_copy_problem_solution_no_metric (fs, rhs_z, 2);

  // Copy the splines coeffs to have exactly matching boundaries
  //=>
  Spline2D * sp = fs;
  gint i, j = 0;
  while (sp) {
    for ( i = 0; i < sp->NXU; i++) {
      SplineCoeffs * sc1 = g_ptr_array_index (sp->coeffs, i + j*sp->NXU);
      SplineCoeffs * sc2 = g_ptr_array_index (sp->hull_patch->coeffs, sp->NXU -1 - i + j*sp->NXU);
      sc1->v[0] = sc2->v[0];
      sc1->v[1] = sc2->v[1];
      //sc1->v[2] = sc2->v[2]; // Don't impose anything as already zero
      sc2->v[2] = 0.; // Make sure the edges of the hull are really at z = 0.
    }
    sp = sp->next;
  }
  
 
  periodic_fs_reinit_panels_physical_quantities (fs);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  periodic_fs_numbering (fs);

  // 50 iteration of elliptic smoothing
  for ( i = 0; i < 0; i++)
    periodic_fs_elliptic_smoothing (fs);

  //spline2d_elliptic_smoothing (fs);

  sim->fs->s->patches = g_slist_append (sim->fs->s->patches, fs);
}


/*************************************************************/

static gdouble m_x (gdouble t)
{
  gdouble xi = 2.;
  gdouble w = M_PI;

  gdouble phi = atan(2*xi*w/(w*w-1));

  return -phi/fabs(phi)*1./sqrt(pow(1-w*w, 2.) + pow(2*xi*w,2.))*cos(w*t+phi)
    + exp(-xi*t)*(exp(t*sqrt(xi*xi-1)) + exp(-t*sqrt(xi*xi-1)));
}

static void test_seb (Simulation * sim)
{
  test_abm ();
  

  /* Create the connected spline patch */

  Spline2D * s /* = periodic_fs_new (10, 10, 3, 3, 4) */;

  sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (10, 10, 3, 4, 2, 1.));
  s = sim->hull->patches->data;

  //Spline2D * s = spline2d_new (100, 35, 3, 3, 3);
  
  FILE * fp = fopen ("hull.out","w");
  //spline2d_print_panels (sim->hull->patches->data, fp);
  hull_print (sim->hull, fp);
  fclose (fp);
  fprintf (stderr, "Hull printed\n");


  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;

  sim->hull->mg = 2./3.*M_PI*1000;
  sim->rho = 1000;
  sim->g = 9.81;

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  g_assert_not_reached ();

  gint i, j;
  
  
  periodic_fs_init_panels (s);

  //spline2d_init_panels (s);

 

  CCSProblem * fit = s->build_fit_matrix (s);

  gsl_vector * rhs_x = s->build_fit_rhs (s, sphere_x2, NULL,
					 NULL, NULL, rhs_x);
  gsl_vector * rhs_y = s->build_fit_rhs (s, sphere_y2, NULL,
					 NULL, NULL, rhs_y);
  gsl_vector * rhs_z = s->build_fit_rhs (s, sphere_z2, NULL,
					 NULL, NULL, rhs_z);
  
  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);

  s->copy_fit_solution (s, rhs_x, 0);
  s->copy_fit_solution (s, rhs_y, 1);
  s->copy_fit_solution (s, rhs_z, 2);
  
  periodic_fs_reinit_panels_physical_quantities (s);
  //spline2d_reinit_panels_physical_quantities (s);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  Motion m;
  /* Matrix3 euler_m; */
  /* Point xg; */
  /* // Vector t; */

  /* xg.x = xg.y = xg.z = 0.; */

  for ( i = 0; i < 3; i++) {
    m.x[i] = 0.;
  }

  /* m.x[2] = 0.5; */

  /* m.x[3] = M_PI/2.; */
  //m.x[4] = M_PI/2.;


  /* motion_update_euler_matrix (&m); */

  initialise_motion (sim);

  Hull * hull = sim->hull;
  hull->m.x[2] = 2.;
  hull->m.v[2] = -4.;
  hull->m.u[2] = -4.;

  FILE * fmotion = fopen ("motion.tmp","w");

  gdouble t = 0., dt = sim->time.dt = 0.001;
  sim->time.itime = 0;
  fprintf (fmotion, "%f %f %f \n", t, hull->m.x[2], m_x(0.));
  
  hull->mg = 1.;
  hull->Ig[0][0] = hull->Ig[1][1] = hull->Ig[2][2] = 1.;
  hull->Ig[0][1] = hull->Ig[1][0] = hull->Ig[2][0] = 0.;
  hull->Ig[0][2] = hull->Ig[1][2] = hull->Ig[2][1] = 0.;

  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) {
      hull->M[i][j] = 0.;
    }
  }

  for ( i = 0; i < 6; i++ )
    hull->M[i][i] = 1.;



  for ( t = t; t < 100; t += dt) {
    sim->time.t = t;
    //solve_equation_of_motion (sim->hull, &sim->time, sim);

    Forces * f1 = g_malloc (sizeof(Forces));
    gdouble t = sim->time.t;
    gdouble dt = sim->time.dt;
    gdouble xi = 2;
    gdouble omega = M_PI;
    forces_set_to_zero (f1);
    //  f1.forces_m[1] = -2.*xi*v - x + cos(omega*(t+dt));
    f1->forces_m[2] = -2.*xi*hull->m.u[2] - hull->m.x[2] + cos(omega*(t+dt));
    f1->u[2] = sim->hull->m.u[2];

    solve_equation_of_motion_pure_RK4 (sim->hull, &sim->time, sim, f1, NULL);

    fprintf (fmotion, "%f %f %f %f \n", t+dt, hull->m.x[2]*180/M_PI,m_x(t+dt)*180/M_PI, hull->m.u[2]);

    if ( sim->time.itime%100 == 0 ) {
      /* FILE *  */fp = fopen ("spline.tmp","w");

      spline2d_print_transformed_panels (s, fp, &hull->xg, &hull->m.t, &hull->m.euler_m);
      fclose (fp);
      fp = fopen ("normals.tmp","w");
      spline2d_print_transformed_normals (s, fp, &hull->xg, &hull->m.t, &hull->m.euler_m);
      fclose (fp);
      sleep (1);
    }
    sim->time.itime++;
  }

  fprintf (stdout, "Time %f Error: %e \n", t, fabs(hull->m.x[4]-m_x(t)));

  fclose (fmotion);

  
   //spline2d_print_panels (s, fp);
  
  
  /* for ( i = 0; i < s->M; i++) { */
  /*   for ( j = 0; j < s->N; j++) { */
  /*     SPPanel * spp = g_ptr_array_index (s->panels, i + j*s->M); */
  /*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u0, spp->v0, 0), */
  /* 	      spline2d_eval (s , spp->u0, spp->v0, 1), spline2d_eval (s, spp->u0, spp->v0, 2), */
  /* 	      spline2d_derivative_eval (s, spp->u0, spp->v0, 0, 1, 2), spp->u0, spp->v0); */
  /*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u1, spp->v0, 0), */
  /* 	      spline2d_eval (s, spp->u1, spp->v0, 1), spline2d_eval (s, spp->u1, spp->v0, 2), */
  /* 	      spline2d_derivative_eval (s, spp->u1, spp->v0, 0, 1, 2), spp->u1, spp->v0); */
  /*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u1, spp->v1, 0), */
  /* 	      spline2d_eval (s, spp->u1, spp->v1, 1), spline2d_eval (s, spp->u1, spp->v1, 2), */
  /* 	      spline2d_derivative_eval (s, spp->u1, spp->v1, 0, 1, 2), spp->u1, spp->v1); */
  /*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u0, spp->v1, 0), */
  /* 	      spline2d_eval (s, spp->u0, spp->v1, 1), spline2d_eval (s, spp->u0, spp->v1, 2), */
  /* 	      spline2d_derivative_eval (s, spp->u0, spp->v1, 0, 1, 2), spp->u0, spp->v1); */
  /*     fprintf(fp, "%f %f %f %f %f %f \n\n\n", spline2d_eval (s, spp->u0, spp->v0, 0), */
  /* 	      spline2d_eval (s, spp->u0, spp->v0, 1), spline2d_eval (s, spp->u0, spp->v0, 2), */
  /* 	      spline2d_derivative_eval (s, spp->u0, spp->v0, 0, 1, 2), spp->u0, spp->v0); */
      
  /*   } */
  /* } */

  //fclose (fp);
  /* FILE * */ fp = fopen ("normals.tmp","w");
  
  spline2d_print_transformed_normals (s, fp, &hull->xg, &m.t, &m.euler_m);
   
  //   spline2d_print_normals (s, fp);
    
  fclose (fp);
}

static void test_hull (Simulation * sim)
{
  FILE * fp = fopen ("1704B.tmp","r");
  float x, y, z;
  DCurve * dc;
  GSList * dcs = NULL;

  GSList * points = NULL;

  while (fscanf(fp, "%f %f %f\n", &x, &y, &z) != EOF) {
    Point * p = g_malloc (sizeof(Point));
    p->x = x;
    p->y = y;
    p->z = z;
    points = g_slist_append (points, p);
  }

  /* while (points) { */
  /*   Point * pp = points->data; */
  /*   fprintf(stdout, "%f %f %f \n", pp->x, pp->y, pp->z); */
  /*   points = points->next; */
  /* } */

  BCurve * bc =  bcurve_fit_point_list (points);

  gdouble i;
  for ( i = 0.; i <= 1.; i += 0.02 ) {
    Point pp = bcurve_eval (i, bc);
    fprintf (stdout, "%f %f %f \n", pp.x, pp.y, pp.z);
  }

  fclose (fp);


  /* /\* Create the connected spline patch *\/ */

  /* Spline2D * s /\* = periodic_fs_new (10, 10, 3, 3, 4) *\/; */

  /* sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (10, 10, 3, 4, 2, 1.)); */
  /* s = sim->hull->patches->data; */

  /* //Spline2D * s = spline2d_new (100, 35, 3, 3, 3); */
  


  /* gint i, j; */
  
  
  /* periodic_fs_init_panels (s); */

  /* //spline2d_init_panels (s); */

 

  /* CCSProblem * fit = s->build_fit_matrix (s); */

  /* gsl_vector * rhs_x = s->build_fit_rhs (s, sphere_x2, NULL, */
  /* 					 NULL, NULL); */
  /* gsl_vector * rhs_y = s->build_fit_rhs (s, sphere_y2, NULL, */
  /* 					 NULL, NULL); */
  /* gsl_vector * rhs_z = s->build_fit_rhs (s, sphere_z2, NULL, */
  /* 					 NULL, NULL); */
  
  /* ccs_problem_lu_solve (fit, rhs_x); */
  /* ccs_problem_lu_solve (fit, rhs_y); */
  /* ccs_problem_lu_solve (fit, rhs_z); */

  /* s->copy_fit_solution (s, rhs_x, 0); */
  /* s->copy_fit_solution (s, rhs_y, 1); */
  /* s->copy_fit_solution (s, rhs_z, 2); */
  
  /* periodic_fs_reinit_panels_physical_quantities (s); */
  /* //spline2d_reinit_panels_physical_quantities (s); */

  /* gsl_vector_free (rhs_x); */
  /* gsl_vector_free (rhs_y); */
  /* gsl_vector_free (rhs_z); */
  /* ccs_problem_destroy (fit); */

  /* Motion m; */
  /* /\* Matrix3 euler_m; *\/ */
  /* /\* Point xg; *\/ */
  /* /\* // Vector t; *\/ */

  /* xg.x = xg.y = xg.z = 0.; */

  /* for ( i = 0; i < 3; i++) { */
  /*   m.x[i] = 0.; */
  /* } */

  /* /\* m.x[2] = 0.5; *\/ */

  /* /\* m.x[3] = M_PI/2.; *\/ */
  /* //m.x[4] = M_PI/2.; */


  /* /\* motion_update_euler_matrix (&m); *\/ */

  /* initialise_motion (sim); */

  /* Hull * hull = sim->hull; */
  /* hull->m.x[2] = 2.; */
  /* hull->m.v[2] = -4.; */
  /* hull->m.u[2] = -4.; */

  /* FILE * fmotion = fopen ("motion.tmp","w"); */

  /* gdouble t = 0., dt = sim->time.dt = 0.001; */
  /* sim->time.itime = 0; */
  /* fprintf (fmotion, "%f %f %f \n", t, hull->m.x[2], m_x(0.)); */
  
  /* hull->mg = 1.; */
  /* hull->Ig[0][0] = hull->Ig[1][1] = hull->Ig[2][2] = 1.; */
  /* hull->Ig[0][1] = hull->Ig[1][0] = hull->Ig[2][0] = 0.; */
  /* hull->Ig[0][2] = hull->Ig[1][2] = hull->Ig[2][1] = 0.; */

  /* for ( i = 0; i < 6; i++ ) { */
  /*   for ( j = 0; j < 6; j++ ) { */
  /*     hull->M[i][j] = 0.; */
  /*   } */
  /* } */

  /* for ( i = 0; i < 6; i++ ) */
  /*   hull->M[i][i] = 1.; */



  /* for ( t = t; t < 100; t += dt) { */
  /*   sim->time.t = t; */
  /*   //solve_equation_of_motion (sim->hull, &sim->time, sim); */

  /*   Forces * f1 = g_malloc (sizeof(Forces)); */
  /*   gdouble t = sim->time.t; */
  /*   gdouble dt = sim->time.dt; */
  /*   gdouble xi = 2; */
  /*   gdouble omega = M_PI; */
  /*   forces_set_to_zero (f1); */
  /*   //  f1.forces_m[1] = -2.*xi*v - x + cos(omega*(t+dt)); */
  /*   f1->forces_m[2] = -2.*xi*hull->m.u[2] - hull->m.x[2] + cos(omega*(t+dt)); */
  /*   f1->u[2] = sim->hull->m.u[2]; */

  /*   solve_equation_of_motion_pure_RK4 (sim->hull, &sim->time, sim, f1); */

  /*   fprintf (fmotion, "%f %f %f %f \n", t+dt, hull->m.x[2]*180/M_PI,m_x(t+dt)*180/M_PI, hull->m.u[2]); */

  /*   if ( sim->time.itime%100 == 0 ) { */
  /*     FILE * fp = fopen ("spline.tmp","w"); */

  /*     spline2d_print_transformed_panels (s, fp, &hull->xg, &hull->m.t, &hull->m.euler_m); */
  /*     fclose (fp); */
  /*     fp = fopen ("normals.tmp","w"); */
  /*     spline2d_print_transformed_normals (s, fp, &hull->xg, &hull->m.t, &hull->m.euler_m); */
  /*     fclose (fp); */
  /*     sleep (1); */
  /*   } */
  /*   sim->time.itime++; */
  /* } */

  /* fprintf (stdout, "Time %f Error: %e \n", t, fabs(hull->m.x[4]-m_x(t))); */

  /* fclose (fmotion); */

  
  /*  //spline2d_print_panels (s, fp); */
  
  
  /* /\* for ( i = 0; i < s->M; i++) { *\/ */
  /* /\*   for ( j = 0; j < s->N; j++) { *\/ */
  /* /\*     SPPanel * spp = g_ptr_array_index (s->panels, i + j*s->M); *\/ */
  /* /\*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u0, spp->v0, 0), *\/ */
  /* /\* 	      spline2d_eval (s , spp->u0, spp->v0, 1), spline2d_eval (s, spp->u0, spp->v0, 2), *\/ */
  /* /\* 	      spline2d_derivative_eval (s, spp->u0, spp->v0, 0, 1, 2), spp->u0, spp->v0); *\/ */
  /* /\*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u1, spp->v0, 0), *\/ */
  /* /\* 	      spline2d_eval (s, spp->u1, spp->v0, 1), spline2d_eval (s, spp->u1, spp->v0, 2), *\/ */
  /* /\* 	      spline2d_derivative_eval (s, spp->u1, spp->v0, 0, 1, 2), spp->u1, spp->v0); *\/ */
  /* /\*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u1, spp->v1, 0), *\/ */
  /* /\* 	      spline2d_eval (s, spp->u1, spp->v1, 1), spline2d_eval (s, spp->u1, spp->v1, 2), *\/ */
  /* /\* 	      spline2d_derivative_eval (s, spp->u1, spp->v1, 0, 1, 2), spp->u1, spp->v1); *\/ */
  /* /\*     fprintf(fp, "%f %f %f %f %f %f \n", spline2d_eval (s, spp->u0, spp->v1, 0), *\/ */
  /* /\* 	      spline2d_eval (s, spp->u0, spp->v1, 1), spline2d_eval (s, spp->u0, spp->v1, 2), *\/ */
  /* /\* 	      spline2d_derivative_eval (s, spp->u0, spp->v1, 0, 1, 2), spp->u0, spp->v1); *\/ */
  /* /\*     fprintf(fp, "%f %f %f %f %f %f \n\n\n", spline2d_eval (s, spp->u0, spp->v0, 0), *\/ */
  /* /\* 	      spline2d_eval (s, spp->u0, spp->v0, 1), spline2d_eval (s, spp->u0, spp->v0, 2), *\/ */
  /* /\* 	      spline2d_derivative_eval (s, spp->u0, spp->v0, 0, 1, 2), spp->u0, spp->v0); *\/ */
      
  /* /\*   } *\/ */
  /* /\* } *\/ */

  /* //fclose (fp); */
  /* FILE * fp = fopen ("normals.tmp","w"); */
  
  /* spline2d_print_transformed_normals (s, fp, &xg, &m.t, &m.euler_m); */
   
  /* //   spline2d_print_normals (s, fp); */
    
  /* fclose (fp); */
}

Spline2D * periodic_sphere (gint M, gint N, gint k, gint ninner, gint nouter, gdouble r)
{
  /* Create the connected spline patch */
  Spline2D * s = periodic_fs_new (M, N, k, ninner, nouter);
  s->noflux = FALSE;
  
  periodic_fs_init_panels (s);

  Spline2D * s2 = periodic_fs_new (M, N, k, ninner, nouter);
  s2->noflux = FALSE;
  periodic_fs_init_panels (s2);
  s->next = s2;


  CCSProblem * fit = periodic_fs_build_galerkin_fit_matrix_no_metric (s);

  gsl_vector * rhs_x = periodic_fs_build_galerkin_rhs_gauss_no_metric (s, sphere_x2, &r, NULL, NULL);
  gsl_vector * rhs_y = periodic_fs_build_galerkin_rhs_gauss_no_metric (s, sphere_y2, &r, NULL, NULL);
  gsl_vector * rhs_z = periodic_fs_build_galerkin_rhs_gauss_no_metric (s, sphere_z2, &r, NULL, NULL);
  
  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);  

  periodic_fs_copy_problem_solution_no_metric (s, rhs_x, 0);
  periodic_fs_copy_problem_solution_no_metric (s, rhs_y, 1);
  periodic_fs_copy_problem_solution_no_metric (s, rhs_z, 2);
  
  periodic_fs_reinit_panels_physical_quantities (s);
  periodic_fs_reinit_panels_physical_quantities (s2);

  if (s->rhs) {
    gsl_vector_free (s->rhs);
    s->rhs = NULL;
  }
  
  if (s2->rhs) {
    gsl_vector_free (s2->rhs);
    s2->rhs = NULL;
  }

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  periodic_fs_numbering (s);

  return s;
}

Spline2D * periodic_spheroid (gint M, gint N, gint k, gint ninner, gint nouter, gdouble r1, gdouble r2, gdouble r3)
{
  /* Create the connected spline patch */
  Spline2D * s = periodic_fs_new (M, N, k, ninner, nouter);
  s->noflux = FALSE;
  
  periodic_fs_init_panels (s);

  Spline2D * s2 = periodic_fs_new (M, N, k, ninner, nouter);
  s2->noflux = FALSE;
  periodic_fs_init_panels (s2);
  s->next = s2;

  CCSProblem * fit = periodic_fs_build_galerkin_fit_matrix_no_metric (s);

  gsl_vector * rhs_x = periodic_fs_build_galerkin_rhs_gauss_no_metric (s, sphere_x2, &r1, NULL, NULL);
  gsl_vector * rhs_y = periodic_fs_build_galerkin_rhs_gauss_no_metric (s, sphere_y2, &r2, NULL, NULL);
  gsl_vector * rhs_z = periodic_fs_build_galerkin_rhs_gauss_no_metric (s, sphere_z2, &r3, NULL, NULL);
  
  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);  

  periodic_fs_copy_problem_solution_no_metric (s, rhs_x, 0);
  periodic_fs_copy_problem_solution_no_metric (s, rhs_y, 1);
  periodic_fs_copy_problem_solution_no_metric (s, rhs_z, 2);
  
  periodic_fs_reinit_panels_physical_quantities (s);
  periodic_fs_reinit_panels_physical_quantities (s2);

  if (s->rhs) {
    gsl_vector_free (s->rhs);
    s->rhs = NULL;
  }
  
  if (s2->rhs) {
    gsl_vector_free (s2->rhs);
    s2->rhs = NULL;
  }

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  periodic_fs_numbering (s);

  return s;
}

Spline2D * standard_sphere (gint M, gint N, gint k,
			    gint ninner, gint nouter, gdouble r)
{
  /* Create the connected spline patch */
  Spline2D * s = spline2d_new (M, N, k, ninner, nouter);
  s->noflux = FALSE;

  gint i, j;

  spline2d_init_panels (s);

#if 1
  CCSProblem * fit = spline2d_build_galerkin_fit_matrix_no_metric (s);
  gsl_vector * rhs_x = build_galerkin_rhs_gauss_no_metric (s, sphere_x3, &r, NULL, NULL);
  gsl_vector * rhs_y = build_galerkin_rhs_gauss_no_metric (s, sphere_y3, &r, NULL, NULL);
  gsl_vector * rhs_z = build_galerkin_rhs_gauss_no_metric (s, sphere_z3, &r, NULL, NULL);
#else
  CCSProblem * fit = spline2d_build_galerkin_fit_matrix_no_metric_bc_dirichlet (s);
  gsl_vector * rhs_x = build_galerkin_rhs_gauss_no_metric_bc_dirichlet (s, sphere_x3, &r, sphere_x3_bc, &r);
  gsl_vector * rhs_y = build_galerkin_rhs_gauss_no_metric_bc_dirichlet (s, sphere_y3, &r, sphere_y3_bc, &r);
  gsl_vector * rhs_z = build_galerkin_rhs_gauss_no_metric_bc_dirichlet (s, sphere_z3, &r, sphere_z3_bc, &r);
#endif
  
  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);  

  /* FILE * ffp = fopen ("rhs.tmp","w"); */
  /* for ( i = 0; i < rhs_x->size; i++) */
  /*   fprintf (ffp, "%i %f \n", i, gsl_vector_get (rhs_x, i)); */
  /* fclose (ffp); */

  spline2d_copy_problem_solution (s, rhs_x, 0);
  spline2d_copy_problem_solution (s, rhs_y, 1);
  spline2d_copy_problem_solution (s, rhs_z, 2);

  spline2d_reinit_panels_physical_quantities (s);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  return s;
}

static gdouble reverse_sphere_x3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;
  v = sin(M_PI/2.*v);

  return  *r*cos (2. * M_PI * u)*sin (M_PI*v) /* - 1e-10 */;
}

static gdouble reverse_sphere_y3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;
  v = sin(M_PI/2.*v);

  return -*r*sin (2. * M_PI * u)*sin (M_PI*v) ;
}

static gdouble reverse_sphere_z3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  v = sin(M_PI/2.*v);

  return *r*cos(M_PI*v);
}

Spline2D * reverse_sphere (gint M, gint N, gint k,
			   gint ninner, gint nouter, gdouble r)
{
  /* Create the connected spline patch */
  Spline2D * s = spline2d_new (M, N, k, ninner, nouter);
  s->noflux = FALSE;

  gint i, j;

  spline2d_init_panels (s);

  CCSProblem * fit = spline2d_build_galerkin_fit_matrix_no_metric (s);
  gsl_vector * rhs_x = build_galerkin_rhs_gauss_no_metric (s, reverse_sphere_x3, &r, NULL, NULL);
  gsl_vector * rhs_y = build_galerkin_rhs_gauss_no_metric (s, reverse_sphere_y3, &r, NULL, NULL);
  gsl_vector * rhs_z = build_galerkin_rhs_gauss_no_metric (s, reverse_sphere_z3, &r, NULL, NULL);
  
  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);  

  spline2d_copy_problem_solution (s, rhs_x, 0);
  spline2d_copy_problem_solution (s, rhs_y, 1);
  spline2d_copy_problem_solution (s, rhs_z, 2);

  spline2d_reinit_panels_physical_quantities (s);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  return s;
}

static void test_sphere (Simulation * sim)
{

  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
  //sim->build_boundary_subproblem = build_boundary_subproblem_collocation;

   /** Self-influence coefficients integration method **/
  sim->self_influence_function = rong_self_influence_coefficients;
  //sim->self_influence_function = lachat_watson_self_influence_coefficients;
  //   sim->self_influence_function = lachat_watson_self_influence_coefficients_qag;
  // sim->self_influence_function = wamit_self_influence_coefficients;
  //  sim->self_influence_function = lachat_watson_ye_self_influence_coefficients;
  // sim->self_influence_function = qin_self_influence_coefficients;

  // Read sphere geometry
  //sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere ( 20, 20, 3, 4, 3, 0.5));
  // sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (/* 10 */15, 30, 3, 4, 3, 0.5));
  //sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (/* 10 */20, 20, 3, 4, 3, 0.5));
  sim->hull->patches = g_slist_append (sim->hull->patches, standard_sphere (20, 20, 3, 4, 3, 0.5));

  /* FILE * ffp = fopen("sphere.GDF","r"); */
  /* hull_read (sim->hull, ffp, 20, 20, FALSE, FALSE, FALSE, FALSE); */
  /* fclose (ffp); */

  /* Point p; */
  /* p.x = 0.04; p.y = 0.005; p.z = 0.496; */
  /* Spline2D * sp = sim->hull->patches->data; */
  /* SPPanel * spp = g_ptr_array_index (sp->panels, 0); */
  /* newton_raphson (spp, p); */

  sim->hull->wet_patches = sim->hull->patches;

  FILE * fp = fopen ("hull.out","w");
  hull_print (sim->hull, fp);
  fclose (fp);


  hull_print (sim->hull, NULL);
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  GSList * patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);


  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  sim->U.x = 1.;
  sim->U.y = sim->U.z = 0.;

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  solve_boundary_problem_for_basis_flow (sim);

  /* Calculate dzdz Phi */

  calculate_dz_spline_coeff_new (sim);

  simulation_build_dirichlet_sub_problems_rhs (sim, 14);
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  patches = sim->hull->patches;
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 15);

  hull_print_gnuplot (sim->hull, NULL, 3, 0.);

  print_potential_gauss (sim->hull->patches);


  Forces * f =  wet_hull_pressure_force_integration (sim->hull ,sim ,
						   (HeightCurve) sim->wp.wave_elevation,
						   0, &sim->wp);
  forces_print (f, stdout);

  calculate_added_mass_matrix (sim, sim->hull->xg);

  gint i;
  for ( i = 0; i < 6; i++) {
    fprintf (stderr,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }

  gdouble added_mass = calculate_added_mass (sim->hull->patches);
  fprintf (stdout, "Added mass coeff: %e  Analytical: %e Error: %e \n",
	   added_mass, 2.*M_PI/24., fabs (2.*M_PI/24.- added_mass));
  g_free (f);
}

/**
 * This calculate the added mass in surge, sway and pitch for a
 * spheroid in an infinite fluid and allows to reproduce Figure 3.5
 * of (Roe, 2005).
 **/
static void test_potential_spheroid (Simulation * sim)
{
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;

  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  // Read sphere geometry
  gdouble ratio = 0.2;

  sim->hull->patches = g_slist_append (sim->hull->patches, periodic_spheroid ( 20, 20, 3, 4, 3, 1., ratio, ratio));

  sim->hull->wet_patches = sim->hull->patches;

  FILE * fp = fopen ("hull.out","w");
  hull_print (sim->hull, fp);
  fclose (fp);


  hull_print (sim->hull, NULL);
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  GSList * patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  sim->U.x = 1.;
  sim->U.y = sim->U.z = 0.;

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  sim->rho = 1.;
  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (stdout, "%f Added mass coeff: %e %e %e\n",
	   ratio, sim->hull->A[0][0]/(4./3.*M_PI*ratio*ratio), sim->hull->A[1][1]/(4./3.*M_PI*ratio*ratio), sim->hull->A[4][4]/(4./15.*M_PI*ratio*ratio*(1+ratio*ratio)));
}

static gdouble metrix_test_grid_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);

  return -5. + 10.*u+ 0.2*sin (15*v);
}

static gdouble metrix_test_grid_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);

  return -4 + 8.*v + 0.8*cos (10*u);
  return -(1+4.*v)*sin(2.*M_PI*u +  M_PI);
}

gdouble explicit_metric_test_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);
	

  Vector grad, xu, xv;
  gdouble dvardu = 0., dvardv = 0., Vn = 0.;

  gint  i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

  istart = gp->istart;
  jstart = gp->jstart;

  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    gint ii = (istart+i) % (sp->M+sp->k-1);
    for ( j = 0; j < sp->k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cudv = cu*gsl_matrix_get (Bv, j, 1);
      gdouble cvdu = cv*cdu;
      gint jj = (jstart+j);
      xu.x += coeff (sp,ii,jj, 0)*cvdu;
      xu.y += coeff (sp,ii,jj, 1)*cvdu;
      xv.x += coeff (sp,ii,jj, 0)*cudv;
      xv.y += coeff (sp,ii,jj, 1)*cudv;
      dvardu += coeff (sp,ii,jj, 9)*cvdu;
      dvardv += coeff (sp,ii,jj, 9)*cudv;
    }
  }
 
  gdouble detinv = 1./(xu.x*xv.y-xu.y*xv.x);

  grad.x = (xv.y*dvardu-xu.y*dvardv)*detinv;
  grad.y = (-xv.x*dvardu+xu.x*dvardv)*detinv;
  grad.z = 0.;

  Vector W;

  /* Test advection */
  W.x = 1.;
  W.y = 0.;
  W.z = 0.;

  gdouble val =  spline2d_eval_gauss_point (sp, gp, m, n, 9);

  gdouble rhsmn = val - sim->time.dt*( vector_scalar_product(&W,&grad) );

  return rhsmn;
}

gdouble leapfrog_metric_test_rhs_gauss (SPPanel * spp,
					gint m, gint n,
					gpointer data)
{
  Simulation * sim = (Simulation *) data;

  if (sim->time.t == 0.)
    return explicit_metric_test_rhs_gauss (spp, m, n, data);

  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  /* For numerical beaches */
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);
	

  Vector grad, xu, xv;
  gdouble dvardu = 0., dvardv = 0., Vn = 0.;

  gint  i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

  istart = gp->istart;
  jstart = gp->jstart;

  xu.x = xu.y = xu.z = xv.x = xv.y = xv.z = 0.;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    gint ii = (istart+i);
    if (sp->periodic)
      ii -= (sp->k-1);
    for ( j = 0; j < sp->k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cudv = cu*gsl_matrix_get (Bv, j, 1);
      gdouble cvdu = cv*cdu;
      gint jj = (jstart+j);
      xu.x += coeff (sp,ii,jj, 0)*cvdu;
      xu.y += coeff (sp,ii,jj, 1)*cvdu;
      xv.x += coeff (sp,ii,jj, 0)*cudv;
      xv.y += coeff (sp,ii,jj, 1)*cudv;
      dvardu += coeff (sp,ii,jj, 9)*cvdu;
      dvardv += coeff (sp,ii,jj, 9)*cudv;
    }
  }
 
  gdouble detinv = 1./(xu.x*xv.y-xu.y*xv.x);

  grad.x = (xv.y*dvardu-xu.y*dvardv)*detinv;
  grad.y = (-xv.x*dvardu+xu.x*dvardv)*detinv;
  grad.z = 0.;

  Vector W;

  /* Test advection */
  W.x = 1.;
  W.y = 0.;
  W.z = 0.;

  gdouble val =  spline2d_eval_gauss_point (sp, gp, m, n, 22);

  gdouble rhsmn = val - sim->time.dt*( vector_scalar_product(&W,&grad) );

  return rhsmn;
}

static void semi_implicit_test_advection (Simulation * sim)
{
  /* Start timer */
  g_test_timer_start ();
  Spline2D * sp = sim->fs->s->patches->data;
  gint NU = gsl_bspline_ncoeffs (sp->w_u);
  gint NV = gsl_bspline_ncoeffs (sp->w_v);
  gint size = NU*NV;
  gdouble A0[size][size];
  gdouble RHS[size];
  gint i, j, m, n, ii, a, b;

  g_assert (sp != NULL);

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    RHS[i] = 0.;
    for ( j = 0; j < size; j++) {
      A0[i][j] = 0.;
    }
  }

  // Loop over the panels of the patch
  for ( ii = 0; ii < sp->M*sp->N; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    g_assert (spp != NULL);
     	
    // Gauss outer-integration
    GaussPoints * gp = spp->outer;
    gint ng = gp->ui->len; // Order of outer Gauss-Legendre rule
    gint ustart = gp->istart;
    if (sp->periodic)
      ustart -= sp->k - 1;
    gint vstart = gp->jstart;

    for ( m = 0; m < ng; m++) {
      gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
      	  
      for ( n = 0; n < ng; n++) {
	gint gindex = m + n*ng;
	gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
	Vector N = g_array_index (gp->Ni, Vector, gindex);
	gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
	gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
	gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
	gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
	gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
	gdouble c6 = g_array_index (gp->c6, gdouble, gindex);


  	// Calculate W at point (um, vn)
  	Vector W ;
	W.x = 1.;
	W.y = 0.;
	W.z = 0.;
  	gint  i, j, ii, jj;
  	gdouble zeta, Phi2, Phi2n, dvardu, dvardv;
  	zeta = Phi2 = Phi2n = dvardu = dvardv = 0.;

  	for ( i = 0; i < sp->k; i++) {
  	  gdouble cu = gsl_matrix_get (Bu, i, 0);
  	  gdouble cdu = gsl_matrix_get (Bu, i, 1);
	  ii = (ustart+i);
  	  for ( j = 0; j < sp->k; j++) {
  	    gdouble cv = gsl_matrix_get (Bv, j, 0);
  	    gdouble cudv = cu*gsl_matrix_get (Bv, j, 1);
  	    gdouble cvdu = cv*cdu;
  	    gdouble cuv = cu*cv;
	    jj = (vstart+j);

  	    zeta += coeff (sp,ii,jj, 9)*cuv;
	    dvardu += coeff (sp,ii,jj, 9)*cvdu;
	    dvardv += coeff (sp,ii,jj, 9)*cudv;
  	  }
  	}

	Vector grad;
	grad.x = c1*dvardu + c2*dvardv;
	grad.y = c3*dvardu + c4*dvardv;
	grad.z = 0.;

	gdouble term1 = sim->beta*sim->time.dt*(W.x*c1 + W.y*c3);
	gdouble term2 = sim->beta*sim->time.dt*(W.x*c2 + W.y*c4);
	// Phi2n = -Phi0n
  	/* gdouble term3 = 0.; */

	gdouble rhsmn = sim->time.dt*(1.-sim->beta)*vector_scalar_product(&W,&grad);

	// Loop over the splines whose support is included in the panel
	for ( i = ustart; i < ustart + sp->k; i++) {
	  gdouble wmni = wmn*gsl_matrix_get(Bu, i-ustart, 0);
	  for ( j = vstart; j < vstart + sp->k; j++) {
	    gdouble wmnij = wmni*gsl_matrix_get(Bv, j-vstart, 0);
	    gint indexi = i + j*NU;

	    for ( a = 0; a < sp->k; a++) {
	      gdouble wmnija = wmnij*gsl_matrix_get(Bu, a, 0);
	      for ( b = 0; b < sp->k; b++) {
		A0[indexi][(ustart+a) + (vstart+b)*NU]
		+=  wmnija*gsl_matrix_get(Bv, b, 0) + wmnij*term1*gsl_matrix_get(Bu, a, 1)*gsl_matrix_get(Bv, b, 0)
			     + wmnija*term2*gsl_matrix_get(Bv, b, 1);
	      }
	    }

	    
	    RHS[indexi] += wmnij*(zeta + rhsmn);
	  }
	}
	
      }
    }
    
  }

/* /\* #ifdef NO_FLUX *\/ */
/*   // On the solid boundary dn phi = - dn phi0 */
/*   // For now, dn phi = 0 i.e. dv phi = 0 */
/*   size_t ustart, uend, vstart, vend; */
/*   gsl_vector * Bu = gsl_vector_alloc (sp->k); */
/*   gsl_matrix * Bv = gsl_matrix_alloc (sp->k, 2); */
/*   for ( i = 0; i < NU; i++) { */
/*     gint index1 = i; */
/*     gdouble u = gsl_bspline_greville_abscissa (i, sp->w_u); */
/*     gdouble v = 0.; */

/*     for ( j = 0; j < size; j++) */
/*       A0[j][index1] = 0.; */

/*     Vector xv; */
/*     xv.x = spline2d_derivative_eval (sp, u, v, 0, 1, 0); */
/*     xv.y = spline2d_derivative_eval (sp, u, v, 0, 1, 1); */
/*     xv.z = spline2d_derivative_eval (sp, u, v, 0, 1, 2); */

/*     xv = vector_normalise (xv); */

/*     gsl_bspline_eval_nonzero (u, Bu, &ustart, &uend, sp->w_u); */
/*     gsl_bspline_deriv_eval_nonzero (v, 1, Bv, &vstart, &vend, sp->w_v, sp->wd_v); */

/*     for ( m = 0; m < sp->k; m++) { */
/*       gdouble cu = gsl_vector_get (Bu, m); */
/*       for ( n = 0; n < sp->k; n++) { */
/*     	gdouble cv = gsl_matrix_get (Bv, n, 1); */
/* 	A0[ustart+m + (vstart+n)*NU][index1] = cu*cv; */
/*       } */
/*     } */
    
/*     RHS[index1] = 0.; */
/*   } */
/*   gsl_vector_free (Bu); */
/*   gsl_matrix_free (Bv); */
/* /\* #endif *\/ */

/*   // Continuity of variable on boundary */
/*   for ( i = 0; i < NV; i++) { */
/*     gint index1 = (i+1)*NU - 1; */
/*     gint index2 = i*NU; */
    
/*     for ( j = 0; j < size; j++) */
/*       A0[j][index1] += A0[j][index2]; */

/*     for ( j = 0; j < size; j++) */
/*       A0[j][index2] = 0.; */

/*     A0[index1][index2] = 1.; */
/*     A0[index2][index2] = -1.; */

/*     RHS[index1] += RHS[index2]; */
/*     RHS[index2] = 0.; */
/*   } */


  /* Storage in Compressed Column Storage (CCS) format for superlu */
  CCSProblem * ccs = ccs_problem_new ();
  gsl_vector * gsl_rhs = gsl_vector_alloc (size);
  gint count = 0;
  for ( i = 0; i < size; i++) {
    g_array_append_val (ccs->index, count);
    for ( j = 0; j < size; j++) {
      if (A0[i][j] != 0.) {
  	g_array_append_val (ccs->matrix, A0[i][j]);
  	g_array_append_val (ccs->column, j);
  	count++;
      }
    }
    gsl_vector_set (gsl_rhs, i, RHS[i]);
  }
  g_array_append_val (ccs->index, count);

  /* Solve the problem using superlu */
  ccs_problem_lu_solve (ccs, gsl_rhs);

  /* Copy the solution to the patch */
  for ( i = 0; i < gsl_bspline_ncoeffs (sp->w_u); i++) {
    for ( j = 0; j < gsl_bspline_ncoeffs (sp->w_v); j++) {
      coeff_assign (sp, i, j, 7, gsl_vector_get (gsl_rhs, i + j*gsl_bspline_ncoeffs (sp->w_u)));
    }
  }

  ccs_problem_destroy (ccs);
  gsl_vector_free (gsl_rhs);
  
  /* Stop timer and print */
  fprintf (stdout, "   Free-surface disturbance potential update: %f \n", g_test_timer_elapsed());
}

static gdouble gaussian_shape_test_advection (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  return 0.6*exp(-5*(p.x - 1.)*(p.x - 1.))*exp(-5.*p.y*p.y);
}

gdouble test_advection (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  2.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.01;

  sim->wp.g = 9.81;
  sim->wp.A = 1.;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
#if 1
  // For constant unidirectional flow
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
#endif


  // Radius of domain
  /* sim->wp.r = /\* 10. *\/2.5; */
  sim->wp.r1 = /* 10. */3.;
  sim->wp.r2 = /* 10. */3.;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = NULL;


  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80, 80, metrix_test_grid_x, metrix_test_grid_y, NULL));

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fprintf(stderr,"Grids done\n");


  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection, sim, 9);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // For leapfrog
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 22);

    sim->time.dt = sim->time.dt = /* 0.001 */0.005;

    if (1) {
      gsl_vector * gsl_rhs;
      
      //gsl_rhs = sp->build_fit_rhs (sp, explicit_metric_test_rhs_gauss, sim);
      
      gsl_rhs = sp->build_fit_rhs (sp, leapfrog_metric_test_rhs_gauss, sim, NULL, NULL, gsl_rhs);
      
      /* Solve the problem using superlu */
      ccs_problem_lu_solve (sp->fit, gsl_rhs);
      
      sp->copy_fit_solution (sp, gsl_rhs, 9);
      
      gsl_vector_free (gsl_rhs);
    }
    else {
      semi_implicit_test_advection (sim);
    }

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%200 == 0 ) {
      // spline2d_filter_variable (sim->hull->patches->data, 7);
      // spline2d_filter_variable (sim->hull->patches->data, 9);
      // print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);





  /* FreeSurface * fs = sim->fs; */
  /* fs->s->patches = g_slist_append (fs->s->patches, rectangular_grid (80, 80)); */

  /* FILE * fout = fopen ("grid.tmp", "w"); */
  /* spline2d_surface_print_grid (fs->s, fout); */
  /* fclose (fout); */

  /* // Leapfrog scheme is explicit scheme for the first time step */
  /* /\* if (sim->time.t == 0.) { *\/ */
  /* /\*   explicit_free_surface_elevation_disturbance_update (sim); *\/ */
  /* /\*   return; *\/ */
  /* /\* } *\/ */

  /* g_test_timer_start (); */
  /* Spline2D * sp = sim->fs->s->patches->data; */
  /* gint i; */

  /* g_assert (sp != NULL); */

  /* // Original Galerkin method */
  /* g_assert (sp->fit_noflux); */

  /* // Get rhs */
  /* gsl_vector * gsl_rhs; */
 
  /* gsl_rhs = sp->build_fit_rhs (sp, leapfrog_free_surface_update_rhs_gauss, sim); */
  /* /\* Solve the problem using superlu *\/ */
  /* ccs_problem_lu_solve (sp->fit, gsl_rhs); */

  /* /\* Copy the solution to the patch *\/ */
  /* sp->copy_fit_solution (sp, gsl_rhs, 9); */
  
  /* gsl_vector_free (gsl_rhs); */


}

static void test_cylinder (Simulation * sim)
{
  sim->self_influence_function = rong_self_influence_coefficients;

  // Read sphere geometry
  FILE * fp = fopen("cylinder1.GDF","r");
  hull_read_old (sim->hull, fp, 10, 10, FALSE, FALSE);
  fclose (fp);

  sim->hull->wet_patches = sim->hull->patches;
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  GSList * patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  hull_print (sim->hull, NULL);

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  sim->U.x = 1.;
  sim->U.y = sim->U.z = 0.;

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  solve_boundary_problem_for_basis_flow (sim);

  hull_print_gnuplot (sim->hull, NULL, 3, 0.);
  print_cylinder_profile (sim->hull->patches);

  gdouble added_mass = calculate_added_mass (sim->hull->patches);
  fprintf (stdout, "Added mass coeff: %e Newman: %e Difference %e \n",
	   added_mass, 1.8390*2., fabs(added_mass-1.8390*2));
}



static gdouble cube_u (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(sin(0.5*M_PI)*u-0.5);
}

static gdouble cube_v (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(v/* *v */-0.5);
}

static gdouble cube_mu (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.5-u);
}

static gdouble cube_mv (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.5-v);
}

static gdouble cube_top (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble * r = data;
  return *r/2.;
}

static gdouble cube_bottom (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble * r = data;
  return -*r/2.;
}

Spline2D * create_gauss_patch (gint M, gint N, gint k,
			       gint ninner, gint nouter,
			       GaussFunc func_x, gpointer data_x,
			       GaussFunc func_y, gpointer data_y,
			       GaussFunc func_z, gpointer data_z)
{
  Spline2D * s = spline2d_new (M, N, k, ninner, nouter);
  s->noflux = FALSE;

  gint i, j;

  spline2d_init_panels (s);

  CCSProblem * fit = spline2d_build_galerkin_fit_matrix_no_metric (s);
  
  gsl_vector * rhs_x = build_galerkin_rhs_gauss_no_metric (s, func_x, data_x, NULL, NULL);
  gsl_vector * rhs_y = build_galerkin_rhs_gauss_no_metric (s, func_y, data_y, NULL, NULL);
  gsl_vector * rhs_z = build_galerkin_rhs_gauss_no_metric (s, func_z, data_z, NULL, NULL);

  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);  

  spline2d_copy_problem_solution (s, rhs_x, 0);
  spline2d_copy_problem_solution (s, rhs_y, 1);
  spline2d_copy_problem_solution (s, rhs_z, 2);

  spline2d_reinit_panels_physical_quantities (s);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  return s;
}

GSList * cube_inside (gint M, gint N, gint k,
		      gint ninner, gint nouter, gdouble r)
{
  GSList * patches = NULL;

  /* Create the connected spline patch */
  

  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 cube_mu, &r,
							 cube_v, &r,
							 cube_top, &r));
  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 cube_u, &r,
							 cube_v, &r,
							 cube_bottom, &r));

  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 cube_top, &r,
							 cube_mu, &r,
							 cube_v, &r));
  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 cube_bottom, &r,
							 cube_u, &r,
							 cube_v, &r));

  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 cube_v, &r,
							 cube_top, &r,
							 cube_mu, &r));
  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 cube_v, &r,
							 cube_bottom, &r,
							 cube_u, &r));

  return patches;
}

static gdouble star_u (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.2765+0.079*cos(5.*2.*M_PI*u))*cos(2.*M_PI*u)/* *v */;
}

static gdouble star_v (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.2765+0.079*cos(5.*2.*M_PI*u))*sin(2.*M_PI*u)/* *v */;
}

static gdouble cube_w (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(v/* *v */-0.5);
}

static gdouble star_u2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.2765+0.079*cos(5.*2.*M_PI*u))*cos(2.*M_PI*u)*v;
}

static gdouble star_v2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.2765+0.079*cos(5.*2.*M_PI*u))*sin(2.*M_PI*u)*v;
}

static gdouble star_u3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.2765+0.079*cos(5.*2.*M_PI*u))*cos(2.*M_PI*u)*(1.-v);
}

static gdouble star_v3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = data;

  return  *r*(0.2765+0.079*cos(5.*2.*M_PI*u))*sin(2.*M_PI*u)*(1.-v);
}

GSList * star_inside (gint M, gint N, gint k,
		      gint ninner, gint nouter, gdouble r)
{
  GSList * patches = NULL;

  /* Create the connected spline patch */
  
  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 star_u, &r,
							 star_v, &r,
							 cube_w, &r));

  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 star_u2, &r,
							 star_v2, &r,
							 cube_bottom, &r));
  
  patches = g_slist_append (patches, create_gauss_patch (M, N, k, ninner, nouter,
							 star_u3, &r,
							 star_v3, &r,
							 cube_top, &r));

  return patches;
}

static void test_square (Simulation * sim)
{

  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
  // sim->build_boundary_subproblem = build_boundary_subproblem_collocation;

  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;
  sim->self_influence_function = rong_self_influence_coefficients;


  sim->continuity = FALSE;

  // Read sphere geometry
  FILE * fp;
  //FILE * fp = fopen("square.GDF","r");
  // hull_read (sim->hull, fp, 20, 20, FALSE, FALSE, FALSE, FALSE);
  //fclose (fp);
  sim->hull->patches = g_slist_concat (sim->hull->patches, cube_inside (12, 12, 3, 4, 3, 1.));

  sim->hull->wet_patches = sim->hull->patches;

  hull_print (sim->hull, NULL);
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  GSList * patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  sim->U.x = 1.;
  sim->U.y = sim->U.z = 0.;

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  solve_boundary_problem_for_basis_flow (sim);

  print_potential_square (sim->hull->patches);

  gdouble added_mass = calculate_added_mass (sim->hull->patches);
  

  fprintf (stdout, "Added mass coeff: %e Newman: %e Error: %e \n",
	   added_mass, 0.31921*2., fabs(added_mass-0.31921*2.));
}





gdouble polynomial_normal_velocity (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);  
  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  Vector grad;
  grad.x = 4*p.x;
  grad.y = -2.*p.y;
  grad.z = -2.*p.z;
  return vector_scalar_product (&grad, &N);
}

Vector polynomial_potential_gradient (Spline2D *sp, gdouble u, gdouble v)
{
  Point p = spline2d_eval_point (sp, u, v);
  Vector grad;
  grad.x = 4*p.x;
  grad.y = -2.*p.y;
  grad.z = -2.*p.z;

  return grad;
}

gdouble polynomial_potential (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;  
  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  return 2.*p.x*p.x - p.y*p.y - p.z*p.z;
}

gdouble polynomial_potential_uv (Spline2D * sp, gdouble u, gdouble v)
{ 
  Point p = spline2d_eval_point (sp, u, v);

  return 2.*p.x*p.x - p.y*p.y - p.z*p.z;
}

gdouble cosh_potential (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;  
  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  gdouble a = 1., b = 2.;

  return cosh(a*p.x)*cosh(b*p.y)*cos(sqrt(a*a+b*b)*p.z);
}

gdouble cosh_potential_uv (Spline2D * sp, gdouble u, gdouble v)
{
  Point p = spline2d_eval_point (sp, u, v);
  gdouble a = 1., b = 2.;

  return cosh(a*p.x)*cosh(b*p.y)*cos(sqrt(a*a+b*b)*p.z);
}

gdouble cosh_potential_dzz_uv (Spline2D * sp, gdouble u, gdouble v)
{
  Point p = spline2d_eval_point (sp, u, v);
  gdouble a = 1., b = 2.;

  return -(a*a+b*b)*cosh(a*p.x)*cosh(b*p.y)*cos(sqrt(a*a+b*b)*p.z);
}

gdouble cosh_normal_velocity (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);  
  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  gdouble a = 1., b = 2.;
  Vector grad;
  grad.x = a*sinh(a*p.x)*cosh(b*p.y)*cos(sqrt(a*a+b*b)*p.z);
  grad.y = b*cosh(a*p.x)*sinh(b*p.y)*cos(sqrt(a*a+b*b)*p.z);
  grad.z = -sqrt(a*a+b*b)*cosh(a*p.x)*cosh(b*p.y)*sin(sqrt(a*a+b*b)*p.z);
  return vector_scalar_product (&grad, &N);
}

Vector cosh_potential_gradient (Spline2D * sp, gdouble u, gdouble v)
{ 
  Point p = spline2d_eval_point (sp, u, v);
  gdouble a = 1., b = 2.;
  Vector grad;
  grad.x = a*sinh(a*p.x)*cosh(b*p.y)*cos(sqrt(a*a+b*b)*p.z);
  grad.y = b*cosh(a*p.x)*sinh(b*p.y)*cos(sqrt(a*a+b*b)*p.z);
  grad.z = -sqrt(a*a+b*b)*cosh(a*p.x)*cosh(b*p.y)*sin(sqrt(a*a+b*b)*p.z);
  return grad;
}

static void test_star (Simulation * sim)
{

  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
  // sim->build_boundary_subproblem = build_boundary_subproblem_collocation;

  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  sim->continuity = FALSE;

  // Read sphere geometry
  FILE * fp;

  /* GSList * patches = star_inside (80, 12, 3, 4, 3, 1.); */

  GSList * patches = star_inside (50, 12, 3, 4, 3, 1.);

  sim->fs->s->patches = g_slist_append (sim->fs->s->patches, patches->data);
  
  sim->hull->patches = g_slist_append (sim->hull->patches, patches->next->data);
  sim->hull->patches = g_slist_append (sim->hull->patches, patches->next->next->data);

  sim->hull->wet_patches = sim->hull->patches;

  hull_print (sim->hull, NULL);
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  fp = fopen ("fs.tmp", "w");
  spline2d_surface_print_grid (sim->fs->s, fp);
  fclose (fp);

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  //  solve_boundary_problem_for_basis_flow (sim);
  gint i, j;
  Spline2D * sp;
#if 0 // Neumann problem
  // Apply Phin = U.N on the hull (stored in variable 4)
  patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, polynomial_normal_velocity, &sim->U, 4);
    patches = patches->next;
  }

  // Apply Phin = 0 on the free-surface (stored in variable 4)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, polynomial_normal_velocity, NULL, 4);
    patches = patches->next;
  }

  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_neumann_sub_problems_rhs (sim, 4);

  // Assemble the total Neumann rhs
  boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->neumann_lu, sim->neumann_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->neumann_problem, 3);
#else // Mixed problem
   // Apply Phin = U.N on the hull (stored in variable 4)
  patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, polynomial_normal_velocity, &sim->U, 4);
    patches = patches->next;
  }

  // Apply Phi = 0 on the free-surface (stored in variable 3)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, polynomial_potential, NULL, 3);
    patches = patches->next;
  }

  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_mixed_sub_problems_rhs (sim, 3, 4);

  // Assemble the total Neumann rhs
  /* boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems); */
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 3, 4);

  fp = fopen ("star-fs.tmp","w");

  gdouble NP = 60;
  sp = sim->fs->s->patches->data;

  for ( i = 0; i <= NP; i++) {
    for (j = 0; j <= NP; j++) {
      gdouble ui = i/(NP);
      gdouble vj = j/(NP);

      Point p = spline2d_eval_point (sp, ui, vj);
      Vector N = spline2d_normal (sp, ui, vj);

      Vector grad;
      grad.x = 4*p.x;
      grad.y = -2.*p.y;
      grad.z = -2.*p.z;
      
      fprintf (fp, "%f %f %f %f %f %f %f \n", p.x,
	       p.y,
	       p.z,
	       spline2d_eval (sp, ui, vj, 3),
	       spline2d_eval (sp, ui, vj, 4),
	       2*p.x*p.x-p.y*p.y-p.z*p.z,
	       vector_scalar_product (&grad, &N));

    }
    fprintf(fp, "\n");
  }

  fclose (fp);

#endif

  //  print_potential_square (sim->hull->patches);

  fp = fopen("star_hull-1.tmp","w");
  
  GSList * plist = sim->hull->patches;
  sp = plist->data;

  for ( i = 1.; i <= 60; i++) {
    gdouble ui = i/(60.);
    for (j = 1.; j <= 60; j++) {
      gdouble vj = j/(60.);

      Point p = spline2d_eval_point (sp, ui, vj);
      Vector grad;
      grad.x = 4*p.x;
      grad.y = -2.*p.y;
      grad.z = -2.*p.z;
      Vector N = spline2d_normal (sp, ui, vj);
      Vector grad2 = potential_gradient_on_surface (sp, ui, vj, 3);

      /* fprintf (fp, "%f %f %f %f %f %f %f\n", p.x, p.y, p.z, */
      /* 	       spline2d_eval (sp, ui, vj, 3), */
      /* 	       spline2d_eval (sp, ui, vj, 4), */
      /* 	       2*p.x*p.x-p.y*p.y-p.z*p.z, */
      /* 	       vector_scalar_product (&grad, &N)); */

      fprintf (fp, "%f %f %f %f %f %f %f %f %f\n", p.x, p.y, p.z,
      	       grad.x,
      	       grad2.x,
      	       grad.y,
      	       grad2.y,
      	       grad.z,
      	       grad2.z);

    }
    fprintf(fp, "\n");
  }
  fclose (fp);
  plist = plist->next;
  

  sp = plist->data;
  fp = fopen("star_hull-2.tmp","w");
  for ( i = 0; i <= 60; i++) {
    gdouble ui = i/(60.);
    for (j = 0; j <= 60; j++) {
      gdouble vj = j/(60.);

      Point p = spline2d_eval_point (sp, ui, vj);
      
      fprintf (fp, "%f %f %f %f %f %f \n", p.x, p.y, p.z,
	       spline2d_eval (sp, ui, vj, 3),
	       spline2d_eval (sp, ui, vj, 4),
	       2*p.x*p.x-p.y*p.y-p.z*p.z);

    }
    fprintf(fp, "\n");
  }
  fclose (fp);
}

static void test_star2 (Simulation * sim)
{

  /** Boundary problem method **/
    sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
  // sim->build_boundary_subproblem = build_boundary_subproblem_collocation;

  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  sim->continuity = FALSE;

  // Read sphere geometry
  FILE * fp;

#if 0
  /* GSList * patches = star_inside (80, 12, 3, 4, 3, 1.); */
  GSList * patches = star_inside (50, 12, 4, 4, 3, 1.);

  sim->fs->s->patches = g_slist_append (sim->fs->s->patches, patches->data);
  
  sim->hull->patches = g_slist_append (sim->hull->patches, patches->next->data);
  sim->hull->patches = g_slist_append (sim->hull->patches, patches->next->next->data);

  sim->hull->wet_patches = sim->hull->patches;
#else
  //  GSList * patches = cube_inside (12, 12, 4, 4, 3, 1.);

  GSList * patches = NULL;
  patches  = g_slist_append (patches, standard_sphere (20, 20, 3, 4, 3, 0.5));

  sim->hull->patches = patches;
  
  sim->hull->wet_patches = sim->hull->patches;
#endif


  hull_print (sim->hull, NULL);
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  /* fp = fopen ("fs.tmp", "w"); */
  /* spline2d_surface_print_grid (sim->fs->s, fp); */
  /* fclose (fp); */

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  //  solve_boundary_problem_for_basis_flow (sim);
  gint i, j;
  Spline2D * sp;
#if 0 // Neumann problem
  // Apply Phin = U.N on the hull (stored in variable 4)
  patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, cosh_normal_velocity, &sim->U, 4);
    apply_dirichlet_conditions (patches->data, cosh_potential, &sim->U, 3);
    patches = patches->next;
  }

  // Apply Phin = 0 on the free-surface (stored in variable 4)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, cosh_normal_velocity, NULL, 4);
    patches = patches->next;
  }

  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_neumann_sub_problems_rhs (sim, 4);

  // Assemble the total Neumann rhs
  boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->neumann_lu, sim->neumann_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->neumann_problem, 3);
#else 

#if 0// Mixed problem
   // Apply Phin = U.N on the hull (stored in variable 4)
  patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, cosh_normal_velocity, &sim->U, 4);
    patches = patches->next;
  }

  // Apply Phi = 0 on the free-surface (stored in variable 3)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, cosh_potential, NULL, 3);
    patches = patches->next;
  }

  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_mixed_sub_problems_rhs (sim, 3, 4);

  // Assemble the total Neumann rhs
  /* boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems); */
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 3, 4);

#else// Mixed problem
   // Apply Phin = U.N on the hull (stored in variable 4)
  patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, polynomial_potential/* cosh_potential */, &sim->U, 3);
    patches = patches->next;
  }

  // Apply Phi = 0 on the free-surface (stored in variable 3)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, polynomial_potential/* cosh_potential */, NULL, 3);
    patches = patches->next;
  }

  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_dirichlet_sub_problems_rhs (sim, 3);

  // Assemble the total Neumann rhs
  /* boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems); */
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 4);

#endif

  /* fp = fopen ("star-fs.tmp","w"); */

  /* gdouble NP = 60; */
  /* sp = sim->fs->s->patches->data; */

  /* for ( i = 0; i <= NP; i++) { */
  /*   for (j = 0; j <= NP; j++) { */
  /*     gdouble ui = i/(NP); */
  /*     gdouble vj = j/(NP); */

  /*     Point p = spline2d_eval_point (sp, ui, vj); */
  /*     Vector N = spline2d_normal (sp, ui, vj); */

  /*     Vector grad = cosh_potential_gradient (sp, ui, vj); */

  /*     fprintf (fp, "%f %f %f %f %f %f %f \n", p.x, */
  /* 	       p.y, */
  /* 	       p.z, */
  /* 	       spline2d_eval (sp, ui, vj, 3), */
  /* 	       spline2d_eval (sp, ui, vj, 4), */
  /* 	       cosh_potential_uv (sp, ui, vj), */
  /* 	       //	       2*p.x*p.x-p.y*p.y-p.z*p.z, */
  /* 	       vector_scalar_product (&grad, &N)); */

  /*   } */
  /*   fprintf(fp, "\n"); */
  /* } */

  /* fclose (fp); */

#endif

  //  print_potential_square (sim->hull->patches);

  fp = fopen("star_hull-1.tmp","w");
  
  GSList * plist = sim->hull->patches;
  sp = plist->data;

  for ( i = 1.; i <= 60; i++) {
    gdouble ui = i/(60.);
    for (j = 1.; j <= 60; j++) {
      gdouble vj = j/(60.);

      Point p = spline2d_eval_point (sp, ui, vj);
      Vector grad = polynomial_potential_gradient (sp, ui, vj);
      //Vector grad = cosh_potential_gradient (sp, ui, vj);
      /* grad.x = 4*p.x; */
      /* grad.y = -2.*p.y; */
      /* grad.z = -2.*p.z; */
      Vector N = spline2d_normal (sp, ui, vj);
      Vector grad2 = potential_gradient_on_surface (sp, ui, vj, 3);

      /* fprintf (fp, "%f %f %f %f %f %f %f\n", p.x, p.y, p.z, */
      /* 	       spline2d_eval (sp, ui, vj, 3), */
      /* 	       spline2d_eval (sp, ui, vj, 4), */
      /* 	       2*p.x*p.x-p.y*p.y-p.z*p.z, */
      /* 	       vector_scalar_product (&grad, &N)); */

      fprintf (fp, "%f %f %f %f %f %f %f %f %f %f %f \n", p.x, p.y, p.z,
	       //       cosh_potential_uv (sp, ui, vj),
	       polynomial_potential_uv (sp, ui, vj),
	       spline2d_eval (sp, ui, vj, 3),
      	       grad.x,
      	       grad2.x,
      	       grad.y,
      	       grad2.y,
      	       grad.z,
      	       grad2.z);

    }
    fprintf(fp, "\n");
  }
  fclose (fp);
  plist = plist->next;
  

  sp = plist->data;
  fp = fopen("star_hull-2.tmp","w");
  for ( i = 0; i <= 60; i++) {
    gdouble ui = i/(60.);
    for (j = 0; j <= 60; j++) {
      gdouble vj = j/(60.);

      Point p = spline2d_eval_point (sp, ui, vj);
      
      fprintf (fp, "%f %f %f %f %f %f \n", p.x, p.y, p.z,
	       spline2d_eval (sp, ui, vj, 3),
	       spline2d_eval (sp, ui, vj, 4),
	       cosh_potential_uv (sp, ui, vj));

    }
    fprintf(fp, "\n");
  }
  fclose (fp);
}

static void test_star3 (Simulation * sim)
{

  /** Boundary problem method **/
    sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
  // sim->build_boundary_subproblem = build_boundary_subproblem_collocation;

  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;
  //  sim->self_influence_function = lachat_watson_self_influence_coefficients_qag;

  sim->continuity = FALSE;

  // Read sphere geometry
  FILE * fp;

  /*************************/
  /* GSList * patches = NULL; */
  /* patches  = g_slist_append (patches, reverse_sphere (30, 30, 4, 4, 3, 0.5)); */
  /**************************/
  GSList * patches = cube_inside (10, 10, 4, 4, 3, 1.);

  sim->hull->patches = patches;
  sim->hull->wet_patches = sim->hull->patches;
  /****************************/
  /* GSList * patches = star_inside (40, 15, 4, 4, 3, 1.); */

  /* sim->fs->s->patches = g_slist_append (sim->fs->s->patches, patches->data); */
  
  /* sim->hull->patches = g_slist_append (sim->hull->patches, patches->next->data); */
  /* sim->hull->patches = g_slist_append (sim->hull->patches, patches->next->next->data); */

  /* sim->hull->wet_patches = sim->hull->patches; */
  
  /*******************************/

  hull_print (sim->hull, NULL);
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  /* fp = fopen ("fs.tmp", "w"); */
  /* spline2d_surface_print_grid (sim->fs->s, fp); */
  /* fclose (fp); */

  /* fp = fopen ("fs_normals.tmp","w"); */

  /* patches = sim->fs->s->patches; */
  /* while (patches) { */
  /*   spline2d_print_normals (patches->data, fp); */
  /*   patches = patches->next; */
  /* } */
  /* fclose (fp); */

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

#if 0  
  //Dirichlet

   // Apply Phin = U.N on the hull (stored in variable 4)
  patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, /* polynomial_potential */cosh_potential, &sim->U, 3);
    patches = patches->next;
  }

  // Apply Phi = 0 on the free-surface (stored in variable 3)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, /* polynomial_potential */cosh_potential, NULL, 3);
    patches = patches->next;
  }

  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_dirichlet_sub_problems_rhs (sim, 3);

  // Assemble the total Neumann rhs
  /* boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems); */
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 4);
#else
  //Dirichlet

   // Apply Phin = U.N on the hull (stored in variable 4)
  patches = sim->hull->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, cosh_normal_velocity, &sim->U, 4);
    patches = patches->next;
  }

  // Apply Phi = 0 on the free-surface (stored in variable 3)
  patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, cosh_normal_velocity, NULL, 4);
    patches = patches->next;
  }

  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);

  // Build the rhs corresponding to the Neumann problem for each subproblem
  // using the Neumann condition stored in variable 4
  simulation_build_neumann_sub_problems_rhs (sim, 4);

  // Assemble the total Neumann rhs
  /* boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems); */
  boundary_problem_assemble_neumann_rhs (sim->neumann_problem, sim->sub_problems);

  // Solve the Neumann problem using the LU method implemented in the GNU Scientific Library
  sim->lu_factorised_solve (sim->neumann_lu, sim->neumann_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->neumann_problem, 3);
#endif

  
  /* Calculate dzdz Phi */

  calculate_dz_spline_coeff_new (sim);

  simulation_build_dirichlet_sub_problems_rhs (sim, 14);
  boundary_problem_assemble_dirichlet_rhs (sim->dirichlet_problem, sim->sub_problems);

  sim->lu_factorised_solve (sim->dirichlet_lu, sim->dirichlet_problem->rhs);

  patches = sim->hull->patches;
  cuda_boundary_problem_copy_solution_to_patches (patches, sim->dirichlet_problem, 15);




  fp = fopen("star_hull-1.tmp","w");
  
  GSList * plist = sim->hull->patches;
  Spline2D * sp = plist->data;
  gint i, j;

  gdouble count = 0;
  gdouble e0_1 = 0., e1_1 = 0., e2_1 = 0., e3_1 = 0., e4_1 = 0., e5_1 = 0.;
  gdouble e0_2 = 0., e1_2 = 0., e2_2 = 0., e3_2 = 0., e4_2 = 0., e5_2 = 0.;
  gdouble e0_max = 0., e1_max = 0., e2_max = 0., e3_max = 0., e4_max = 0., e5_max = 0.;

  for ( i = 1.; i <= 60; i++) {
    gdouble ui = i/(60.);
    for (j = 1.; j < 60; j++) {
      gdouble vj = j/(60.);

      Point p = spline2d_eval_point (sp, ui, vj);
      //Vector grad = polynomial_potential_gradient (sp, ui, vj);
      Vector grad = cosh_potential_gradient (sp, ui, vj);
      Vector N = spline2d_normal (sp, ui, vj);
      Vector grad2 = potential_gradient_on_surface (sp, ui, vj, 3);

      gdouble vn = vector_scalar_product (&grad, &N);
      gdouble vn2 = spline2d_eval (sp, ui, vj, 4);

      //gdouble val = polynomial_potential_uv (sp, ui, vj);
      gdouble val = cosh_potential_uv (sp, ui, vj);
      gdouble val2 = spline2d_eval (sp, ui, vj, 3);

      gdouble dzz = cosh_potential_dzz_uv (sp, ui, vj);
      gdouble dzz2 = spline2d_eval (sp, ui, vj, 15);

      fprintf (fp, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f \n", p.x, p.y, p.z,
	       //       cosh_potential_uv (sp, ui, vj),
	       val,
	       val2,
	       vn,
	       vn2,
      	       grad.x,
      	       grad2.x,
      	       grad.y,
      	       grad2.y,
      	       grad.z,
      	       /* grad2.z */spline2d_eval (sp, ui, vj, 14),
	       dzz,
	       dzz2);
      
      e0_1 += fabs(val-val2)/* /fabs(val) */;
      e1_1 += fabs(vn-vn2)/* /fabs(vn) */;
      e2_1 += fabs(grad.x-grad2.x)/* /fabs(grad.x) */;
      e3_1 += fabs(grad.y-grad2.y)/* /fabs(grad.y) */;
      e4_1 += fabs(grad.z-/* grad2.z */spline2d_eval (sp, ui, vj, 14))/* /fabs(grad.z) */;
      e5_1 += fabs(dzz-dzz2);

      e0_2 += pow(fabs(val-val2),2);
      e1_2 += pow(fabs(vn-vn2),2);
      e2_2 += pow(fabs(grad.x-grad2.x),2);
      e3_2 += pow(fabs(grad.y-grad2.y),2);
      e4_2 += pow(fabs(grad.z-/* grad2.z */spline2d_eval (sp, ui, vj, 14)),2);
      e5_2 += pow(fabs(dzz-dzz2),2.);

      if (e0_max < fabs(val-val2))
	e0_max = fabs(val-val2);
      if (e1_max < fabs(vn-vn2))
	e1_max = fabs(vn-vn2);
      if (e2_max < fabs(grad.x-grad2.x))
	e2_max = fabs(grad.x-grad2.x);
      if (e3_max < fabs(grad.y-grad2.y))
	e3_max = fabs(grad.y-grad2.y);
      if (e4_max < fabs(grad.z-/* grad2.z */spline2d_eval (sp, ui, vj, 14)))
	e4_max = fabs(grad.z-/* grad2.z */spline2d_eval (sp, ui, vj, 14));
      if (e5_max < fabs(dzz-dzz2))
	e5_max = fabs(dzz-dzz2);

      count += 1.;
    }
    fprintf(fp, "\n");
  }
  e0_1 /= count;
  e1_1 /= count;
  e2_1 /= count;
  e3_1 /= count;
  e4_1 /= count;
  e5_1 /= count;

  e0_2 = sqrt(e0_2)/count;
  e1_2 = sqrt(e1_2)/count;
  e2_2 = sqrt(e2_2)/count;
  e3_2 = sqrt(e3_2)/count;
  e4_2 = sqrt(e4_2)/count;
  e5_2 = sqrt(e5_2)/count;

  fprintf(stdout,"Error1  : %e  %e  %e %e %e  %e\n", e0_1, e1_1, e2_1, e3_1, e4_1, e5_1);
  fprintf(stdout,"Error2  : %e  %e  %e %e %e  %e\n", e0_2, e1_2, e2_2, e3_2, e4_2, e5_1);
  fprintf(stdout,"ErrorInf: %e  %e  %e %e %e  %e\n", e0_max, e1_max, e2_max, e3_max, e4_max, e5_max);
  
  fclose (fp);
}

static gdouble spheroid_fs_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);

  return -10. + 15.*u;

  return -20. + 30.*u;

  return -20. + 24*u;

  return -10. + 14.*u;

    return -8 + 12.*u;
}

static gdouble spheroid_fs_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  // return -2.+4*v;

  // return v < 0.2 ? -8. + v/0.2*5.0 : v < 0.8 ? -3. + (v-0.2)/0.6*6. : 3 + (v-0.8)/0.2*5.;

  return v < 0.15 ? -6. + v/0.15*2 : v < 0.85 ? -4. + (v-0.15)/0.7*8. : 4. + (v-0.85)/0.15*2;

  return v < 0.15 ? -10. + v/0.15*4 : v < 0.85 ? -6. + (v-0.15)/0.7*12. : 6. + (v-0.85)/0.15*4;

  return v < 0.2 ? -6. + v/0.2*3 : v < 0.8 ? -3. + (v-0.2)/0.6*6. : 3. + (v-0.8)/0.2*3;

  return v < 0.2 ? -4. + v/0.2*2.5 : v < 0.8 ? -1.5 + (v-0.2)/0.6*3. : 1.5 + (v-0.8)/0.2*2.5;
  return v < 0.15 ? -3. + v/0.15*1.5 : v < 0.85 ? -1.5 + (v-0.15)/0.7*3. : 1.5 + (v-0.85)/0.15*1.5;
}

static gdouble spheroid_wu_fs_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  Simulation * sim = (Simulation *) data;

  gdouble length = 2.*sim->wp.r1;

  return u < 0.15 ? -length/2. + length/4.*u/0.15 : u < 0.85 ? -length/4. + (u-0.15)/0.7*length/2. : length/4.*(1+(u-0.85)/0.15); 

  return -sim->wp.r1 + 2*sim->wp.r1*u;
}

static gdouble spheroid_wu_fs_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  Simulation * sim = (Simulation *) data;

  gdouble length = 2.*sim->wp.r2;

  return v < 0.15 ? -length/2. + length/4.*v/0.15 : v < 0.85 ? -length/4. + (v-0.15)/0.7*length/2. : length/4.*(1+(v-0.85)/0.15); 

  return -length/2. + length*v;
}

static gdouble spheroid_fs_bathy_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);

  return -5 + 8.*u;
}

static gdouble spheroid_fs_bathy_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble v = (1.-g_array_index (spp->outer->vj, gdouble, n));

  return -2.+4*v;

  return v < 0.2 ? -4. + v/0.2*2.5 : v < 0.8 ? -1.5 + (v-0.2)/0.6*3. : 1.5 + (v-0.8)/0.2*2.5;
  return v < 0.15 ? -3. + v/0.15*1.5 : v < 0.85 ? -1.5 + (v-0.15)/0.7*3. : 1.5 + (v-0.85)/0.15*1.5;
}

static void print_crossection (Spline2D * sp)
{
  FILE * fp = fopen ("crossection.tmp","w");

  gdouble u, du = 0.0031249999999;
  gdouble v = 0.5;

  for ( u = 0; u < 1-0.0125 ; u += du) {
    fprintf (fp, "%f %f %f \n", spline2d_eval (sp, u, v, 0), spline2d_eval (sp, u, v, 1), spline2d_eval (sp, u, v, 9));
  }

  fclose (fp);
}

static void add_disturbance_flow (Simulation * sim,
				  Forces * f, gdouble t,
				  gdouble u[6], gdouble x[6],
				  gboolean prediction)
{
  //g_test_timer_start ();
  //  simulation_calculate_gradients (sim);
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

#if 0
  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }
#endif
}

/**
 * To reproduce the quantitative wakes of Figure 6.3 of (Scullen,1998),
 * the Froude number needs adjusting here and in spheroid.sh. And
 * spheroid.GDF should be re-generated.
 **/
static void test_spheroid (Simulation * sim)
{
  // Initialising of simulation
  gdouble Froude = 1.2;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 1.;
  sim->U.y = sim->U.z = 0.;

  sim->wp.g = sim->g = 1./L*pow(sim->U.x/Froude,2.);

  sim->wp.g = sim->g = 1.;
  L = 1./(pow (Froude, 2.));

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end = 40.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005/* 0.004/sqrt(sim->g*L) */;

  //sim->wp.g = 9.81;
  sim->wp.A = 1.;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // No forcing
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 10./* 2.5 */;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  //sim->build_boundary_subproblem = build_boundary_subproblem_collocation;
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_rectangle_spheroid;
  sim->wp.Cs = 3/* 0 */; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = explicit_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update;
  sim->fs_elevation_rhs_store = NULL;
  sim->fs_elevation_rhs_store = abm4_free_surface_elevation_disturbance_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->fs_potential_update = explicit_free_surface_disturbance_potential_update;
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson
  sim->fs_potential_update = abm4_free_surface_disturbance_potential_update;
  sim->fs_potential_rhs_store = NULL;
  sim->fs_potential_rhs_store = abm4_free_surface_disturbance_potential_store;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("spheroid.GDF","r");
  GSList * patches = NULL;
  

  hull_read (sim->hull, fp, 10, 10, FALSE, FALSE, FALSE, FALSE);
  fclose (fp);

  freesurface_init (fs, &sim->wp);

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  sim->hull->wet_patches = sim->hull->patches;

  fs->s->b->dcb = hull_intersect_with_free_surface (sim->hull, fs->s->hz, sim->time.t, &sim->wp, sim->N);

  bathymetry_init (bathy, fs->s->b->dcb, &sim->wp);
    
  boundaries_init (fs->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  boundaries_init (bathy->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  FILE * fout = fopen ("boundaries.tmp","w");
  boundaries_print (fs->s->b, fout);
  fclose (fout);
    
  fout = fopen ("boundaries2.tmp","w");
  boundaries_print (bathy->s->b, fout);
  fclose (fout);
  
  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (/* 60 *//* 55 */ 40, /* 90 *//* 85 */60, spheroid_fs_x, spheroid_fs_y, NULL)); 


  fout = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fout);
  fclose (fout);


  FILE * ff = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  Spline2D * tmpsp = fs->s->patches->data;
  tmpsp->fit = tmpsp->build_fit_matrix (tmpsp);


  bathy->s->patches = g_slist_append (bathy->s->patches, parametric_grid (/* 25 */20, /* 25 */20, spheroid_fs_x, spheroid_fs_y, NULL));
  coeff_set_var_to_constant (bathy->s->patches->data, 2, -0.5);
  
  ff = fopen ("norm3.tmp","w");
  ppp = bathy->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  fout = fopen ("bathy.tmp", "w");
  spline2d_surface_print_grid (bathy->s, fout);
  fclose (fout);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  solve_boundary_problem_for_basis_flow (sim);

  //   spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection, sim, 7);

  simulation_calculate_gradients_linear (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  // g_assert_not_reached ();
  // Dummy matrix of inertia
  sim->hull->mg = 1.;
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 1.;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  initialise_motion (sim);

  sim->forces = g_slist_append (sim->forces, add_disturbance_flow);

  FILE * fp_forces = fopen ("forces_spheroid.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull / free-surface **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);

    // Update time

    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->fs->s->patches->data, 9);
      spline2d_filter_variable (sim->fs->s->patches->data, 7);
      spline2d_filter_variable (sim->fs->s->patches->data, 18);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_crossection (sim->fs->s->patches->data);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

static void test_spheroid_bathy (Simulation * sim)
{
  // Initialising of simulation
  gdouble Froude = 0.5;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end = 10.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.004/sqrt(sim->g*L);

  sim->wp.g = 9.81;
  sim->wp.A = 1.;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // No forcing
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 10./* 2.5 */;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  //sim->build_boundary_subproblem = build_boundary_subproblem_collocation;
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_rectangle_spheroid;
  sim->wp.Cs = 30.; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("spheroid.GDF","r");
  GSList * patches = NULL;
  

  hull_read (sim->hull, fp, 10, 10, FALSE, FALSE, FALSE, FALSE);
  fclose (fp);

  freesurface_init (fs, &sim->wp);

  hull_print (sim->hull, NULL);
  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);


  fs->s->b->dcb = hull_intersect_with_free_surface (sim->hull, fs->s->hz, sim->time.t, &sim->wp, sim->N);

  bathymetry_init (bathy, fs->s->b->dcb, &sim->wp);
    
  boundaries_init (fs->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  boundaries_init (bathy->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  FILE * fout = fopen ("boundaries.tmp","w");
  boundaries_print (fs->s->b, fout);
  fclose (fout);
    
  fout = fopen ("boundaries2.tmp","w");
  boundaries_print (bathy->s->b, fout);
  fclose (fout);
    
  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (50, 50, spheroid_fs_x, spheroid_fs_y, NULL));
  //  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80, 80, spheroid_fs_x, spheroid_fs_y, NULL));

  fout = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fout);
  fclose (fout);


  FILE * ff = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  //surface_generate_grid (bathy->s, TRUE);

  //spline2d_discretize_bathymetry (bathy->s->patches->data, &sim->wp, sim->time.t);

  bathy->s->patches = g_slist_append (bathy->s->patches, parametric_grid (30, 30, spheroid_fs_bathy_x, spheroid_fs_bathy_y, NULL));
  coeff_set_var_to_constant (bathy->s->patches->data, 2, -0.5);
  
  ff = fopen ("norm3.tmp","w");
  ppp = bathy->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  fout = fopen ("bathy.tmp", "w");
  spline2d_surface_print_grid (bathy->s, fout);
  fclose (fout);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  solve_boundary_problem_for_basis_flow (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  //g_assert_not_reached ();

  FILE * fp_forces = fopen ("forces_spheroid.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    sim->time.dt = sim->time.dt = 0.01/sqrt(sim->g*L);

    // New geometry / regrid
    
    // Store old value of phi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of dzPhi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
    // Store old value of dzphi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    simulation_calculate_gradients (sim);

    /** Time integration of free-surface condition
        for wave elevation. **/
    sim->fs_elevation_update (sim, sim->time.t, FALSE);

    /** Time integration of free-surface condition
        for disturbance potential **/
    sim->fs_potential_update (sim, sim->time.t, FALSE);

    /** Solve boundary problem for disturbance potential **/
    solve_boundary_problem_for_disturbance_flow (sim);

    /* if (sim->time.itime == 2) { */
    /*   print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */
    /*   //print_free_surface (sim->bathy->s->patches, &sim->wp, sim->time.t); */
    /*   g_assert_not_reached (); */
    /* } */

    /** Calculate forces on the hull **/
    Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, fs->s->hz, sim->time.t, &sim->wp);

    /** Print forces on the hull **/
    forces_total_print (f, fp_forces, &sim->time);

    g_free (f);

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
      //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //print_crossection (sim->fs->s->patches->data);
    }
    if ( sim->time.itime%200 == 0 ) {
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_crossection (sim->fs->s->patches->data);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
} 

static gdouble spheroid_of_fs_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);

  return u < 0.1 ? -10. + u/0.1*4. : u < 0.9 ? -6. + (u-0.1)/0.8*12.0 : 6 + (u-0.9)/0.1*4.;
  return u < 0.1 ? -5. + u/0.1*2. : u < 0.9 ? -3. + (u-0.1)/0.8*6.0 : 3 + (u-0.9)/0.1*2.;
  return -5 + 10.*u;
}

static gdouble spheroid_of_fs_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return v < 0.1 ? -10. + v/0.1*4. : v < 0.9 ? -6. + (v-0.1)/0.8*12.0 : 6 + (v-0.9)/0.1*4.;
  return v < 0.1 ? -5. + v/0.1*2. : v < 0.9 ? -3. + (v-0.1)/0.8*6.0 : 3 + (v-0.9)/0.1*2.;

  return -5 + 10.*v;
}

static gdouble spheroid_of_bathy_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = (1.-g_array_index (spp->outer->ui, gdouble, m));

  return u < 0.1 ? -10. + u/0.1*4. : u < 0.9 ? -6. + (u-0.1)/0.8*12.0 : 6 + (u-0.9)/0.1*4.;
  return u < 0.1 ? -5. + u/0.1*2. : u < 0.9 ? -3. + (u-0.1)/0.8*6.0 : 3 + (u-0.9)/0.1*2.;
  return -5 + 10.*u;
}

static gdouble spheroid_of_bathy_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return v < 0.1 ? -6. + v/0.1*4. : v < 0.9 ? -6. + (v-0.1)/0.8*12.0 : 6 + (v-0.9)/0.1*4.;
  return v < 0.1 ? -5. + v/0.1*2. : v < 0.9 ? -3. + (v-0.1)/0.8*6.0 : 3 + (v-0.9)/0.1*2.;

  return -5 + 10.*v;
}

static void tmp_print (Spline2D * sp, Simulation * sim)
{
  gdouble u, v;
  FILE * fp = fopen ("tmp_print.tmp","w");

  for ( u = 0; u <= 1.; u += 0.02 ) {
    for ( v = 0; v <= 1.; v += 0.02 ) {
      Point p = spline2d_eval_point (sp, u, v);
      Vector grad = finite_depth_wave_potential_gradient (&sim->wp, p, 0);
      fprintf (fp, "%f %f %f %f %f %f \n", p.x, p.y, finite_depth_wave_elevation (p.x, p.y, sim->time.t, &sim->wp)  /* finite_depth_wave_potential (&sim->wp, p,0.) */, grad.x, grad.y, grad.z);
    }
  }

  fclose (fp);
  g_assert_not_reached ();
}

static gdouble circ_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  /* if ( u < 0.25 ) */
  /*   u = u*0.425/0.25; */
  /* else if ( u < 0.75) */
  /*   u = 0.425+ (u-0.25)/0.5*0.15; */
  /* else */
  /*   u = 0.575+(u-0.75)*0.425/0.25; */

  /* return 15 + (5+20*v)*cos(2.*M_PI*(1-u)); */

  return 15 + (5+40*v)*cos(2.*M_PI*(1-u));

  return *r*v*cos(2.*M_PI*u);
}

static gdouble circ_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  /*  if ( u < 0.25 ) */
  /*   u = u*0.425/0.25; */
  /* else if ( u < 0.75) */
  /*   u = 0.425+ (u-0.25)/0.5*0.15; */
  /* else */
  /*   u = 0.575+(u-0.75)*0.425/0.25; */

  /* return (5+20*v)*sin(2.*M_PI*(1-u)); */

  return (5+40*v)*sin(2.*M_PI*(1-u));

  return *r*v*sin(2.*M_PI*u);
}

static gdouble circ_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  return 0.;
}

Spline2D * circular_fs (gint M, gint N, gdouble r, Simulation * sim,
			gint k, gint ninner, gint nouter)
{
  Spline2D * grid = periodic_fs_new (M, N, k, ninner, nouter);

  grid->noflux = FALSE;
  periodic_fs_init_panels (grid);

  CCSProblem * fit = periodic_fs_build_galerkin_fit_matrix_no_metric (grid);

  gsl_vector * rhs_x = periodic_fs_build_galerkin_rhs_gauss_no_metric (grid, circ_x, &r, NULL, NULL);
  gsl_vector * rhs_y = periodic_fs_build_galerkin_rhs_gauss_no_metric (grid, circ_y, &r, NULL, NULL);
  gsl_vector * rhs_z = periodic_fs_build_galerkin_rhs_gauss_no_metric (grid, circ_z, &r, NULL, NULL);
  
  ccs_problem_lu_solve (fit, rhs_x);
  ccs_problem_lu_solve (fit, rhs_y);
  ccs_problem_lu_solve (fit, rhs_z);

  periodic_fs_copy_problem_solution_no_metric (grid, rhs_x, 0);
  periodic_fs_copy_problem_solution_no_metric (grid, rhs_y, 1);
  //periodic_fs_copy_problem_solution_no_metric (grid, rhs_z, 2);
 
  periodic_fs_reinit_panels_physical_quantities (grid);

  gsl_vector_free (rhs_x);
  gsl_vector_free (rhs_y);
  gsl_vector_free (rhs_z);
  ccs_problem_destroy (fit);

  periodic_fs_numbering (grid);

  return grid;
}

static void test_spheroid_in_oscillatory_flow (Simulation * sim)
{
  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.01/sqrt(sim->g*L);

  sim->wp.g = 9.81;
  sim->wp.A = 0.15;
  sim->wp.w = 1.5*sqrt(0.5*9.81);
  sim->wp.h = 2.5;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  //sim->wp.k = M_PI;
  fprintf (stderr, " k is %e \n", sim->wp.k );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);
  
  // For monochronatic finite-depth forcing
  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;
  sim->wp.wave_normal_time_derivative = finite_depth_wave_normal_time_derivative;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 10./* 2.5 */;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_oscillatory_spheroid;
  sim->wp.Cs = 40.; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;
  sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update;
  sim->fs_elevation_rhs_store = abm4_free_surface_elevation_disturbance_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;
  sim->fs_potential_update = abm4_free_surface_disturbance_potential_update;
  sim->fs_potential_rhs_store = abm4_free_surface_disturbance_potential_store;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("spheroid.GDF","r");
  GSList * patches = NULL;
  

  hull_read (sim->hull, fp, 10, 10, FALSE, FALSE, FALSE, FALSE);
  fclose (fp);

  /* freesurface_init (fs, &sim->wp); */

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  sim->hull->wet_patches = sim->hull->patches;
    
  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80, 80, spheroid_of_fs_x, spheroid_of_fs_y, NULL));
  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (50, 50, spheroid_of_fs_x, spheroid_of_fs_y, NULL));

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);


  FILE * ff = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  //surface_generate_grid (bathy->s, TRUE);

  //spline2d_discretize_bathymetry (bathy->s->patches->data, &sim->wp, sim->time.t);
  /* fout = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fout); */
  /* fclose (fout); */

  /* ff = fopen ("norm3.tmp","w"); */
  /* ppp = bathy->s->patches->data; */
  /* spline2d_print_normals (ppp, ff); */
  /* fclose(ff); */

   print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); 

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  /** Solve boundary problem for basis flow **/
  //solve_boundary_problem_for_basis_flow (sim);    
  /* print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */
  /* g_assert_not_reached (); */
  simulation_calculate_gradients_linear (sim);

  sim->hull->mg = 1.;
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 1.;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  initialise_motion (sim);

  sim->forces = g_slist_append (sim->forces, add_disturbance_flow);

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    

    /** Equation of motion for the hull / free-surface **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->fs->s->patches->data, 9);
      spline2d_filter_variable (sim->fs->s->patches->data, 7);
      spline2d_filter_variable (sim->fs->s->patches->data, 18);
      
    }
    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

static gdouble gaussian_shape_test_advection2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  return 0.6*exp(-(p.x - 3.)*(p.x - 3.))*exp(-p.y*p.y);
}

static gdouble metrix_test_grid_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);

  return 2.5*(-4. + 8*u+ 0.2*sin (15*v));
}

static gdouble metrix_test_grid_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);

  return 2.5*(-4 + 8.*v + 0.8*cos (10*u));
  return -(1+4.*v)*sin(2.*M_PI*u +  M_PI);
}

gdouble half_sphere_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 15+5.*cos(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
  return -0.5*cos(M_PI*v);
  return -1.*cos(M_PI*v);
}

gdouble half_sphere_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 5*sin(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
  return /* 0.125 */0.5*sin(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 1.*sin(2.*M_PI*u)*sin(M_PI*v);
}

gdouble half_sphere_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return /* 1e-8 */ - 5.*cos(M_PI/2.*(1.-v));
  return 1e-8+0.05*cos(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 0.5*cos(2.*M_PI*u)*sin(M_PI*v);
}

static gdouble gaussian_ring (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);

  gdouble r = sqrt((p.x/* -10 *//* 5. */)*(p.x/* -10 *//* 5 */) + p.y*p.y);

  return 0.6*exp(-(r-10.)*(r-10.));
  return 0.6*exp(-(r-15)*(r-15));

  return 0.6*exp(-(p.x - 1.)*(p.x - 1.))*exp(-p.y*p.y);
}

/* static gdouble gaussian_ring (SPPanel * spp, gint m, gint n, gpointer data) */
/* { */
/*   Spline2D * sp = spp->sp; */
/*   GaussPoints * gp = spp->outer; */
/*   gint ng = sp->nouter; */

/*   Point p = g_array_index (gp->Pi, Point, m + n*ng); */

/*   gdouble r = sqrt((p.x + 10. /\* - 15. *\/)*(p.x + 10./\* -15. *\/) + p.y*p.y); */

/*   return 0.6*exp(-(r-8/\* 5 *\/)*(r-8/\* 5 *\/)); */

/*   return 0.6*exp(-(p.x - 1.)*(p.x - 1.))*exp(-p.y*p.y); */
/* } */

static gdouble centered_gaussian_ring (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  gdouble u = g_array_index (gp->ui, gdouble, m);

  gdouble r = sqrt((p.x)*(p.x) + p.y*p.y);

  return 0.6*exp(-(r-15)*(r-15)/4.)*(1 + 0.1*sin(8.*M_PI*u));

  return 0.6*exp(-(p.x - 1.)*(p.x - 1.))*exp(-p.y*p.y);
}

#if 1
gdouble test_propagation (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = 0./* 4 */;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  4.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.001;

  sim->wp.g = 9.81;
  sim->wp.A = 1.;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  // Radius of domain
  sim->wp.r1 = /* 10. */3.;
  sim->wp.r2 = /* 10. */3.;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = NULL;

  /** Free-surface elevation advection scheme **/
  //sim->fs_elevation_update = leapfrog_no_speed_elevation_update;
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;

  /** Free-surface potential advection scheme **/
  //sim->fs_potential_update = semi_implicit_no_speed_potential_update;
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->beta = 0./* 5 */; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 10,
										      half_sphere_x,
										      half_sphere_y,
										      half_sphere_z,
										      NULL, 3, 4, 3)); 

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Weirdly stretched grid
  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80, 80, metrix_test_grid_x2, metrix_test_grid_y2, NULL));

  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid2 (sim->M, sim->N, testfs_x2, testfs_y2, fs->s));

  // Rectangular grid
  /* fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (70, 70, spheroid_of_fs_x, spheroid_of_fs_y, NULL)); */
  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (50, 50, spheroid_of_fs_x, spheroid_of_fs_y, NULL));

  // fs->s->patches = g_slist_append (fs->s->patches, circular_fs (80, 80, 20, sim, 3, 4, 3));
  
  fs->s->patches = g_slist_append (fs->s->patches, circular_fs (50, 50, 20, sim, 3, 4, 3));

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");


  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  spline2d_fit_galerkin (fs->s->patches->data, gaussian_ring, sim, 9);

  /* spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 9); */

  


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());


  simulation_calculate_gradients (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

   // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  /* spline2d_list_copy_var (simulation_all_patches_list (sim), 23, 34); */
  /* spline2d_list_copy_var (simulation_all_patches_list (sim), 34, 35); */
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
  

  
  // g_assert_not_reached ();
  /** Solve boundary problem for disturbance potential **/
  /* solve_boundary_problem_for_disturbance_flow (sim); */

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

 // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    /* spline2d_list_copy_var (simulation_all_patches_list (sim), 23, 34); */
    /* spline2d_list_copy_var (simulation_all_patches_list (sim), 34, 35); */
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    

    /** Equation of motion for the hull **/

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    simulation_calculate_gradients (sim);

    /** Time integration of free-surface condition
        for wave elevation. **/
    sim->fs_elevation_update (sim, sim->time.t, FALSE);

    /** Time integration of free-surface condition
        for disturbance potential **/
    sim->fs_potential_update (sim, sim->time.t, FALSE);

    /** Solve boundary problem for disturbance potential **/
    solve_boundary_problem_for_disturbance_flow (sim);


    /* // For leapfrog */
    /* spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 22); */

    /* sim->time.dt = sim->time.dt = /\* 0.001 *\/0.005; */

    /* if (1) { */
    /*   gsl_vector * gsl_rhs; */
      
    /*   //gsl_rhs = sp->build_fit_rhs (sp, explicit_metric_test_rhs_gauss, sim); */
      
    /*   gsl_rhs = sp->build_fit_rhs (sp, leapfrog_metric_test_rhs_gauss, sim, NULL, NULL); */
      
    /*   /\* Solve the problem using superlu *\/ */
    /*   ccs_problem_lu_solve (sp->fit, gsl_rhs); */
      
    /*   sp->copy_fit_solution (sp, gsl_rhs, 9); */
      
    /*   gsl_vector_free (gsl_rhs); */
    /* } */
    /* else { */
    /*   semi_implicit_test_advection (sim); */
    /* } */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100 == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}
#else
gdouble test_propagation (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  20.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005;

  sim->wp.g = 9.81;
  sim->wp.A = 1.;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;

  // Radius of domain
  sim->wp.r1 = /* 10. */3.;
  sim->wp.r2 = /* 10. */3.;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = NULL;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 10,
										      half_sphere_x,
										      half_sphere_y,
										      half_sphere_z,
										      NULL, 3, 4, 3)); 

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Weirdly stretched grid
  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80, 80, metrix_test_grid_x2, metrix_test_grid_y2, NULL));

  // Rectangular grid
  /* fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (70, 70, spheroid_of_fs_x, spheroid_of_fs_y, NULL)); */
  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (50, 50, spheroid_of_fs_x, spheroid_of_fs_y, NULL));

  // Circular grid
  fs->s->patches = g_slist_append (fs->s->patches, circular_fs (80, 80, 20, sim, 3, 4, 3));
   //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (50, 50, 20, sim, 3, 4, 3));

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");


  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_ring, sim, 9);

  /* spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 9); */

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  /** Solve boundary problem for disturbance potential **/
  /* solve_boundary_problem_for_disturbance_flow (sim); */

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    

    /** Equation of motion for the hull **/

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    /** Time integration of free-surface condition
        for wave elevation. **/
    sim->fs_elevation_update (sim, sim->time.t, FALSE);

    /** Time integration of free-surface condition
        for disturbance potential **/
    sim->fs_potential_update (sim, sim->time.t, FALSE);

    /** Solve boundary problem for disturbance potential **/
    solve_boundary_problem_for_disturbance_flow (sim);


    /* // For leapfrog */
    /* spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 22); */

    /* sim->time.dt = sim->time.dt = /\* 0.001 *\/0.005; */

    /* if (1) { */
    /*   gsl_vector * gsl_rhs; */
      
    /*   //gsl_rhs = sp->build_fit_rhs (sp, explicit_metric_test_rhs_gauss, sim); */
      
    /*   gsl_rhs = sp->build_fit_rhs (sp, leapfrog_metric_test_rhs_gauss, sim, NULL, NULL); */
      
    /*   /\* Solve the problem using superlu *\/ */
    /*   ccs_problem_lu_solve (sp->fit, gsl_rhs); */
      
    /*   sp->copy_fit_solution (sp, gsl_rhs, 9); */
      
    /*   gsl_vector_free (gsl_rhs); */
    /* } */
    /* else { */
    /*   semi_implicit_test_advection (sim); */
    /* } */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100 == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}
#endif

gdouble half_sphere_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 2.5*cos(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v)); // Comment
  return 5.*cos(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v));
  return 5.*cos(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
  return -0.5*cos(M_PI*v);
  return -1.*cos(M_PI*v);
}

gdouble half_sphere_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 2.5/6.*sin(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v)); // Comment
  return 0.75/2.*sin(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v));
  /* return 2.5*sin(2.*M_PI*u)*sin(0.5*M_PI*(1.-v)); */
  /* return 5.*sin(2.*M_PI*u)*sin(0.5*M_PI*(1.-v)); */
  return /* 0.125 */0.5*sin(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 1.*sin(2.*M_PI*u)*sin(M_PI*v);
}

gdouble half_sphere_z2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return -2.5/10.*cos(M_PI/2.*(1.-v)); // Comment
  return -0.3/2.*cos(M_PI/2.*(1.-v));
  return -1.25*cos(M_PI/2.*(1.-v));
  return -5.*cos(M_PI/2.*(1.-v));
  return 1e-8+0.05*cos(/* 2.* */M_PI*u+M_PI/2.)*sin(M_PI*v);
  return 0.5*cos(2.*M_PI*u)*sin(M_PI*v);
}

static gdouble circ_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  // Log scaling in radial direction
  gdouble a = 5.;
  v = 1. - log(a*v+1.)/log(a+1.);

  return (5.+70.*v)*cos(2.*M_PI*(/* 1- */u));
  return (5+40*v)*cos(2.*M_PI*(1-u));

  return *r*v*cos(2.*M_PI*u);
}

static gdouble circ_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  GaussPoints * gp = spp->outer;
  gdouble u = g_array_index (gp->ui, gdouble, m);
  gdouble v = g_array_index (gp->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  // Log scaling in radial direction
  gdouble a = 5.;
  v = 1. - log(a*v+1.)/log(a+1.);

  return (0.75+74.25*v)*sin(2.*M_PI*(/* 1- */u));
  return (0.125+49.875*v)*sin(2.*M_PI*(1-u));
  return (2.5+42.5*v)*sin(2.*M_PI*(1-u));
  return (5+40*v)*sin(2.*M_PI*(1-u));

  return *r*v*sin(2.*M_PI*u);
}

static gdouble circ_z2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  return 0.;
}

gdouble numerical_beaches_radiation (gdouble x, gdouble y, gdouble z,
				     gpointer data)
{
  WaveParams * wp = (WaveParams *) data;
  gdouble r = sqrt(x/wp->r1*x/wp->r1 + y/wp->r2*y/wp->r2);

  /* if ( r > 0.8 ) */
  /*   return 3.*wp->Cs/pow(0.2, 3.)*pow(r-0.8, 3.); */
  /* else */
  /*   return 0.; */
  
  /* if ( r > 0.7 ) { */
  /*   return 3.*wp->Cs/pow(0.3, 3.)*pow(r-0.7, 3.); */
  /* } */
  /* else */
  /*   return 0.; */

  /* if ( r > 0.6 ) { */
  /*       return 3.*wp->Cs/pow(0.4, 3.)*pow(r-0.6, 3.); */
  /* } */
  /* else */
  /*   return 0.; */

  /* if ( r > 0.3 ) { */
  /*       return 3.*wp->Cs/pow(0.7, 3.)*pow(r-0.3, 3.); */
  /* } */
  /* else */
  /*   return 0.; */

  if ( r > 0.5 ) {
        return 3.*wp->Cs/pow(0.5, 3.)*pow(r-0.5, 3.);
  }
  else
    return 0.;

  if ( r > 0.6 ) {
        return 3.*wp->Cs/pow(0.6, 3.)*pow(r-0.4, 3.);
  }
  else
    return 0.;
    
  gdouble cosa = x/r;
  gdouble sina = y/r;

  gdouble r_outer = sqrt(wp->r1*wp->r1*cosa*cosa + wp->r2*wp->r2*sina*sina);

  gdouble r_inner = 0.7*r_outer;

  if ( r > r_inner )
    return  3.*wp->Cs/pow(r_outer-r_inner, 3.)*pow(r-r_inner, 3.);

  /* if ( r > 40. ) { */
  /*   return 3.*wp->Cs/pow(35., 3.)*pow(r-40., 3.); */
  /* } */
  if ( r > 35. ) {
    return 3.*wp->Cs/pow(15., 3.)*pow(r-35., 3.);
  }
  else
    return 0.;
}

static void local_linear_nospeed_forces_contribution (Spline2D * sp,
						      Simulation * sim,
						      gpointer data,
						      gdouble u, gdouble v,
						      gdouble weight, 
						      HeightCurve hz,
						      gdouble t,
						      gpointer hz_data)
{
  Forces * f = (Forces *) data;
  gdouble Ph = 0., Pfk = 0., Pl = 0.;
  gint k = sp->k;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gint NXU = sp->NXU;

  Vector xu, xv, gradphi2;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  gdouble phi2n = 0., phi2du = 0., phi2dv = 0., phi2 = 0.;
  Point p;
  p.x = p.y = p.z = 0.;

  gint  i, j;
  size_t istart, iend, jstart, jend, istart_x;
  gsl_matrix * Bu = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bu, &istart, &iend, sp->w_u, sp->wd_u);
  gsl_bspline_deriv_eval_nonzero (v, 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (u, 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  if (sp->periodic)
    istart -= sp->k-1;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    gint ii = istart;
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cudv = cu*cdv;
      gdouble cvdu = cv*cdu;
      gdouble cuv = cu*cv;
      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      SplineCoeffs * sc =
	g_ptr_array_index (sp->coeffs, iix+ jj*NXU);
      
      gdouble v0 = sc->v[0];
      gdouble v1 = sc->v[1];
      gdouble v2 = sc->v[2];

      sc = g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;

      phi2 += v7*cuv;
      phi2n += sc->v[8]*cuv;
      phi2du += v7*cvdu;
      phi2dv += v7*cudv;
      
    }
    ii++;
    iix++;
  }

  gsl_matrix_free (Bu);
  gsl_matrix_free (Bv);
  gsl_matrix_free (Bux);

  // Position in inertial reference frame
  //Point p_inertial = hull_transformed_point (sim->hull, p);
 
  /* Dimensional normal to the surface */
  Vector N = vector_vector_product (&xu, &xv);
  
  /* Jacobian */
  gdouble J = vector_norm (N);
  N.x /= J; N.y /= J; N.z /= J;
  gdouble det = xu.x*(xv.y*N.z-xv.z*N.y)
    - xu.y*(N.z*xv.x-xv.z*N.x)
    + xu.z*(xv.x*N.y-xv.y*N.x);
  det = 1./det;
  gdouble c1 = (xv.y*N.z-xv.z*N.y)*det;
  gdouble c2 = (xu.z*N.y-xu.y*N.z)*det;
  gdouble c3 = (xv.z*N.x-xv.x*N.z)*det;
  gdouble c4 = (xu.x*N.z-xu.z*N.x)*det;
  gdouble c5 = (xv.x*N.y-xv.y*N.x)*det;
  gdouble c6 = (N.x*xu.y-xu.x*N.y)*det;

  gradphi2.x = phi2n*N.x + c1*phi2du + c2*phi2dv;
  gradphi2.y = phi2n*N.y + c3*phi2du + c4*phi2dv;
  gradphi2.z = phi2n*N.z + c5*phi2du + c6*phi2dv;

  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p/* _inertial */, t);

  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p/* _inertial */, t);


 /* Hydrostatic pressure */
 //Ph = -sim->rho*sim->g*(p_inertial.z-hz(p_inertial.x, p_inertial.y, t, hz_data));
 Ph = -sim->rho*sim->g*(p.z-hz(p.x, p.y, t, hz_data));

 /* Froude Krylov-Forces */
 Pfk = -sim->rho*(dtphi0 + vector_scalar_product (&gradphi0, &gradphi0));

 /* Time local / radiation forces */
 Pl = -sim->rho*vector_scalar_product (&gradphi0,&gradphi2);

 J *= weight;

 gdouble wh = J*Ph;
 gdouble wfk = J*Pfk;
 gdouble wl = J*Pl;
 gdouble wphi2 = J*phi2;

 f->forces_h[0] += wh*N.x;
 f->forces_h[1] += wh*N.y;
 f->forces_h[2] += wh*N.z;

 f->forces_fk[0] += wfk*N.x;
 f->forces_fk[1] += wfk*N.y;
 f->forces_fk[2] += wfk*N.z;

 f->forces_l[0] += wl*N.x;
 f->forces_l[1] += wl*N.y;
 f->forces_l[2] += wl*N.z;

 f->phi2[0] += wphi2*N.x;
 f->phi2[1] += wphi2*N.y;
 f->phi2[2] += wphi2*N.z;

 /* Moments */
 Vector x;
 Point xg = sim->hull->xg;
 x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z;
 x = vector_vector_product (&x, &N);

 f->forces_h[3] += wh*x.x;
 f->forces_h[4] += wh*x.y;
 f->forces_h[5] += wh*x.z;

 f->forces_fk[3] += wfk*x.x;
 f->forces_fk[4] += wfk*x.y;
 f->forces_fk[5] += wfk*x.z;

 f->forces_l[3] += wl*x.x;
 f->forces_l[4] += wl*x.y;
 f->forces_l[5] += wl*x.z;

 f->phi2[3] += wphi2*x.x;
 f->phi2[4] += wphi2*x.y;
 f->phi2[5] += wphi2*x.z;
}

static Pressure local_linear_nospeed_gauss (SPPanel * spp,
					    gint m, gint n,
					    Simulation * sim,
					    HeightCurve hz,
					    gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m+n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.Pm = pressure.Pl = pressure.Ph = 0.;
  pressure.Pfk = pressure.Pr = pressure.phi2 = 0.;

  Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);

  Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble Phi2n = 0., Phi2 = 0., dPhi2du = 0., dPhi2dv = 0./* , zeta = 0. */;
  Vector gradPhi2;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc = g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

      dPhi2du += v7*cv*cdu;
      dPhi2dv += v7*cu*cdv;
      Phi2n += sc->v[8]*cuv;
      Phi2 += v7*cuv;
      //zeta += sc->v[9]*cuv;
    }
  }

  /* Vector gradPhi2; */
  gradPhi2.x = Phi2n*N.x + c1*dPhi2du + c2*dPhi2dv;
  gradPhi2.y = Phi2n*N.y + c3*dPhi2du + c4*dPhi2dv;
  gradPhi2.z = Phi2n*N.z + c5*dPhi2du + c6*dPhi2dv;

  /* Hydrostatic pressure */

  // Takes FS deformation into account for hydrostatic forces
  //  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  // Does not take FS deformation into account for hydrostatic forces
  pressure.Ph = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data));
  // Which one should be used ??

  /* Froude-Krylov forces */
  pressure.Pfk = -sim->rho*(dtphi0 /* + vector_scalar_product (&gradphi0, &gradphi0) */);

  /* Time local /radiation forces */
  pressure.Pl = -sim->rho*vector_scalar_product (&gradphi0, &gradPhi2);

  /* Phi2 */
  pressure.phi2 = -sim->rho*Phi2;

  return pressure;
}

static Pressure local_linear_nospeed_maccamy_gauss (SPPanel * spp,
						     gint m, gint n,
						     Simulation * sim,
						     HeightCurve hz,
						     gdouble t,
						     gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m+n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.Pm = pressure.Pl = pressure.Ph = 0.;
  pressure.Pfk = pressure.Pr = pressure.phi1 = 0.;
  pressure.Pm2 = pressure.Pl2 = pressure.Pfk2 = pressure.phi2 = 0.;

  Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);

  Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble Phi1 = 0., Phi1n = 0., dPhi1du = 0., dPhi1dv = 0.;
  gdouble Phi2n = 0., Phi2 = 0., dPhi2du = 0., dPhi2dv = 0.;
  Vector gradPhi1, gradPhi2;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc = g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

      dPhi1du += v7*cv*cdu;
      dPhi1dv += v7*cu*cdv;
      Phi1n += sc->v[8]*cuv;
      Phi1 += v7*cuv;

      dPhi2du += sc->v[34]*cv*cdu;
      dPhi2dv += sc->v[34]*cu*cdv;
      Phi2n += sc->v[35]*cuv;
      Phi2 += sc->v[34]*cuv;
    }
  }

  gradPhi1.x = Phi1n*N.x + c1*dPhi1du + c2*dPhi1dv;
  gradPhi1.y = Phi1n*N.y + c3*dPhi1du + c4*dPhi1dv;
  gradPhi1.z = Phi1n*N.z + c5*dPhi1du + c6*dPhi1dv;

  /* Vector gradPhi2; */
  gradPhi2.x = Phi2n*N.x + c1*dPhi2du + c2*dPhi2dv;
  gradPhi2.y = Phi2n*N.y + c3*dPhi2du + c4*dPhi2dv;
  gradPhi2.z = Phi2n*N.z + c5*dPhi2du + c6*dPhi2dv;

  /* Hydrostatic pressure */

  // Takes FS deformation into account for hydrostatic forces
  //  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  // Does not take FS deformation into account for hydrostatic forces
  pressure.Ph = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data));
  // Which one should be used ??

  /* Froude-Krylov forces */
  pressure.Pfk = -sim->rho*(dtphi0 /* + vector_scalar_product (&gradphi0, &gradphi0) */);

  /* Time local /radiation forces */
  pressure.Pl = -sim->rho*(vector_scalar_product (&gradphi0, &gradPhi1)
			   + vector_scalar_product (&gradphi0, &gradphi0));

  /* Phi2 */
  pressure.phi1 = -sim->rho*Phi1;
  pressure.phi2 = -sim->rho*Phi2;

  return pressure;
}

static void sppanel_linear_nospeed_forces_integral_gauss (SPPanel * spp,
							  Simulation * sim,
							  gpointer data,
							  gint m, gint n,
							  HeightCurve hz,
							  gdouble t,
							  gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_nospeed_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph;
  gdouble wfk = wij*lp.Pfk;
  gdouble wl = wij*lp.Pl;
  gdouble wphi2 = wij*lp.phi2;

  f->forces_h[0] += wh*N.x;
  f->forces_h[1] += wh*N.y;
  f->forces_h[2] += wh*N.z;
  
  f->forces_fk[0] += wfk*N.x;
  f->forces_fk[1] += wfk*N.y;
  f->forces_fk[2] += wfk*N.z;

  f->forces_l[0] += wl*N.x;
  f->forces_l[1] += wl*N.y;
  f->forces_l[2] += wl*N.z;

  f->phi2[0] += wphi2*N.x;
  f->phi2[1] += wphi2*N.y;
  f->phi2[2] += wphi2*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h[3] += wh*x.x;
  f->forces_h[4] += wh*x.y;
  f->forces_h[5] += wh*x.z;

  f->forces_fk[3] += wfk*x.x;
  f->forces_fk[4] += wfk*x.y;
  f->forces_fk[5] += wfk*x.z;

  f->forces_l[3] += wl*x.x;
  f->forces_l[4] += wl*x.y;
  f->forces_l[5] += wl*x.z;

  f->phi2[3] += wphi2*x.x;
  f->phi2[4] += wphi2*x.y;
  f->phi2[5] += wphi2*x.z;
}

static Pressure local_linear_gauss (SPPanel * spp,
					    gint m, gint n,
					    Simulation * sim,
					    HeightCurve hz,
					    gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m+n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.Pm = pressure.Pl = pressure.Ph = 0.;
  pressure.Pfk = pressure.Pr = pressure.phi2 = 0.;

  Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);

  Vector W = sim->U;
  Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble Phi2n = 0., Phi2 = 0., dPhi2du = 0., dPhi2dv = 0./* , zeta = 0. */;
  Vector gradPhi2;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc = g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

      dPhi2du += v7*cv*cdu;
      dPhi2dv += v7*cu*cdv;
      Phi2n += sc->v[8]*cuv;
      Phi2 += v7*cuv;
      //zeta += sc->v[9]*cuv;
    }
  }

  /* Vector gradPhi2; */
  gradPhi2.x = Phi2n*N.x + c1*dPhi2du + c2*dPhi2dv;
  gradPhi2.y = Phi2n*N.y + c3*dPhi2du + c4*dPhi2dv;
  gradPhi2.z = Phi2n*N.z + c5*dPhi2du + c6*dPhi2dv;

  /* Hydrostatic pressure */

  // Takes FS deformation into account for hydrostatic forces
  //  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  // Does not take FS deformation into account for hydrostatic forces
  pressure.Ph = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data));  

  W.x -= fsd.gradPhi.x;
  W.y -= fsd.gradPhi.y;
  W.z -= fsd.gradPhi.z;

  pressure.Pl = -sim->rho*(fsd.dtPhi - vector_scalar_product (&W, &fsd.gradPhi) - 0.5*vector_scalar_product (&fsd.gradPhi, &fsd.gradPhi));

  W.x -= gradphi0.x;
  W.y -= gradphi0.y;
  W.z -= gradphi0.z;

  /* Froude-Krylov forces */
  pressure.Pfk = -sim->rho*(dtphi0 - vector_scalar_product (&W, &gradphi0));

  /* Time local /radiation forces */
  pressure.Pm = sim->rho*(vector_scalar_product (&W, &gradPhi2));
  
  /* Phi2 */
  pressure.phi2 = -sim->rho*Phi2;

  return pressure;
}

static void sppanel_linear_forces_integral_gauss (SPPanel * spp,
						  Simulation * sim,
						  gpointer data,
						  gint m, gint n,
						  HeightCurve hz,
						  gdouble t,
						  gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph;
  gdouble wfk = wij*lp.Pfk;
  gdouble wl = wij*lp.Pl;
  gdouble wphi2 = wij*lp.phi2;
  gdouble wm = wij*lp.Pm;

  f->forces_h[0] += wh*N.x;
  f->forces_h[1] += wh*N.y;
  f->forces_h[2] += wh*N.z;
  
  f->forces_fk[0] += wfk*N.x;
  f->forces_fk[1] += wfk*N.y;
  f->forces_fk[2] += wfk*N.z;

  f->forces_l[0] += wl*N.x;
  f->forces_l[1] += wl*N.y;
  f->forces_l[2] += wl*N.z;

  f->forces_m[0] += wm*N.x;
  f->forces_m[1] += wm*N.y;
  f->forces_m[2] += wm*N.z;

  f->phi2[0] += wphi2*N.x;
  f->phi2[1] += wphi2*N.y;
  f->phi2[2] += wphi2*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h[3] += wh*x.x;
  f->forces_h[4] += wh*x.y;
  f->forces_h[5] += wh*x.z;

  f->forces_fk[3] += wfk*x.x;
  f->forces_fk[4] += wfk*x.y;
  f->forces_fk[5] += wfk*x.z;

  f->forces_l[3] += wl*x.x;
  f->forces_l[4] += wl*x.y;
  f->forces_l[5] += wl*x.z;

  f->forces_m[3] += wm*x.x;
  f->forces_m[4] += wm*x.y;
  f->forces_m[5] += wm*x.z;

  f->phi2[3] += wphi2*x.x;
  f->phi2[4] += wphi2*x.y;
  f->phi2[5] += wphi2*x.z;
}

static void sppanel_linear_nospeed_maccamy_forces_integral_gauss (SPPanel * spp,
								   Simulation * sim,
								   gpointer data,
								   gint m, gint n,
								   HeightCurve hz,
								   gdouble t,
								   gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_nospeed_maccamy_gauss (spp, m, n, sim,
						     hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph;
  gdouble wfk = wij*lp.Pfk;
  gdouble wfk2 = wij*lp.Pfk2;
  gdouble wl = wij*lp.Pl;
  gdouble wl2 = wij*lp.Pl2;
  gdouble wphi1 = wij*lp.phi1;
  gdouble wphi2 = wij*lp.phi2;

  f->forces_h[0] += wh*N.x;
  f->forces_h[1] += wh*N.y;
  f->forces_h[2] += wh*N.z;
  
  f->forces_fk[0] += wfk*N.x;
  f->forces_fk[1] += wfk*N.y;
  f->forces_fk[2] += wfk*N.z;

  f->forces_l[0] += wl*N.x;
  f->forces_l[1] += wl*N.y;
  f->forces_l[2] += wl*N.z;

  f->phi1[0] += wphi1*N.x;
  f->phi1[1] += wphi1*N.y;
  f->phi1[2] += wphi1*N.z;

  f->forces_fk2[0] += wfk2*N.x;
  f->forces_fk2[1] += wfk2*N.y;
  f->forces_fk2[2] += wfk2*N.z;

  /* f->forces_l2[0] += wl2*N.x; */
  /* f->forces_l2[1] += wl2*N.y; */
  /* f->forces_l2[2] += wl2*N.z; */

  f->phi2[0] += wphi2*N.x;
  f->phi2[1] += wphi2*N.y;
  f->phi2[2] += wphi2*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h[3] += wh*x.x;
  f->forces_h[4] += wh*x.y;
  f->forces_h[5] += wh*x.z;

  f->forces_fk[3] += wfk*x.x;
  f->forces_fk[4] += wfk*x.y;
  f->forces_fk[5] += wfk*x.z;

  f->forces_l[3] += wl*x.x;
  f->forces_l[4] += wl*x.y;
  f->forces_l[5] += wl*x.z;

  f->phi1[3] += wphi1*x.x;
  f->phi1[4] += wphi1*x.y;
  f->phi1[5] += wphi1*x.z;

  f->forces_fk2[3] += wfk2*x.x;
  f->forces_fk2[4] += wfk2*x.y;
  f->forces_fk2[5] += wfk2*x.z;

  /* f->forces_l2[3] += wl2*x.x; */
  /* f->forces_l2[4] += wl2*x.y; */
  /* f->forces_l2[5] += wl2*x.z; */

  f->phi2[3] += wphi2*x.x;
  f->phi2[4] += wphi2*x.y;
  f->phi2[5] += wphi2*x.z;
}

gdouble calculate_mass_from_position_at_rest_linear (Hull * hull,
						     Simulation * sim)
{
  gdouble mass = 0.;

  gpointer tmp_func = sim->wp.wave_elevation;
  sim->wp.wave_elevation = flat_sea;

  // Calculates the hydrostatic forces given the position of the hull
  // and assuming a flat free-surface. For those the mass of the hull
  // can be derived
  /* Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, sim->wp.wave_elevation, sim->time.t, &sim->wp); */

  Forces f;

  forces_set_to_zero (&f);

  whole_hull_integration (sim->hull, sim, &f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  /* sim->wp.wave_elevation */flat_sea, sim->time.t, &sim->wp);

  hull->mg = sqrt(/* f->forces_h[0]*f->forces_h[0] */
		  /* + f->forces_h[1]*f->forces_h[1] */
		  /* +  */f.forces_h[2]*f.forces_h[2])/sim->g;
  
  fprintf (stderr, "Mass of the hull: %e kg \n", hull->mg);

  sim->wp.wave_elevation = tmp_func;
  return mass;
}

static Pressure local_huang_linear_nospeed_gauss (SPPanel * spp,
						  gint m, gint n,
						  Simulation * sim,
						  HeightCurve hz,
						  gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.Pm = pressure.Pl = pressure.Ph = 0.;
  pressure.Pfk = pressure.Pr = pressure.phi2 = 0.;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);

  Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint gindex = m + n*ng;
  Vector N = g_array_index (gp->Ni, Vector, gindex);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble Phi2n = 0., Phi2 = 0., dPhi2du = 0., dPhi2dv = 0., zeta = 0.;
  gdouble phin = 0., phi = 0., dphidu = 0., dphidv = 0.;
  Vector gradPhi2, gradphi;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc =
	g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];
      gdouble v5 = sc->v[5];

      dPhi2du += v7*cv*cdu;
      dPhi2dv += v7*cu*cdv;
      Phi2n += sc->v[8]*cuv;
      Phi2 += v7*cuv;

      dphidu += v5*cv*cdu;
      dphidv += v5*cu*cdv;
      phin += sc->v[6]*cuv;
      //phi += v5*cuv;

      zeta += sc->v[9]*cuv;
    }
  }
   
  /* Vector gradPhi2; */
  gradPhi2.x = Phi2n*N.x + c1*dPhi2du + c2*dPhi2dv;
  gradPhi2.y = Phi2n*N.y + c3*dPhi2du + c4*dPhi2dv;
  gradPhi2.z = Phi2n*N.z + c5*dPhi2du + c5*dPhi2dv;

  /* Vector gradphi; */
  gradphi.x = phin*N.x + c1*dphidu + c2*dphidv;
  gradphi.y = phin*N.y + c3*dphidu + c4*dphidv;
  gradphi.z = phin*N.z + c5*dphidu + c6*dphidv;

  Vector U = sim->U;

  U.x -= gradphi0.x;
  U.y -= gradphi0.y;
  U.z -= gradphi0.z;

  /* Second term of memory forces (Huang - p 35) */
  pressure.Pm = -sim->rho * ( dtphi0 - vector_scalar_product (&U, &gradphi0)
			      - 0.5* vector_scalar_product (&gradphi0, &gradphi0) );

  U.x -= gradphi.x;
  U.y -= gradphi.y;
  U.z -= gradphi.z;

  pressure.Pm += sim->rho * vector_scalar_product (&U, &gradPhi2);

  /* Hydrostatic pressure */
  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  //pressure.Ph = -sim->rho*sim->g *( p.z-(zeta + hz(p.x, p.y, t, hz_data)));

  /* pressure.Ph = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data)); */
  /* pressure.Ph = -sim->rho*sim->g *( p.z - hz(p.x, p.y, t, hz_data)); */


  /* Froude-Krylov forces */
  pressure.Pfk = -sim->rho*(dtphi0 + vector_scalar_product (&gradphi0, &gradphi0));

  /* Time local forces */
  //pressure.Pl = -sim->rho*vector_scalar_product (&gradphi0, &gradPhi2);
  pressure.Pl = -sim->rho*(- vector_scalar_product (&U, &gradphi) -0.5*vector_scalar_product (&gradphi, &gradphi));

  /* Memory forces */
  // pressure.Pm = -sim->rho*vector_scalar_product (&gradphi0, &gradPhi2);
  //pressure.Pm = -sim->rho*vector_scalar_product (&gradphi, &gradPhi2)

  /* Phi2 */
  pressure.phi2 = -sim->rho*Phi2;
  // pressure.phi = -sim->rho*phi;

  return pressure;
}

static void sppanel_huang_linear_nospeed_forces_integral_gauss (SPPanel * spp,
								Simulation * sim,
								gpointer data,
								gint m, gint n,
								HeightCurve hz,
								gdouble t,
								gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_huang_linear_nospeed_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph;
  gdouble wfk = wij*lp.Pfk;
  gdouble wl = wij*lp.Pl;
  gdouble wphi2 = wij*lp.phi2;
  gdouble wphi = wij*lp.phi;
  gdouble wm = wij*lp.Pm;

  f->forces_h[0] += wh*N.x;
  f->forces_h[1] += wh*N.y;
  f->forces_h[2] += wh*N.z;
  
  f->forces_fk[0] += wfk*N.x;
  f->forces_fk[1] += wfk*N.y;
  f->forces_fk[2] += wfk*N.z;

  f->forces_l[0] += wl*N.x;
  f->forces_l[1] += wl*N.y;
  f->forces_l[2] += wl*N.z;

  f->forces_m[0] += wm*N.x;
  f->forces_m[1] += wm*N.y;
  f->forces_m[2] += wm*N.z;

  f->phi2[0] += wphi2*N.x;
  f->phi2[1] += wphi2*N.y;
  f->phi2[2] += wphi2*N.z;

  /* f->phi[0] += wphi*N.x; */
  /* f->phi[1] += wphi*N.y; */
  /* f->phi[2] += wphi*N.z; */

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h[3] += wh*x.x;
  f->forces_h[4] += wh*x.y;
  f->forces_h[5] += wh*x.z;

  f->forces_fk[3] += wfk*x.x;
  f->forces_fk[4] += wfk*x.y;
  f->forces_fk[5] += wfk*x.z;

  f->forces_l[3] += wl*x.x;
  f->forces_l[4] += wl*x.y;
  f->forces_l[5] += wl*x.z;

  f->forces_m[3] += wm*x.x;
  f->forces_m[4] += wm*x.y;
  f->forces_m[5] += wm*x.z;

  f->phi2[3] += wphi2*x.x;
  f->phi2[4] += wphi2*x.y;
  f->phi2[5] += wphi2*x.z;

  /* f->phi[3] += wphi*x.x; */
  /* f->phi[4] += wphi*x.y; */
  /* f->phi[5] += wphi*x.z; */
}

static void add_radiative_forces (Simulation * sim, Forces * f, gdouble t, gdouble u[6], gdouble x[6], gboolean prediction)
{

  /* gint a; */
  /* for ( a = 0; a < 6; a++ ) { */
  /*   sim->hull->m.x[a] = sim->hull->m.v[a] = sim->hull->m.u[a] = 0.; */
  /* } */

  /* gint d = 0; */
  /* sim->hull->m.x[d] = 0.15*sin (sim->wp.w*t); */
  /* sim->hull->m.v[d] = sim->hull->m.u[d] = 0.15*sim->wp.w*cos (sim->wp.w*t); */

  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, sim->time.t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, sim->time.t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

#if 1
  // Now we have the potential at time n+1, the forces can be calculated

  // whole_hull_integration ??

  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++) {
    f->a[i] = sim->hull->m.u[i]; 
    f->u[i] = sim->hull->m.u[i];
  }

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Set acceleration vector to zero
  for ( i = 0; i < 6; i++ )
    a[i] = 0.;

  // Fourth order backward estimate of the time derivative
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] += 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

#endif

  for ( i = 0; i < 2; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
    f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }

  for ( i = 3; i < 6; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
    f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }
}

static void add_radiative_forces_huang (Simulation * sim, Forces * f, gdouble t, gdouble u[6], gdouble x[6], gboolean prediction)
{

  /* gint a; */
  /* for ( a = 0; a < 6; a++ ) { */
  /*   sim->hull->m.x[a] = sim->hull->m.v[a] = sim->hull->m.u[a] = 0.; */
  /* } */

  /* gint d = 0; */
  /* sim->hull->m.x[d] = 0.15*sin (sim->wp.w*t); */
  /* sim->hull->m.v[d] = sim->hull->m.u[d] = 0.15*sim->wp.w*cos (sim->wp.w*t); */

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, sim->time.t, prediction);
  /* if ( sim->time.itime%20 == 0 ) */
  /*   periodic_fs_filter_variable (sim->fs->s->patches->data, 9); */

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, sim->time.t, prediction);
  /* if ( sim->time.itime%20 == 0 ) */
  /*   periodic_fs_filter_variable (sim->fs->s->patches->data, 7); */

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);

  /* fprintf (stderr, "test8: %f \n", sim->hull->m.u[2]); */
  /* fprintf (stderr, "test9: %f \n", u[2]); */

  /** Solve boundary problem for time-local potential **/
  solve_boundary_problem_for_time_local_flow (sim);
  //g_assert_not_reached ();
#if 1
  // Now we have the potential at time n+1, the forces can be calculated
  // whole_hull_integration ??
  
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_huang_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++) {
    /* f->a[i] = u[i]; */
    f->u[i] = u[i];
  }

  /* wet_hull_integration (sim->hull, sim, f, */
  /* 			local_linear_nospeed_forces_contribution, */
  /* 			sppanel_linear_nospeed_forces_integral_gauss, */
  /* 			pressure_force_integration_tolerance, */
  /* 			//corner_point_new, // to check */
  /* 			corner_point_new_uv_linear,  */
  /* 			flat_sea, t, &sim->wp); */

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6]/* , phi[4][6] */, uu[4][6], a[6];;
  gdouble dt = sim->time.dt;
  gint j;
  i= 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      //phi[i][j] = forces->phi[j];
      uu[i][j] = forces->u[j];
    }
    fl = fl->next;
    i++;
  }

  // Set acceleration vector to zero
  for ( i = 0; i < 6; i++ )
    a[i] = 0.;

  // Fourth order backward estimate of the time derivative
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  += 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      //f->forces_l[j]  += 1./(12.*dt)*(25.*f->phi[j] - 48.*phi[3][j] + 36.*phi[2][j] - 16.*phi[1][j] + 3.*phi[0][j]);
      a[j] += 1./(12.*dt)*(25.*f->u[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }

  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
	//f->forces_m[i] -= sim->rho*sim->hull->A[i][j]*a[j];
      }
    }
  }
  /* for ( j = 0; j < 6; j++ ) { */
  /*  f->forces_m[j]  = 0.; */
  /* } */


#endif

  f->v[0] = f->forces_m[0] = f->forces_l[0] = f->forces_h[0] = 0.;
  /* f->forces_fk[0] = */ f->forces_r[0] = f->forces_e[0] = f->forces_ext[0] = 0.;
  f->phi2[0] = 0.;

  for ( i = 0; i < 2; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
   /* f->forces_fk[i] = */ f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }

  for ( i = 3; i < 6; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
    /* f->forces_fk[i] = */ f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }

}

static void add_radiative_forces_test (Simulation * sim,
				       Forces * f, gdouble t,
				       gdouble u[6], gdouble x[6],
				       gboolean prediction)
{

  gint aa;
  for ( aa = 0; aa < 6; aa++ ) {
    sim->hull->m.x[aa] = sim->hull->m.v[aa] = sim->hull->m.u[aa] = 0.;
  }

  gint d = 0;
  sim->hull->m.x[d] = 0.15*sin (sim->wp.w*t);
  sim->hull->m.v[d] = sim->hull->m.u[d] = 0.15*sim->wp.w*cos (sim->wp.w*t);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x, sim->hull->m.u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++) {
    f->a[i] = sim->hull->m.u[i]; 
    f->u[i] = sim->hull->m.u[i];
  }

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Set acceleration vector to zero
  for ( i = 0; i < 6; i++ )
    a[i] = 0.;

  // Fourth order backward estimate of the time derivative
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] += 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  for ( i = 0; i < 26; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
    f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }
}

gdouble test_radiation (Simulation * sim)
{
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 2.5;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  /* sim->wp.wave_potential = finite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = finite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = finite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative; */
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 30.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;



  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 50,
										      half_sphere_x2,
										      half_sphere_y2,
										      half_sphere_z2,
										      NULL, 3, 4, 3));

  hull_print (sim->hull, NULL);


  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Circular grid
  // fs->s->patches = g_slist_append (fs->s->patches, circular_fs (80, 80, 20, sim, 3, 4, 3));
   //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (50, 50, 20, sim, 3, 4, 3));
  gdouble r = 20;
  //fs->s->patches = g_slist_append (fs->s->patches, spline2d_parametric_periodic_patch (50, 50, circ_x2, circ_y2, circ_z2, &r));

  // Radius of domain
  sim->wp.r1 = /* 75. *//* 30. */50.;
  sim->wp.r2 = /* 75. *//* 30. */50.;

  sim->N = 50;
  sim->M = 50;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  // Filter test
  /* spline2d_fit_galerkin (fs->s->patches->data, centered_gaussian_ring, sim, 9); */
  /* gint a; */
  /* for ( a = 0; a < 90; a++) */
  /*   periodic_fs_filter_variable (fs->s->patches->data, 9); */

  /* print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */
  /* g_assert_not_reached (); */


  simulation_build_galerkin_fit_matrixes (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  initialise_motion (sim);

  sim->forces = g_slist_append (sim->forces, add_radiative_forces_test);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

    /** Equation of motion for the hull **/
    //g_assert_not_reached ();
    Forces * f = g_malloc (sizeof(Forces));
    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
    }

    if ( sim->time.itime%20 == 0 ) {
      fprintf (ffk, " %e %f %f %f %f %f %f \n", sim->time.t+sim->time.dt, f->forces_fk[0],
	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %f %f %f %f %f %f \n", sim->time.t+sim->time.dt, f->forces_h[0],
	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %f %f %f %f %f %f \n", sim->time.t+sim->time.dt, f->forces_l[0],
	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %f %f %f %f %f %f \n", sim->time.t+sim->time.dt, f->forces_m[0],
	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      /* periodic_fs_filter_variable (fs->s->patches->data, 9); */
      /* periodic_fs_filter_variable (fs->s->patches->data, 7); */
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
}

gdouble half_sphere_x3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*cos(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v));
}

gdouble half_sphere_y3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*sin(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v));
}

gdouble half_sphere_z3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -*r*cos(M_PI/2.*(1.-v));
}

gdouble half_cylinder_x3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*cos(2.*M_PI*(/* 1- */u))/* *sin(0.5*M_PI*(1.-v)) */;
}

gdouble half_cylinder_y3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*sin(2.*M_PI*(/* 1- */u))/* *sin(0.5*M_PI*(1.-v)) */;
}

gdouble half_cylinder_z3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -0.5*v/* *cos(M_PI/2.*(1.-v)) */;
}

gdouble half_cylinder_bottom_x3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*cos(2.*M_PI*(/* 1- */u))*(1-v)/* *sin(0.5*M_PI*(1.-v)) */;
}

gdouble half_cylinder_bottom_y3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*sin(2.*M_PI*(/* 1- */u))*(1-v)/* *sin(0.5*M_PI*(1.-v)) */;
}

gdouble half_cylinder_bottom_z3 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -0.5/* *v *//* *cos(M_PI/2.*(1.-v)) */;
}

gdouble half_cylinder_z4 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -200.*v/* *cos(M_PI/2.*(1.-v)) */;
}

gdouble half_cylinder_bottom_z4 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -200./* *v *//* *cos(M_PI/2.*(1.-v)) */;
}

gdouble half_spheroid_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return cos(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
}

gdouble half_spheroid_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*sin(2.*M_PI*u)*sin(0.5*M_PI*(1.-v));
}

gdouble half_spheroid_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -*r*cos(M_PI/2.*(1.-v));
}

gdouble half_spheroid_x1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return cos(2.*M_PI*u/2.+M_PI)*sin(0.5*M_PI*(1.-v));
}

gdouble half_spheroid_y1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*sin(2.*M_PI*u/2.+M_PI)*sin(0.5*M_PI*(1.-v));
}

gdouble half_spheroid_z1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -*r*cos(M_PI/2.*(1.-v));
}

gdouble half_spheroid_x2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return cos(2.*M_PI*u/2.)*sin(0.5*M_PI*(1.-v));
}

gdouble half_spheroid_y2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*sin(2.*M_PI*u/2.)*sin(0.5*M_PI*(1.-v));
}

gdouble half_spheroid_z2 (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -*r*cos(M_PI/2.*(1.-v));
}

static void add_radiative_forces_heaving_sphere (Simulation * sim,
						 Forces * f, gdouble t,
						 gdouble u[6], gdouble x[6],
						 gboolean prediction)
{
  //g_test_timer_start ();
  //  simulation_calculate_gradients (sim);
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  flat_sea/* sim->wp.wave_elevation */, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
    


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  for ( i = 0; i < 6; i++ )
    /* f->forces_l[i] = f->forces_m[i] = f->forces_h[i] = f->forces_fk[i] = */ f->forces_h[i] = 0.;

  for ( i = 0; i < 6; i++ ) {
    for (  j = 0; j < 6; j++ ) {
      f->forces_h[i] -= sim->hull->R[j][i]*x[j];
    }
  }

  //f->forces_h[2] -= sim->hull->R[2][2]*x[2];

  //f->forces_h[2] -= sim->rho*sim->g*M_PI*x[2];

  //fprintf (stdout, "%f %f %f \n", t, f->forces_h[2], sim->rho*sim->g*M_PI*x[2]);
}

gdouble test_heaving_sphere (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;
  gdouble radius = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  25.*sqrt(radius/9.81);
  sim->time.iend = 1e6;
  sim->time.dt = 0.005;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 4.5;
  sim->wp.h = 5.;
  sim->wp.k = sim->wp.w*sim->wp.w/9.81;
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  gdouble wavelength = 2.*M_PI/sim->wp.k;

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;
  //  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  //sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update;
  sim->fs_elevation_rhs_store = NULL;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;
  //sim->fs_elevation_rhs_store = abm4_free_surface_elevation_disturbance_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;
  //sim->fs_potential_update = explicit_no_speed_potential_update;
  //sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->fs_potential_update = abm4_no_speed_potential_update;
  //sim->fs_potential_update = abm4_free_surface_disturbance_potential_update;

  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson
  sim->fs_potential_rhs_store = NULL;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;
  //sim->fs_potential_rhs_store = abm4_free_surface_disturbance_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

   // Radius of domain
  // NB: 500 for a ship-size half spheroid
  sim->wp.r1 = /* 35. */45.;
  sim->wp.r2 = /* 35. */45.;

  sim->wp.r1_inner = /* 35. */5.;
  sim->wp.r2_inner = /* 35. */5.;


  sim->N = /* 40 */50;
  sim->M = /* 40 */50;

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 30,
										      half_sphere_x3,
										      half_sphere_y3,
										      half_sphere_z3,
										      &radius, 3, 4, 2));

  hull_print (sim->hull, NULL);

  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 2);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  sim->lu_destroy (sim->neumann_lu);
  
  simulation_calculate_gradients_linear (sim);
  //  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);


  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;
  calculate_mass_from_position_at_rest (sim->hull, sim);

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }

  initialise_motion (sim);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  // Change to the initial position if required
  /* sim->hull->m.x[2] = 1.; */
  sim->hull->m.x[2] = 1.;

  //sim->hull->m.u[2] = sqrt(9.81*radius);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  // sim->forces = g_slist_append (sim->forces, add_gravity_force);
  //sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_heaving_sphere);
  sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force);

  

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");
  FILE * ffe = fopen ("fe.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
    }

    if ( sim->time.itime%15 == 0 ) {
      /* fprintf (fmotion, "%e %e\n", */
      /* 	       (sim->time.t+sim->time.dt)*sqrt(9.81/radius), */
      /* 	     sim->hull->m.x[2]); */
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	       (sim->time.t+sim->time.dt)*sqrt(9.81/radius),
	       sim->hull->m.x[0],
	       sim->hull->m.x[1],
	       sim->hull->m.x[2],
	       sim->hull->m.x[3],
	       sim->hull->m.x[4],
	       sim->hull->m.x[5]);
      fflush (fmotion);

      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
      fprintf (ffe, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_e[0],
      	       f->forces_e[1], f->forces_e[2], f->forces_e[3], f->forces_e[4], f->forces_e[5]);
      fflush (ffe);
    }

    if ( sim->time.itime%10 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  fclose (fmotion);
  fclose (flog);
}

static void add_radiative_forces_heaving_sphere_implicit (Simulation * sim,
							  Forces * f, gdouble t,
							  gdouble u[6], gdouble x[6])
{

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_nospeed_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }
}

CCSProblem * periodic_fs_build_nospeed_numerical_beach_matrix (Spline2D * splines, Simulation * sim)
{
  gint i, j, m, n, ii, a, b;
  gint NV = splines->NV; // Should be the same for all the splines

  Spline2D * sp = splines;
  // Find the total number of coeffs in direction u
  // and number the spline patches
  gint NUT = 0;
  while (sp) {
    sp->fs_index = NUT;
    NUT += sp->NU;
    sp = sp->next;
  }
  
  gint size = NUT*NV;
  gdouble A0[size][size];

  // Initializes the coefficients to 0
  for ( i = 0; i < size; i++) {
    for ( j = 0; j < size; j++) {
      A0[i][j] = 0.;
    }
  }

  gsl_matrix * Bu, * Bv;
  gint ustart, vstart;
  sp = splines;
  while (sp) {// Loop over the spline patches
    // Loop over the panels of the patch
    for ( ii = 0; ii < sp->M*sp->N; ii++) {
      SPPanel * spp = g_ptr_array_index (sp->panels, ii);
      g_assert (spp != NULL);
     	
      // Gauss outer-integration
      GaussPoints * gp = spp->outer;
      gint ng = sp->nouter; // Order of outer Gauss-Legendre rule
      ustart = sp->periodic ? 
	gp->istart + sp->fs_index - sp->k + 1 :
	gp->istart;
      vstart = gp->jstart;
      for ( m = 0; m < ng; m++) {
	Bu = g_ptr_array_index (gp->Bu, m);
	  
	for ( n = 0; n < ng; n++) {
	  Bv = g_ptr_array_index (gp->Bv, n);
	  gdouble wmn = g_array_index (gp->wJij, gdouble, m+n*ng);
	  Point p = g_array_index (gp->Pi, Point, m + n*ng);
	  gdouble nu = 0.;
	  if ( sim->numerical_beaches )
	    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);
	  gdouble coeff = 1.-sim->time.dt*sim->time.dt*4./15.*(2*nu*sim->g*25./12. + nu*nu/sim->g);
	  wmn *= coeff;

	  // Loop over the splines whose support is included in the panel
	  for ( i = ustart; i < ustart + sp->k; i++) {
	    gdouble wmni = wmn*gsl_matrix_get (Bu, i-ustart, 0);
	    gint indexi = i % NUT;
	    for ( j = vstart; j < vstart + sp->k; j++) {
	      gdouble wmnij = wmni*gsl_matrix_get (Bv, j-vstart, 0);
	      gint indexij = indexi + j*NUT;
	      
	      for ( a = 0; a < sp->k; a++) {
		gdouble wmnija = wmnij*gsl_matrix_get (Bu, a, 0);
		gint indexa = (ustart + a)%NUT;
		for ( b = 0; b < sp->k; b++) {
		  A0[indexij][indexa + (vstart+b)*NUT] +=  wmnija*gsl_matrix_get(Bv, b, 0);
		}
	      }

	    }
	  }
	
	}
      }
    }
    sp = sp->next;
  }

  
  FILE * fp = fopen ("fit.tmp","w");
  CCSProblem * fit = ccs_problem_new ();
  gint count = 0;
  for ( i = 0; i < size; i++) {
    g_array_append_val (fit->index, count);
    for ( j = 0; j < size; j++) {
      fprintf(fp,"%i %i %f\n", i, j, A0[i][j]);
      if (A0[i][j] != 0.) {
  	g_array_append_val (fit->matrix, A0[i][j]);
  	g_array_append_val (fit->column, j);
  	count++;
      }
    }
    fprintf (fp, "\n");
  }
  g_array_append_val (fit->index, count);
  fclose (fp);

  return fit;
}

static gdouble numerical_beaches_implicit (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  Simulation * sim = (Simulation *) data;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  gdouble phi, phi0, phi1, phi2, phi3, phi4;

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

  phi = phi0 = phi1 = phi2 = phi3 = phi4 = 0.;
  
  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    for ( j = 0; j < sp->k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      phi += coeff (sp, istart, (jstart+j), 7)*cuv;
      phi0 += coeff (sp, istart, (jstart+j), 23)*cuv;
      phi1 += coeff (sp, istart, (jstart+j), 34)*cuv;
      phi2 += coeff (sp, istart, (jstart+j), 35)*cuv;
      phi3 += coeff (sp, istart, (jstart+j), 36)*cuv;
      phi4 += coeff (sp, istart, (jstart+j), 37)*cuv;
    }
    istart++;
  }

  return phi + sim->time.dt*sim->time.dt*4./15.*2.*nu*sim->g/12.*(-48.*phi0+36.*phi1-16.*phi2+3.*phi3);
}

gdouble trial_numerical_beaches_implicit (SPPanel * spp, gint m, gint n, gpointer data)
{
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  Simulation * sim = (Simulation *) data;
  gint ng = sp->nouter;

  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  gdouble nu = 0.;
  if ( sim->numerical_beaches )
    nu = sim->numerical_beaches (p.x, p.y, p.z, &sim->wp);

  gdouble phi, phi0, phi1, phi2, phi3, phi4;

  gint i, j;
  size_t istart, jstart;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);

  phi = phi0 = phi1 = phi2 = phi3 = phi4 = 0.;
  
  istart = gp->istart;
  if (sp->periodic)
    istart -= (sp->k-1);
  jstart = gp->jstart;

  for ( i = 0; i < sp->k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    for ( j = 0; j < sp->k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      phi += coeff (sp, istart, (jstart+j), 7)*cuv;
      phi0 += coeff (sp, istart, (jstart+j), 23)*cuv;
      phi1 += coeff (sp, istart, (jstart+j), 34)*cuv;
      phi2 += coeff (sp, istart, (jstart+j), 35)*cuv;
      phi3 += coeff (sp, istart, (jstart+j), 36)*cuv;
     }
    istart++;
  }

  gdouble nudt = nu*sim->time.dt;
  gdouble alpha1 = 1.+nudt*25./6.+nudt*nudt;
  gdouble alpha2 = 8.*nudt;
  gdouble alpha3 = -6.*nudt;
  gdouble alpha4 = +8./3.*nudt;
  gdouble alpha5 = -nudt/2.;

  return 1./alpha1*(phi+alpha2*phi0+alpha3*phi1+alpha4*phi2+alpha5*phi3);
}

gdouble test_heaving_sphere_implicit (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;
  gdouble radius = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  25.*sqrt(radius/9.81);
  sim->time.iend = 1e6;
  sim->time.dt = 0.01;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 4.5;
  sim->wp.h = 5.;
  sim->wp.k = sim->wp.w*sim->wp.w/9.81;
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  gdouble wavelength = 2.*M_PI/sim->wp.k;

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 30.;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

   // Radius of domain
  // NB: 500 for a ship-size half spheroid
  sim->wp.r1 = 35.;
  sim->wp.r2 = 35.;

  sim->N = 40;
  sim->M = 40;

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 30,
										      half_sphere_x3,
										      half_sphere_y3,
										      half_sphere_z3,
										      &radius, 3, 4, 3));

  hull_print (sim->hull, NULL);

  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  g_test_timer_start ();
  simulation_build_problems_nospeed_implicit (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 36, 37);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 35, 36);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 34, 35);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 23, 34);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_nospeed_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;
  calculate_mass_from_position_at_rest (sim->hull, sim);

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }

  initialise_motion (sim);

  // Change to the initial position if required
  sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[2] = sqrt(9.81*radius);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_heaving_sphere_implicit);

  FILE * fmotion = fopen ("motion.tmp","w");
  Spline2D * fs_sp = sim->fs->s->patches->data;
  gsl_vector * beaches_rhs;
  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 36, 37);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 35, 36);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 34, 35);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 23, 34);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Numerical beaches **/
    beaches_rhs = fs_sp->build_fit_rhs (fs_sp, trial_numerical_beaches_implicit, sim, NULL, NULL, beaches_rhs);
    ccs_problem_lu_solve (fs_sp->fit, beaches_rhs);
    fs_sp->copy_fit_solution (fs_sp, beaches_rhs, 7);
    gsl_vector_free (beaches_rhs);

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
    }

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e\n",
	       (sim->time.t+sim->time.dt)*sqrt(9.81/radius),
	     sim->hull->m.x[2]);
      fflush (fmotion);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  fclose (fmotion);
  fclose (flog);
}

static void add_radiative_forces_heaving_hull (Simulation * sim,
					       Forces * f, gdouble t,
					       gdouble u[6], gdouble x[6],
					       gboolean prediction)
{
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  // Set forces for the 5 other degrees of freedom to zero
  /* for ( i = 0; i < 1; i++ ) { */
  /*   f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.; */
  /*   f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.; */
  /*   f->phi2[i] = 0.; */
  /* } */

  /* for ( i = 3; i < 6; i++ ) { */
  /*   f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.; */
  /*   f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.; */
  /*   f->phi2[i] = 0.; */
  /* } */
}

gdouble test_heaving_hull (Simulation * sim)
{
  FILE * flog = fopen ("heaving_hull.log","w");
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;
  gdouble radius = 90.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  100.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.005 */0.005;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 4.5;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 20.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

   // Radius of domain
  sim->wp.r1 = 500.;
  sim->wp.r2 = 500.;

  sim->N = 40;
  sim->M = 40;

  // Initial fit of half hull (low but sufficient number of panels)
  fp = fopen("1704deck-flat-mesh-12.2.GDF","r");
  hull_read (sim->hull, fp, 20, 10, TRUE, FALSE, TRUE, FALSE);
  fclose (fp);

  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  
  // Regridding of hull to get desired number of panels
  GSList * patches_tmp = sim->hull->patches;
  sim->hull->patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 15 */12, /* 45 */25);
    sim->hull->patches = g_slist_append (sim->hull->patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Regridding of wet hull to get desired number of panels
  patches_tmp = sim->hull->wet_patches;
  sim->hull->wet_patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 15 */12, /* 45 */25);
    sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Add other symmetrical hull
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));
  sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches,
					   spline2d_symmetrical_y (sim->hull->wet_patches->data, 0));

  // Translate hulls
  // -86 <=> Midship
  // -16. <=> Half breadth, -2. = initial distance between pier and hull
  spline2d_translate  (sim->hull->patches->data, -86., -16.-2., 0.);
  spline2d_translate  (sim->hull->patches->next->data , -86., -16.-2., 0.);
  
  spline2d_translate  (sim->hull->wet_patches->data, -86., -16.-2., 0.);
  spline2d_translate  (sim->hull->wet_patches->next->data , -86., -16.-2., 0.);

  hull_print (sim->hull, NULL);  

  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  sim->hull->xg.x = /* 80.4 *//* 90.1 */0; // 4.55m forward of midship
  sim->hull->xg.y = -16.;
  sim->hull->xg.z = -3.45; // 11.7 meters above the keel -15.15 + 11.7 = 

  build_free_surface (sim, 3, 4, 3);


  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);


  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  //  sim->fs_potential_update (sim, sim->time.t);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Point cob = find_center_of_buoyancy (sim->hull, sim, flat_sea, sim->time.t, NULL);

  sim->hull->xg.x = cob.x;
  sim->hull->xg.y = -18.00;

  Motion * m = &sim->hull->m;
  Vector test;
  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);
  test.x = m->euler_m.a[0][0]*f->forces_h[0] + m->euler_m.a[0][1]*f->forces_h[1] + m->euler_m.a[0][2]*f->forces_h[2];
  test.y = m->euler_m.a[1][0]*f->forces_h[0] + m->euler_m.a[1][1]*f->forces_h[1] + m->euler_m.a[1][2]*f->forces_h[2];
  test.z = m->euler_m.a[2][0]*f->forces_h[0] + m->euler_m.a[2][1]*f->forces_h[1] + m->euler_m.a[2][2]*f->forces_h[2];
  fprintf (stdout, " Forces at equilibrium: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z);
  fprintf (stdout, " Moments at equilibrium: %e %e %e \n", f->forces_h[3], f->forces_h[4], f->forces_h[5]);
  g_free (f);

  //adjust_equilibrium_position_xgx (sim->hull, sim);
  adjust_linear_equilibrium_position_xgx (sim->hull, sim);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);
  test.x = m->euler_m.a[0][0]*f->forces_h[0] + m->euler_m.a[0][1]*f->forces_h[1] + m->euler_m.a[0][2]*f->forces_h[2];
  test.y = m->euler_m.a[1][0]*f->forces_h[0] + m->euler_m.a[1][1]*f->forces_h[1] + m->euler_m.a[1][2]*f->forces_h[2];
  test.z = m->euler_m.a[2][0]*f->forces_h[0] + m->euler_m.a[2][1]*f->forces_h[1] + m->euler_m.a[2][2]*f->forces_h[2];
  fprintf (stdout, " Forces at equilibrium: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z);
  fprintf (stdout, " Moments at equilibrium: %e %e %e \n", f->forces_h[3], f->forces_h[4], f->forces_h[5]);
  g_free (f);

  // Matrix of inertia :
  sim->hull->Ig[0][0] = pow(0.289*32.2*(1.+pow(2.*11.7/32.2,2.)),2)*sim->hull->mg;
  sim->hull->Ig[1][1] = pow(0.289*172,2)*sim->hull->mg;
  sim->hull->Ig[2][2] = pow(0.289*172,2)*sim->hull->mg;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  initialise_motion (sim);

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[0] = 1.;
  sim->hull->m.u[0] = 0.01;
  //sim->hull->m.u[2] = sqrt(9.81*5);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_heaving_hull);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");
  FILE * ffe = fopen ("fe.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%10 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
    }

    

    

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	       (sim->time.t+sim->time.dt)*sqrt(9.81/radius),
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
      fprintf (ffe, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_e[0],
      	       f->forces_e[1], f->forces_e[2], f->forces_e[3], f->forces_e[4], f->forces_e[5]);
      fflush (ffe);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  /* fclose (ffk); */
  /* fclose (ffh); */
  /* fclose (ffl); */
  /* fclose (ffm); */
  /* fclose (ffext); */
  fclose (flog);
}

static void add_radiative_forces_rocking_hull (Simulation * sim,
					       Forces * f, gdouble t,
					       gdouble u[6], gdouble x[6],
					       gboolean prediction)
{
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  for ( i = 0; i < 6; i++ )
    /* f->forces_l[i] = f->forces_m[i] =  */f->forces_h[i] = f->forces_fk[i] = f->forces_ext[i] = 0.;

  /* for ( i = 0; i < 6; i++ ) { */
  /*   for (  j = 0; j < 6; j++ ) { */
  /*     f->forces_h[i] -= sim->hull->R[j][i]*x[j]; */
  /*   } */
  /* } */
}

double delta_linear_forces_xgx (double x, void * params)
{
  Simulation * sim = (Simulation *) params;

  sim->hull->xg.x = x;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces f;
  forces_set_to_zero (&f);

  whole_hull_integration (sim->hull, sim, &f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, sim->time.t, &sim->wp);

  gdouble delta = f.forces_h[4];

  fprintf (stderr, "Forces: %e %e %e Moments: %e %e %e \n",
  	   f.forces_h[0], f.forces_h[1], f.forces_h[2],
  	   f.forces_h[3], f.forces_h[4], f.forces_h[5]);

  return delta;
}

void adjust_linear_equilibrium_position_xgx (Hull * hull, Simulation * sim)
{
  const gsl_root_fsolver_type *T;
  gsl_root_fsolver *s;
  gsl_function F;
  F.function = &delta_linear_forces_xgx;
  F.params = sim;

  T = gsl_root_fsolver_brent;
  s = gsl_root_fsolver_alloc (T);

  gdouble z0 = sim->hull->xg.x-20., z1 = sim->hull->xg.x+20.;

  gsl_root_fsolver_set (s, &F, z0, z1);
  
  gint iter = 0;
  int status;

  gdouble r;
  do {
    iter++;
    status = gsl_root_fsolver_iterate (s);
    r = gsl_root_fsolver_root (s);
    z0 = gsl_root_fsolver_x_lower (s);
    z1 = gsl_root_fsolver_x_upper (s);
    status = gsl_root_test_interval (z0, z1, 0, 0.00000001);
  }
  while (status == GSL_CONTINUE && iter < 1000);

  gsl_root_fsolver_free (s);

  fprintf (stderr, "xg : %f \n", r);
  
  sim->hull->xg.x = r;

  update_rotation_matrix (&hull->m, hull->m.x,
			  hull->m.u);
}

gdouble test_rocking_hull (Simulation * sim)
{
  FILE * flog = fopen ("heaving_hull.log","w");
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;
  gdouble radius = 90.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  1000.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.005 */0.005;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = /* 4.5 *//* 0.025 */2.*M_PI/25.; // = 2pi/period
  sim->wp.h = 5.;
  sim->wp.k = /* solve_dispersion_relation (&sim->wp) */sqrt(9.81*sim->wp.w);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Deep water
  sim->wp.k = 2.*M_PI/100.;
  sim->wp.w = sqrt(9.81*sim->wp.k);

  fprintf (flog, "Period: %f \n", 2.*M_PI/sim->wp.w);
  fprintf (flog, "Wavelength: %f \n", 2.*M_PI/sim->wp.k);
  fflush (flog);

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = infinite_depth_wave_potential;
  sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = infinite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 5./* 70. */;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

   // Radius of domain
  sim->wp.r1 = 600.;
  sim->wp.r2 = 600.;

  sim->N = 40;
  sim->M = 40;

  // Initial fit of half hull (low but sufficient number of panels)
  fp = fopen("1704deck-flat-mesh-12.2.GDF","r");
  hull_read (sim->hull, fp, 20, 10, TRUE, FALSE, TRUE, FALSE);
  fclose (fp);

  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  
  // Regridding of hull to get desired number of panels
  GSList * patches_tmp = sim->hull->patches;
  sim->hull->patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 15 */12, /* 45 */25);
    sim->hull->patches = g_slist_append (sim->hull->patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Regridding of wet hull to get desired number of panels
  patches_tmp = sim->hull->wet_patches;
  sim->hull->wet_patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    /* Spline2D * new = spline2d_regrid (old, /\* 15 *\/12, /\* 45 *\/25); */
    Spline2D * new = spline2d_regrid (old, /* 15 */10, /* 45 */20);
    sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Add other symmetrical hull
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));
  sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches,
					   spline2d_symmetrical_y (sim->hull->wet_patches->data, 0));

  // Translate hulls
  // -86 <=> Midship
  // -16. <=> Half breadth, -2. = initial distance between pier and hull
  spline2d_translate  (sim->hull->patches->data, -86., -16.-2., 0.);
  spline2d_translate  (sim->hull->patches->next->data , -86., -16.-2., 0.);
  
  spline2d_translate  (sim->hull->wet_patches->data, -86., -16.-2., 0.);
  spline2d_translate  (sim->hull->wet_patches->next->data , -86., -16.-2., 0.);

  hull_print (sim->hull, NULL);  

  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  sim->hull->xg.x = /* 80.4 *//* 90.1 */0; // 4.55m forward of midship
  sim->hull->xg.y = -18.;
  sim->hull->xg.z = -3.45; // 11.7 meters above the keel -15.15 + 11.7 = 

  /* calculate_mass_from_position_at_rest_linear (sim->hull, sim); */
  /* calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL); */
  /* g_assert_not_reached (); */

  g_assert (sim->fs->s->patches == NULL);

  build_free_surface (sim, 3, 4, 3);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //  g_assert_not_reached ();

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);


  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  //  sim->fs_potential_update (sim, t);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

#if 1
  Point cob = find_center_of_buoyancy (sim->hull, sim, flat_sea, sim->time.t, NULL);

  sim->hull->xg.x = cob.x;
  sim->hull->xg.y = -18.00;

  fprintf (flog, "COB: %e %e %e \n", cob.x, cob.y, cob.z);
  fflush (flog);

  Motion * m = &sim->hull->m;
  Vector test;
  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);
  test.x = m->euler_m.a[0][0]*f->forces_h[0] + m->euler_m.a[0][1]*f->forces_h[1] + m->euler_m.a[0][2]*f->forces_h[2];
  test.y = m->euler_m.a[1][0]*f->forces_h[0] + m->euler_m.a[1][1]*f->forces_h[1] + m->euler_m.a[1][2]*f->forces_h[2];
  test.z = m->euler_m.a[2][0]*f->forces_h[0] + m->euler_m.a[2][1]*f->forces_h[1] + m->euler_m.a[2][2]*f->forces_h[2];
  fprintf (stdout, " Forces at equilibrium: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z);
  fprintf (stdout, " Moments at equilibrium: %e %e %e \n", f->forces_h[3], f->forces_h[4], f->forces_h[5]);
  g_free (f);

  adjust_linear_equilibrium_position_xgx (sim->hull, sim);
  
  fprintf (flog, "COG: %e %e %e \n", sim->hull->xg.x, sim->hull->xg.y, sim->hull->xg.z);
  fflush (flog);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);
  test.x = m->euler_m.a[0][0]*f->forces_h[0] + m->euler_m.a[0][1]*f->forces_h[1] + m->euler_m.a[0][2]*f->forces_h[2];
  test.y = m->euler_m.a[1][0]*f->forces_h[0] + m->euler_m.a[1][1]*f->forces_h[1] + m->euler_m.a[1][2]*f->forces_h[2];
  test.z = m->euler_m.a[2][0]*f->forces_h[0] + m->euler_m.a[2][1]*f->forces_h[1] + m->euler_m.a[2][2]*f->forces_h[2];
  fprintf (stdout, " Forces at equilibrium: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z);
  fprintf (stdout, " Moments at equilibrium: %e %e %e \n", f->forces_h[3], f->forces_h[4], f->forces_h[5]);
  g_free (f);
#endif

  // Matrix of inertia :
  sim->hull->Ig[0][0] = pow(0.289*32.2*(1.+pow(2.*11.7/32.2,2.)),2)*sim->hull->mg;
  sim->hull->Ig[1][1] = pow(0.289*172,2)*sim->hull->mg;
  sim->hull->Ig[2][2] = pow(0.289*172,2)*sim->hull->mg;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);


  initialise_motion (sim);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  sim->hull->m.x[2] = 1.;
  //  sim->hull->m.x[3] = 0.01;
  //sim->hull->m.u[2] = sqrt(9.81*5);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  //sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_rocking_hull);

  sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");
  FILE * ffe = fopen ("fe.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));
    forces_set_to_zero (f);

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%10 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
      periodic_fs_filter_variable (fs->s->patches->data, 7);
      periodic_fs_filter_variable (fs->s->patches->data, 9);
    }

    

    

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	       (sim->time.t+sim->time.dt)/* *sqrt(9.81/radius) */,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
      fprintf (ffe, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_e[0],
      	       f->forces_e[1], f->forces_e[2], f->forces_e[3], f->forces_e[4], f->forces_e[5]);
      fflush (ffe);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  /* fclose (ffk); */
  /* fclose (ffh); */
  /* fclose (ffl); */
  /* fclose (ffm); */
  /* fclose (ffext); */
  fclose (flog);
}

static void add_radiative_forces_oscillating_sphere2 (Simulation * sim,
						      Forces * f, gdouble t,
						      gdouble u[6], gdouble x[6],
						      gboolean prediction)
{
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  for ( i = 0; i < 2; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
    f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }

  for ( i = 3; i < 6; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
    f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }
}

gdouble test_oscillating_sphere2 (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  500.;
  sim->time.iend = (gint) G_MAXDOUBLE;
  sim->time.dt = 0.0025/* 05 */;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = /* 4.5 */0.2;
  sim->wp.h = 50.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  sim->wp.k = 0.4;
  sim->wp.w = sqrt(9.81*sim->wp.k);

  gdouble wavelength = 2.*M_PI/sim->wp.k;

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = infinite_depth_wave_potential;
  sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = infinite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 70.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 40,
										      half_sphere_x3,
										      half_sphere_y3,
										      half_sphere_z3,
										      NULL, 3, 4, 3));

  hull_print (sim->hull, NULL);


  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  gdouble r = 20;

  // Radius of domain
  /* sim->wp.r1 = 25.; */
  /* sim->wp.r2 = 25.; */

  sim->wp.r1 = 7.*wavelength;
  sim->wp.r2 = 7.*wavelength;

  sim->N = 60;
  sim->M = 60;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble radius = 1.;
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius; // Hollow sphere is 2./3.
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  initialise_motion (sim);

  // Change to the initial position if required
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_oscillating_sphere2);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%10 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
    }

    

    

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

static void add_radiative_forces_wu (Simulation * sim,
				     Forces * f, gdouble t,
				     gdouble u[6], gdouble x[6],
				     gboolean prediction)
{
  


  gint aa;
  for ( aa = 0; aa < 6; aa++ ) {
    sim->hull->m.x[aa] = sim->hull->m.v[aa] = sim->hull->m.u[aa] = 0.;
  }

  gint d = 4;
  sim->hull->m.x[d] = sin (sim->wp.w*t);
  sim->hull->m.v[d] = sim->hull->m.u[d] = sim->wp.w*cos (sim->wp.w*t);
  //  g_assert_not_reached ();

    simulation_calculate_gradients_linear (sim);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.u,
			  sim->hull->m.x);

#if 1
  //  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }
#endif
}

/**
 * Test case of pitch motion of a submerged spheroid. The original
 * work everybody refers to is (Wu et al., 1987) but the results
 * can also be found in "A three dimensional higher order panel method
 * based on B-splines".
 * H. D. Maniar, PhD Thesis, MIT, 1995, p 158
 **/
static void test_spheroid_wu (Simulation * sim)
{
  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = /* 9.81 */ 1.;
  sim->rho = /* 1000. */ 1.;
  sim->U.x = 0. /* Froude*sqrt(sim->g*L) */;
  // sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  sim->wp.g = sim->g = 1./* 1./L*pow(sim->U.x/Froude,2.) */;

  sim->wp.g = sim->g = 1.;
  //L = 1./(pow (Froude, 2.));

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end = 40.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.01/* 0.004/sqrt(sim->g*L) */;

  //sim->wp.g = 9.81;
  sim->wp.A = 1.;
  /* sim->wp.w = 2.; */
  sim->wp.h = 1.;
  sim->wp.k = 1.0;
  sim->wp.w = sqrt(sim->wp.g*sim->wp.k);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // No forcing
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 50./sim->wp.k*0.5;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  //sim->build_boundary_subproblem = build_boundary_subproblem_collocation;
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_wu;
  sim->wp.Cs = 3/* 0 */; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("spheroid_wu.GDF","r");
  GSList * patches = NULL;
  

  hull_read (sim->hull, fp, 17, 17, FALSE, FALSE, FALSE, FALSE);
  fclose (fp);

  freesurface_init (fs, &sim->wp);

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  sim->hull->wet_patches = sim->hull->patches;

  fs->s->b->dcb = hull_intersect_with_free_surface (sim->hull, fs->s->hz, sim->time.t, &sim->wp, sim->N);

  bathymetry_init (bathy, fs->s->b->dcb, &sim->wp);
    
  boundaries_init (fs->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  boundaries_init (bathy->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  FILE * fout = fopen ("boundaries.tmp","w");
  boundaries_print (fs->s->b, fout);
  fclose (fout);
    
  fout = fopen ("boundaries2.tmp","w");
  boundaries_print (bathy->s->b, fout);
  fclose (fout);
  
  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (/* 60 *//* 55 */ 70, /* 90 *//* 85 */70, spheroid_wu_fs_x, spheroid_wu_fs_y, sim)); 

  

  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80, 80, metrix_test_grid_x, metrix_test_grid_y, NULL));

  /* fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (50, 50, spheroid_fs_x, spheroid_fs_y, NULL)); */
  //  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80, 80, spheroid_fs_x, spheroid_fs_y, NULL));

  fout = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fout);
  fclose (fout);

  /* spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection, sim, 7); */
  /* print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t); */
  /* g_assert_not_reached (); */

  FILE * ff = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  Spline2D * tmpsp = fs->s->patches->data;
  tmpsp->fit = tmpsp->build_fit_matrix (tmpsp);

  //surface_generate_grid (bathy->s, TRUE);

  //spline2d_discretize_bathymetry (bathy->s->patches->data, &sim->wp, sim->time.t);

  /* bathy->s->patches = g_slist_append (bathy->s->patches, parametric_grid (/\* 25 *\/20, /\* 25 *\/20, /\* spheroid_fs_bathy_x *\/ spheroid_fs_x, spheroid_fs_y/\* spheroid_fs_bathy_y *\/, NULL)); */
  /* coeff_set_var_to_constant (bathy->s->patches->data, 2, -0.5); */
  
  /* ff = fopen ("norm3.tmp","w"); */
  /* ppp = bathy->s->patches->data; */
  /* spline2d_print_normals (ppp, ff); */
  /* fclose(ff); */

  /* fout = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fout); */
  /* fclose (fout); */

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  //solve_boundary_problem_for_basis_flow (sim);

  //   spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection, sim, 7);

  simulation_calculate_gradients_linear (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  // g_assert_not_reached ();
  // Dummy matrix of inertia
  sim->hull->mg = 1.;
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 1.;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  initialise_motion (sim);

  sim->forces = g_slist_append (sim->forces, add_radiative_forces_wu);
  

  FILE * fp_forces = fopen ("forces_spheroid.tmp","w");

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull / free-surface **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    

    // Update time

    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->fs->s->patches->data, 9);
      spline2d_filter_variable (sim->fs->s->patches->data, 7);
      spline2d_filter_variable (sim->fs->s->patches->data, 18);
    }

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_crossection (sim->fs->s->patches->data);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
}

static void add_radiative_forces_hulme_sphere (Simulation * sim,
					       Forces * f, gdouble t,
					       gdouble u[6], gdouble x[6],
					       gboolean prediction)
{
  


  gint aa;
  for ( aa = 0; aa < 6; aa++ ) {
    sim->hull->m.x[aa] = sim->hull->m.v[aa] = sim->hull->m.u[aa] = 0.;
  }

  gint d = 2;
  sim->hull->m.x[d] = sin (sim->wp.w*t);
  sim->hull->m.v[d] = sim->hull->m.u[d] = sim->wp.w*cos (sim->wp.w*t);


  update_rotation_matrix (&sim->hull->m, sim->hull->m.u,
			  sim->hull->m.x);

#if 1
  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }
#endif
}

static void add_radiative_forces_maccamy (Simulation * sim,
					   Forces * f, gdouble t,
					   gdouble u[6], gdouble x[6],
					   gboolean prediction)
{
  


  gint aa;
  for ( aa = 0; aa < 6; aa++ ) {
    sim->hull->m.x[aa] = sim->hull->m.v[aa] = sim->hull->m.u[aa] = 0.;
  }

  /* gint d = 2; */
  /* sim->hull->m.x[d] = sin (sim->wp.w*t); */
  /* sim->hull->m.v[d] = sim->hull->m.u[d] = sim->wp.w*cos (sim->wp.w*t); */


  update_rotation_matrix (&sim->hull->m, sim->hull->m.u,
			  sim->hull->m.x);

#if 1
  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  simulation_calculate_dphi1dzdz (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_maccamy_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], phi1[4][6], uu[4][6], a[6];
  Vector gradphi1[4][6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  Vector graddphi1dt;
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]) + f->forces_fk[j];
      //f->forces_m2[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]) + f->forces_fk2[j];

      graddphi1dt.x = 1./(12.*dt)*(25.*f->gradphi1[j].x - 48.*gradphi1[3][j].x + 36.*gradphi1[2][j].x - 16.*gradphi1[1][j].x + 3.*gradphi1[0][j].x);

      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }
#endif
}

static void add_radiative_forces_malenica (Simulation * sim,
					   Forces * f, gdouble t,
					   gdouble u[6], gdouble x[6],
					   gboolean prediction)
{
  gint aa;
  /* for ( aa = 0; aa < 2; aa++ ) { */
  /*   sim->hull->m.x[aa] = sim->hull->m.v[aa] = sim->hull->m.u[aa] = 0.; */
  /* } */
  /* for ( aa = 3; aa < 6; aa++ ) { */
  /*   sim->hull->m.x[aa] = sim->hull->m.v[aa] = sim->hull->m.u[aa] = 0.; */
  /* } */
  

#if 1
  //update_rotation_matrix (&sim->hull->m, sim->hull->m.x, sim->hull->m.u);
  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_maccamy_forces_integral_gauss,
			  flat_sea/* sim->wp.wave_elevation */, t, &sim->wp);
 
  /* whole_hull_integration (sim->hull, sim, f, */
  /* 			  sppanel_linear_nospeed_forces_integral_gauss, */
  /* 			  sim->wp.wave_elevation, t, &sim->wp); */

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]) /* + f->forces_fk[j] */;
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  /* } */
  /* else { */
  /*   for ( j = 0; j < 6; j++ ) */
  /*     a[j] = 0.; */
  /* } */
  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  /*  for ( i = 0; i < 6; i++ ) */
  /*   /\* f->forces_l[i] = f->forces_m[i] = f->forces_h[i] = f->forces_fk[i] = *\/ f->forces_h[i] = 0.; */

  /* for ( i = 0; i < 6; i++ ) { */
  /*   for (  j = 0; j < 6; j++ ) { */
  /*     f->forces_h[i] -= sim->hull->R[j][i]*x[j]; */
  /*   } */
  /* } */

  /* for ( i = 0; i < 6; i++ ) */
  /*   /\* f->forces_m[i] = f->forces_l[i] =  *\/f->forces_h[i] = 0.; */
#endif
}

static void add_initial_damping (Simulation * sim,
				 Forces * f, gdouble t,
				 gdouble u[6], gdouble x[6],
				 gboolean prediction)
{
  gdouble period = 2*M_PI/sim->wp.w;

  if ( 1. /* t < 6.*period */ /*20.*/) {
    Motion * m = &sim->hull->m;
    //gdouble dc = 200.*sim->hull->mg;
    /* gdouble dc = 0.05*sim->hull->mg; */
    gdouble dc = t < 300 ? 0.1*sim->hull->mg*(300-t)/300. : 0.;
    gdouble dm = t < 300 ? 1000*sim->hull->mg*(300-t)/300. : 0.;
    /* gdouble fx = t < 10 ? -dc*u[0] : t < 20 ? -dc*(20-t)/10.*u[0] :  0.; */
    /* gdouble fy = t < 10 ? -dc*u[1] : t < 20 ? -dc*(20-t)/10.*u[1] :  0.; */
    /* gdouble fz = t < 10 ? -dc*u[2] : t < 20 ? -dc*(20-t)/10.*u[2] :  0.; */
    /* gdouble mx = t < 10 ? -dc*u[3] : t < 20 ? -dc*(20-t)/10.*u[3] :  0.; */
    /* gdouble my = t < 10 ? -dc*u[4] : t < 20 ? -dc*(20-t)/10.*u[4] :  0.; */
    /* gdouble mz = t < 10 ? -dc*u[5] : t < 20 ? -dc*(20-t)/10.*u[5] :  0.; */

    /* gdouble fx = t < 3.*period ? -dc*u[0] : t < 6.*period ? -dc*(6.*period-t)/(3.*period)*u[0] :  0.; */
    /* gdouble fy = t < 3.*period ? -dc*u[1] : t < 6.*period ? -dc*(6.*period-t)/(3.*period)*u[1] :  0.; */
    /* gdouble fz = t < 3.*period ? -dc*u[2] : t < 6.*period ? -dc*(6.*period-t)/(3.*period)*u[2] :  0.; */
    /* gdouble mx = t < 3.*period ? -dc*u[3] : t < 6.*period ? -dc*(6.*period-t)/(3.*period)*u[3] :  0.; */
    /* gdouble my = t < 3.*period ? -dc*u[4] : t < 6.*period ? -dc*(6.*period-t)/(3.*period)*u[4] :  0.; */
    /* gdouble mz = t < 3.*period ? -dc*u[5] : t < 6.*period ? -dc*(6.*period-t)/(3.*period)*u[5] :  0.; */

    gdouble fx = -dc*u[0];
    gdouble fy = -dc*u[1];
    gdouble fz = -dc*u[2];
    gdouble mx = -dm*u[3];
    gdouble my = -dm*u[4];
    gdouble mz = -dm*u[5];

    /* f->forces_ext[0] = fx; */
    /* f->forces_ext[1] = fy; */
    /* f->forces_ext[2] = fz; */
    /* f->forces_ext[3] = mx; */
    /* f->forces_ext[4] = my; */
    /* f->forces_ext[5] = m->euler_m.a[0][2]*mx + m->euler_m.a[1][2]*my + m->euler_m.a[2][2]*mz; */


    f->forces_ext[0] = m->euler_m.a[0][0]*fx + m->euler_m.a[1][0]*fy + m->euler_m.a[2][0]*fz;
    f->forces_ext[1] = m->euler_m.a[0][1]*fx + m->euler_m.a[1][1]*fy + m->euler_m.a[2][1]*fz;
    f->forces_ext[2] = m->euler_m.a[0][2]*fx + m->euler_m.a[1][2]*fy + m->euler_m.a[2][2]*fz;
    f->forces_ext[3] = m->euler_m.a[0][0]*mx + m->euler_m.a[1][0]*my + m->euler_m.a[2][0]*mz;
    f->forces_ext[4] = m->euler_m.a[0][1]*mx + m->euler_m.a[1][1]*my + m->euler_m.a[2][1]*mz;
    f->forces_ext[5] = m->euler_m.a[0][2]*mx + m->euler_m.a[1][2]*my + m->euler_m.a[2][2]*mz;
  }
}

gdouble test_hulme_sphere (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = 1.;

  sim->g = /* 9.81 */1.;
  sim->rho = /* 1000. */1.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.005 */0.005;

  // Deep water dispersion relation !!!

  sim->wp.g = /* 9.81 */1.;
  sim->wp.A = 0.01;
  
  sim->wp.h = 5.;
  sim->wp.k = 1.;
  sim->wp.w = sqrt(sim->wp.k);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;
  
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 30,
										      half_sphere_x3,
										      half_sphere_y3,
										      half_sphere_z3,
										      &radius, 3, 4, 3));

  hull_print (sim->hull, NULL);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = 50./sim->wp.k;
  sim->wp.r2 = 50./sim->wp.k;

  sim->N = /* 50 */60;
  sim->M = /* 50 */60;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }

  initialise_motion (sim);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[2] = sqrt(9.81*5);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  //sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_hulme_sphere);
  // sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
    }

    

    

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

gdouble cylinder_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*cos(2.*M_PI*(/* 1- */u));
}

gdouble cylinder_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return *r*sin(2.*M_PI*(/* 1- */u));
}

gdouble cylinder_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  return -v;
}

gdouble maccamy_bathy_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  gdouble a = 3;
  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  return (*r*v+1.)*cos(2.*M_PI*(u));
}

gdouble maccamy_bathy_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  gdouble a = 3;
  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  return (*r*v+1.)*sin(2.*M_PI*(u));
}

gdouble maccamy_bathy_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  return -1.;
}

gdouble malenica_bathy_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  gdouble a = 3;
  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  return (*r*v/* +1. */)*cos(2.*M_PI*(u));
}

gdouble malenica_bathy_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);
  gdouble * r = (gdouble *) data;

  gdouble a = 3;
  v = v < 0.75 ? v*0.5/0.75 : 0.5 + 0.5*(1- log(a*(1.-(v-0.75)/0.25)+1)/log(a+1.));

  return (*r*v/* +1. */)*sin(2.*M_PI*(u));
}

gdouble malenica_bathy_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  //gdouble * h = (gdouble *) data;
  return -5.;
}

/**
 * Test case on wave diffraction by a bottom mounted cylinder.
 * Analytical results can be found in 
 * "Wave and current forces on a vertical cylinder
 *  free to surge and sway", Maccamy et al.,
 * Applied Ocean Research, 17:79-90, 1995.
 * Some numerical results can be found in "Numerical potential flow
 * studies on weakly-nonlinear wave-body interactions with/without
 * small forward speed. Y.L. Shao, PhD Thesis, NTNU, 2010.
 **/
gdouble test_maccamy (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = 1.;

  gint M = 60; // radial resolution
  gint N = 40; // azimuthal resolution
  gint MM = 15; // vertical resolution of cylinder

  sim->g = /* 9.81 */1.;
  sim->rho = /* 1025. */1.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.0025 */0.01;

  // Deep water dispersion relation !!!

  sim->wp.g = /* 9.81 */1.;
  sim->wp.A = /* 0.1 */1.;
  
  sim->wp.h = 1.0;
  sim->wp.k = /* M_PI */2.0;
  sim->wp.w = sqrt(sim->wp.k*sim->wp.g*tanh(sim->wp.k*sim->wp.h));
  printf("Wave period: %f \n", 2.*M_PI/sim->wp.w);
  //sim->wp.w = sqrt(sim->wp.k*sim->wp.g );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  //sim->time.dt = 1./200*2.*M_PI/sim->wp.w;
  sim->time.end = 10.*2.*M_PI/sim->wp.w;

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;

  /* sim->wp.wave_potential = infinite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = infinite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative; */
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = NULL;
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  // sim->fs_potential_update = semi_implicit_no_speed_potential_update;
  // sim->fs_potential_rhs_store = NULL;
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  sim->fs_potential2_update = abm4_no_speed_potential2_update;
  sim->fs_potential2_rhs_store = abm4_no_speed_potential2_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;
  
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, N,
										      cylinder_x,
										      cylinder_y,
										      cylinder_z,
										      &radius, 3, 4, 3));

  hull_print (sim->hull, NULL);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = /* 50./sim->wp.w*0.75 *//* 7. */4*2.*M_PI/sim->wp.k;
  sim->wp.r2 = /* 50./sim->wp.w*0.75 *//* 7. */4*2.*M_PI/sim->wp.k;

  sim->wp.r1_inner = 2.;
  sim->wp.r2_inner = 2.;

  sim->N = /* 50 *//* 80/2 *//* 40 */ N;
  sim->M = /* 50 *//* 80/2 *//* 90 *//* 65 */ M;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  /* g_assert_not_reached (); */
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  // Bathy
  bathy->s->patches = g_slist_append (bathy->s->patches, spline2d_parametric_patch (MM, N,
  										    maccamy_bathy_x,
  										    maccamy_bathy_y,
  										    maccamy_bathy_z,
  										    &sim->wp.r1, 3, 4, 3));

  /* fp = fopen ("norm3.tmp","w"); */
  /* spline2d_print_normals (bathy->s->patches->data, fp); */
  /* fclose(fp); */

  /* fp = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fp); */
  /* fclose (fp); */
  //g_assert_not_reached ();
  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta1
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi1
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi1n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 41, 42);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 40, 41);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 30, 40);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 34, 37);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 35, 38);
  // Store old value of old zeta2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 36, 39);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }

  initialise_motion (sim);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[2] = sqrt(9.81*5);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  //sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_maccamy);
  // sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi1
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi1n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 41, 42);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 40, 41);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 30, 40);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 34, 37);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 35, 38);
    // Store old value of old zeta2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 36, 39);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_1dof_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces, 0);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
    }

    

    

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

gdouble test_moses (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = 20.;

  gint M = /* 60 *//* 65 */45/* 55 */; // radial resolution
  gint N = /* 40 *//* 40 */30/* 40 */; // azimuthal resolution
  gint MM = /* 15 *//* 15 */10; // vertical resolution of cylinder

  sim->g = 9.80665;
  sim->rho = 1025.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  2000.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.0025 *//* 0.025 */0.1;

  // Deep water dispersion relation !!!

  sim->wp.g = 9.80665;
  sim->wp.A = 1.0;
  
  sim->wp.h = 20.0;
  gdouble period = 20.;
  sim->wp.w = 2.*M_PI/period;
  sim->wp.k = /* solve_dispersion_relation (&sim->wp) */sim->wp.w*sim->wp.w/sim->wp.g;

  /* sim->wp.k = /\* M_PI *\/2.0; */
  /* sim->wp.w = sqrt(sim->wp.k*sim->wp.g*tanh(sim->wp.k*sim->wp.h)); */
  /* printf("Wave period: %f \n", 2.*M_PI/sim->wp.w); */
  //sim->wp.w = sqrt(sim->wp.k*sim->wp.g );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  //sim->time.dt = 1./200*2.*M_PI/sim->wp.w;
  //sim->time.end = 10.*2.*M_PI/sim->wp.w;

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  /* sim->wp.wave_potential = finite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = finite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = finite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative; */

  sim->wp.wave_potential = infinite_depth_wave_potential;
  sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = infinite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;  

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = /* 20. */200.;
  sim->wp.r2 = /* 20. */200.;

  sim->wp.r1_inner = 100.;
  sim->wp.r2_inner = 100.;

  sim->wp.r1 = 3.*2.*M_PI/sim->wp.k;
  sim->wp.r2 = 3.*2.*M_PI/sim->wp.k;
  
  sim->wp.r1_inner = 50.;
  sim->wp.r2_inner = 50.;

  sim->N = /* 50 *//* 80/2 *//* 40 */ M;
  sim->M = /* 50 *//* 80/2 *//* 90 *//* 65 */ N;

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, N,
										      half_cylinder_x3,
										      half_cylinder_y3,
										      half_cylinder_z4,
										      &radius, 4, 4, 3));
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 4, 4, 3);
  
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, N,
  										      half_cylinder_bottom_x3,
  										      half_cylinder_bottom_y3,
  										      half_cylinder_bottom_z4,
  										      &radius, 4, 4, 3));

  hull_print (sim->hull, NULL);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);


  /* sim->hull->wet_patches = sim->hull->patches; */
  /* build_free_surface (sim, 3, 4, 3); */

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  /* g_assert_not_reached (); */
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  // Bathy
  /* bathy->s->patches = g_slist_append (bathy->s->patches, spline2d_parametric_patch (MM, N, */
  /* 										    malenica_bathy_x, */
  /* 										    malenica_bathy_y, */
  /* 										    malenica_bathy_z, */
  /* 										    &sim->wp.r1, 3, 4, 3)); */

  /* fp = fopen ("norm3.tmp","w"); */
  /* spline2d_print_normals (bathy->s->patches->data, fp); */
  /* fclose(fp); */

  /* fp = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fp); */
  /* fclose (fp); */
  //g_assert_not_reached ();
  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  hull_print_gnuplot (sim->hull, NULL, 3, sim->time.t);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 
  //initialise_motion (sim);
  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  // For solid cylinder the matrix of inertia is:
  // 1/12m (3r^2+h^2)
  fprintf (flog, "MASSSSS: %e \n", sim->hull->mg);
  //sim->hull->mg = 10.;
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1] = 1./12.*sim->hull->mg*(3.*20.*20.+400.*400.)/* 3 */;
  // m r^2/2
  sim->hull->Ig[2][2] = 0.5*sim->hull->mg*20.*20./* 5. */; // ??
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  initialise_motion (sim);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  fprintf (flog, " Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->M[i][0],
	     sim->hull->M[i][1],
	     sim->hull->M[i][2],
	     sim->hull->M[i][3],
	     sim->hull->M[i][4],
	     sim->hull->M[i][5]);
  }
  fflush (flog);

  fprintf (flog, " Restoring coeff matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->R[i][0],
	     sim->hull->R[i][1],
	     sim->hull->R[i][2],
	     sim->hull->R[i][3],
	     sim->hull->R[i][4],
	     sim->hull->R[i][5]);
  }
  fflush (flog);
  //g_assert_not_reached ();

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[2] = sqrt(9.81*5);

  /* sim->hull->m.u[5] = 0.; // Initial spin */
  /* sim->hull->m.x[5] = 0./\* M_PI/4. *\/; */

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  //sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_malenica);
  sim->forces = g_slist_append (sim->forces, add_initial_damping);
  sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force);
  

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffe = fopen ("fe.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));
    forces_set_to_zero (f);

    //        f = solve_equation_of_motion_1dof_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces, 4);
    
    // f = solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
    }

    

    

    if ( sim->time.itime%1 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
      fprintf (ffe, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_e[0],
      	       f->forces_e[1], f->forces_e[2], f->forces_e[3], f->forces_e[4], f->forces_e[5]);
      fflush (ffe);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffe);
  fclose (ffext);
  fclose (flog);
}

/**
 * Test case for the forced motion of a spheroid in all
 * 6 degrees of freedom. The results can be compared to that
 * published in "Numerical method in wave-body interactions",
 * S.H. Mousavizadegan and M. Rahman, J. Appl. Math. & Computing
 * Vol. 17(2005), N0. 1 - 2, pp. 73 - 91.
 **/
gdouble test_mousavizadegan_spheroid (Simulation * sim)
{
  fprintf(stdout, "Running test_mousavizadegan\n");

  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = 1.;

  sim->g = 1.;
  sim->rho = 1.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.01;

  // Deep water dispersion relation !!!

  sim->wp.g = 1.;
  sim->wp.A = 1.;
  
  sim->wp.h = 5.;
  sim->wp.k = 2.0;
  sim->wp.w = sqrt(sim->wp.k);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 1.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

  // Aspect ratio of half_spheroid
  gdouble ratio = /* 1./6. */ 1./6.;

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (15, /* 40 *//* 55 */40,
  										      half_spheroid_x,
  										      half_spheroid_y,
  										      half_spheroid_z,
  										      &ratio, 3, 4, 3));

  hull_print (sim->hull, NULL);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Radius of domain
  sim->wp.r1 = 400./* 0.8*50./2. */;//* sim->wp.k */*/* 0.75 */0.6;
  sim->wp.r2 = 400./* 0.8*50./2. */;//* sim->wp.k */*/* 0.75 */0.6;

  /* sim->wp.r1 = /\* 4.*2.*M_PI/sim->wp.k *\/; */
  /* sim->wp.r2 = /\* 4.*2.*M_PI/sim->wp.k *\/; */

  sim->wp.r1_inner = 100.;
  sim->wp.r2_inner = 100.;

  sim->N = /* 80 */80/* 75 */;
  sim->M = /* 80 */80/* 75 */;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  simulation_calculate_gradients_linear (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);


  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }

  initialise_motion (sim);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  // Change to the initial position if required
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_hulme_sphere);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = /* solve_equation_of_motion_RK4_ABM4 */solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
    }

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

static void add_radiative_forces_oscillating_sphere (Simulation * sim,
						     Forces * f, gdouble t,
						     gdouble u[6], gdouble x[6],
						     gboolean prediction)
{
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  // No rotation
  for ( i = 3; i < 6; i++ ) {
    f->v[i] = f->forces_m[i] = f->forces_l[i] = f->forces_h[i] = 0.;
    f->forces_fk[i] = f->forces_r[i] = f->forces_e[i] = f->forces_ext[i] = 0.;
    f->phi2[i] = 0.;
  }

}

gdouble test_oscillating_sphere (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  500.;
  sim->time.iend = (gint) G_MAXDOUBLE;
  sim->time.dt = 0.01/* 05 */;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = /* 4.5 */0.2;
  sim->wp.h = 50.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 30.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 30,
										      half_sphere_x3,
										      half_sphere_y3,
										      half_sphere_z3,
										      NULL, 3, 4, 3));

  hull_print (sim->hull, NULL);


  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = 150.;
  sim->wp.r2 = 150.;

  sim->N = 40;
  sim->M = 40;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble radius = 5.;
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius; // Hollow sphere is 2./3.
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  initialise_motion (sim);

  // Change to the initial position if required
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
  
  sim->forces = g_slist_append (sim->forces, add_gravity_force);
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_oscillating_sphere);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
    }

    

    

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

gdouble oval_hull_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 90.*cos(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v));
}

gdouble oval_hull_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return -16. + 16.*sin(2.*M_PI*(/* 1- */u))*sin(0.5*M_PI*(1.-v));
}

gdouble oval_hull_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return -12.*cos(M_PI/2.*(1.-v));
}

gdouble test_radiation_hull (Simulation * sim)
{
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005;

  sim->wp.g = 9.81;
  sim->wp.A = 0.15;
  sim->wp.w = /* 2.5 */ 0.025;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 30.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

  

  /* sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 60, */
  /* 										      half_sphere_x2, */
  /* 										      half_sphere_y2, */
  /* 										      half_sphere_z2, */
  /* 										      NULL, 3, 4, 3)); */

  sim->hull->xg.x = /* 80.4 *//* 90.1 */0; // 4.55m forward of midship
  sim->hull->xg.y = -16.;
  sim->hull->xg.z = -3.45; // 11.7 meters above the keel -15.15 + 11.7 = 
  sim->wp.r1 = 500.;
  sim->wp.r2 = 500.;


  /* fp = fopen("1704deck-flat-mesh-12.2.GDF","r"); */
  /* hull_read (sim->hull, fp, 38, 15, TRUE, FALSE, TRUE, FALSE); */
  /* /\* /\\* hull_read (sim->hull, fp, 35, 25, TRUE, TRUE, FALSE); *\\/ *\/ */
  /* //hull_read (sim->hull, fp, 40, 28, TRUE, FALSE, TRUE, FALSE); */
  /* // hull_read (sim->hull, fp, 30, 20, TRUE, FALSE, TRUE, FALSE); */
  /* //hull_read (sim->hull, fp, 35, 25, TRUE, FALSE, TRUE, FALSE); */
  /* fclose (fp); */

  /* sim->hull->patches = g_slist_append (sim->hull->patches, */
  /* 				       spline2d_symmetrical_y (sim->hull->patches->data, 0)); */

  /* /\* // Translate hulls *\/ */
  /* /\* spline2d_translate  (sim->hull->patches->data, 2.*M_PI/sim->wp.k, -10, 0.); *\/ */
  /* /\* spline2d_translate  (sim->hull->patches->next->data , 2.*M_PI/sim->wp.k, -10, 0.); *\/ */
  /* // -86 <=> Midship */
  /* // -16. <=> Half breadth, -2. = initial distance between pier and hull */
  /* spline2d_translate  (sim->hull->patches->data, -86., -16.-2., 0.); */
  /* spline2d_translate  (sim->hull->patches->next->data , -86., -16.-2., 0.); */

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 40,
										      oval_hull_x,
										      oval_hull_y,
										      oval_hull_z,
										      NULL, 3, 4, 3));

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Circular grid
  // fs->s->patches = g_slist_append (fs->s->patches, circular_fs (80, 80, 20, sim, 3, 4, 3));
   //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (50, 50, 20, sim, 3, 4, 3));
  gdouble r = 20;
  //fs->s->patches = g_slist_append (fs->s->patches, spline2d_parametric_periodic_patch (50, 50, circ_x2, circ_y2, circ_z2, &r));

  /* // Radius of domain */
  /* sim->wp.r1 = /\* 75. *\/30.; */
  /* sim->wp.r2 = /\* 75. *\/30.; */

  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  sim->N = 40;
  sim->M = 60;
  //  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);
  
  //g_assert_not_reached ();
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  /* spline2d_fit_galerkin (fs->s->patches->data, centered_gaussian_ring, sim, 9); */

  /* gint a; */
  /* for ( a = 0; a < 1; a++) */
  /*   periodic_fs_filter_variable (fs->s->patches->data, 9); */

  /* print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */
  /* g_assert_not_reached (); */


  simulation_build_galerkin_fit_matrixes (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  initialise_motion (sim);

  sim->forces = g_slist_append (sim->forces, add_radiative_forces);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

    /** Equation of motion for the hull **/
    //g_assert_not_reached ();
    Forces * f = g_malloc (sizeof(Forces));
    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
    }

    if ( sim->time.itime%20 == 0 ) {
      fprintf (ffk, " %e %f %f %f %f %f %f \n", sim->time.t, f->forces_fk[0],
	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %f %f %f %f %f %f \n", sim->time.t, f->forces_h[0],
	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %f %f %f %f %f %f \n", sim->time.t, f->forces_l[0],
	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %f %f %f %f %f %f \n", sim->time.t, f->forces_m[0],
	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      /* periodic_fs_filter_variable (fs->s->patches->data, 9); */
      /* periodic_fs_filter_variable (fs->s->patches->data, 8); */
      /* periodic_fs_filter_variable (fs->s->patches->data, 7); */
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
}


static void add_time_local_forces (Simulation * sim,
				   Forces * f, gdouble t,
				   gdouble u[6], gdouble x[6],
				   gboolean prediction)
{
  /* sim->hull->m.x[2] = 0.05*sin (sim->wp.w*t); */
  /* sim->hull->m.v[2] = sim->hull->m.u[2] = 0.05*sim->wp.w*cos (sim->wp.w*t); */
  //  simulation_calculate_gradients (sim);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_time_local_flow (sim);

  // -> to be merged with the previous one in order to follow Kim's
  // Formulation.
  //solve_boundary_problem_for_time_local_flow (Simulation * sim)

  /* gint i, j; */

  /* for ( i = 0; i < 6; i++) */
  /*   f->forces_h[i] = 0.; */

  /* for ( i = 0; i < 6; i++) { */
  /*   for ( j = 0; j < 6; j++) { */
  /*     f->forces_h[i] -= sim->hull->R[i][j]*x[j]; */
  /*   } */
  /* } */


}

static void add_disturbance_forces (Simulation * sim,
				    Forces * f, gdouble t,
				    gdouble u[6], gdouble x[6],
				    gboolean prediction)
{
  //simulation_calculate_gradients (sim);
  g_test_timer_start ();
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_time_local_flow (sim);
  solve_boundary_problem_for_disturbance_flow (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);
  
  /* // Store u in order to be able to evaluate the acceleration */
  /* gint i; */
  /* for ( i = 0; i < 6; i++) */
  /*   f->a[i] = sim->hull->m.u[i]; */

  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6]/* , uu[4][6], a[6] */;
  gdouble dt = sim->time.dt;
  gint i, j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      /* uu[i][j] = forces->a[j]; */
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  += 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]) + f->forces_fk[j];
      /* a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]); */
    }
  }

  fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}

gdouble test_time_local_flow (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  20.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 30.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

  

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 50,
										      half_sphere_x2,
										      half_sphere_y2,
										      half_sphere_z2,
										      NULL, 3, 4, 3)); 

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Circular grid
  // fs->s->patches = g_slist_append (fs->s->patches, circular_fs (80, 80, 20, sim, 3, 4, 3));
   //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (50, 50, 20, sim, 3, 4, 3));
  gdouble r = 20;
  fs->s->patches = g_slist_append (fs->s->patches, spline2d_parametric_periodic_patch (50, 50, circ_x2, circ_y2, circ_z2, &r));

  // Radius of domain
  sim->wp.r1 = 75;
  sim->wp.r2 = 75;
  

  /* sim->N = 50; */
  /* sim->M = 50; */
  /* sim->hull->wet_patches = sim->hull->patches; */
  /* build_free_surface (sim, 3, 4, 3); */

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  

  /* spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 9); */

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  // Why bother? Those are zero as there is no basis flow
  //solve_boundary_problem_for_m_terms (sim);
  
  
  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
  // Store old value of Phi2n
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
  spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow (sim);

  solve_boundary_problem_for_time_local_flow (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  initialise_motion (sim);

  sim->forces = g_slist_append (sim->forces, add_time_local_forces);
  

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
    // Store old value of Phi2n
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));
    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    sim->hull->m.x[2] = 0.05*sin (sim->wp.w*sim->time.t);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    /** Time integration of free-surface condition
        for wave elevation. **/
    //sim->fs_elevation_update (sim, t, FALSE);

    /** Time integration of free-surface condition
        for disturbance potential **/
    //sim->fs_potential_update (sim, t, FALSE);

    /** Solve boundary problem for disturbance potential **/
    /* solve_boundary_problem_for_disturbance_flow (sim); */


    /* // For leapfrog */
    /* spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 22); */

    /* sim->time.dt = sim->time.dt = /\* 0.001 *\/0.005; */

    /* if (1) { */
    /*   gsl_vector * gsl_rhs; */
      
    /*   //gsl_rhs = sp->build_fit_rhs (sp, explicit_metric_test_rhs_gauss, sim); */
      
    /*   gsl_rhs = sp->build_fit_rhs (sp, leapfrog_metric_test_rhs_gauss, sim, NULL, NULL); */
      
    /*   /\* Solve the problem using superlu *\/ */
    /*   ccs_problem_lu_solve (sp->fit, gsl_rhs); */
      
    /*   sp->copy_fit_solution (sp, gsl_rhs, 9); */
      
    /*   gsl_vector_free (gsl_rhs); */
    /* } */
    /* else { */
    /*   semi_implicit_test_advection (sim); */
    /* } */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100 == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

gdouble test_basis_flow (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 5.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  20.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.0005 /* 0.005 */;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 30.;

  /** Free-surface elevation advection scheme **/
  //sim->fs_elevation_update = leapfrog_no_speed_elevation_update;
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;

  /** Free-surface potential advection scheme **/
  //sim->fs_potential_update = semi_implicit_no_speed_potential_update;
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson

  /** Continuity condition between hull and free-surface **/
  sim->continuity = TRUE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;



  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (10, /* 50 */40,
  								  half_sphere_x2,
  								  half_sphere_y2,
  								  half_sphere_z2,
  								  NULL, 3, 4, 3));
  

  hull_print (sim->hull, NULL);

  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

   

  // Circular grid
  // fs->s->patches = g_slist_append (fs->s->patches, circular_fs (80, 80, 20, sim, 3, 4, 3));
   //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (50, 50, 20, sim, 3, 4, 3));
  gdouble r = 20;
  /* fs->s->patches = g_slist_append (fs->s->patches, spline2d_parametric_periodic_patch (50, 50, circ_x2, circ_y2, circ_z2, &r, 3, 4, 3)); */

  // Radius of domain
  sim->wp.r1 = 15;
  sim->wp.r2 = 15/2.;
  

  sim->N = /* 50 */30;
  sim->M = /* 50 */30;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (60, 60, 60, sim, 3, 4, 3));

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  // spline2d_fit_galerkin (fs->s->patches->data, gaussian_ring, sim, 9);

  /* spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 9); */


  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  simulation_calculate_gradients (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);

  
  
  solve_boundary_problem_for_basis_flow (sim);

  //solve_boundary_problem_for_m_terms (sim);
  
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);

  //print_hull_potential (sim->hull->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();
  // Store old value of phi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of dzPhi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
  // Store old value of dzphi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);

  //solve_boundary_problem_for_time_local_flow (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  initialise_motion (sim);

  //sim->forces = g_slist_append (sim->forces, add_time_local_forces);
  sim->forces = g_slist_append (sim->forces, add_disturbance_forces);
  

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    if ( sim->time.itime%10 == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 5);
      spline2d_filter_variable (sim->hull->patches->data, 18);
      spline2d_filter_variable (sim->hull->patches->data, 9);
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 8);

      periodic_fs_filter_variable (sim->fs->s->patches->data, 5);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 18);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 8);
    }

    // Store old value of phi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of dzPhi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
    // Store old value of dzphi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));
    forces_set_to_zero (f);

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    //sim->hull->m.x[2] = 0.05*sin (sim->wp.w*sim->time.t);
    
    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    /** Time integration of free-surface condition
        for wave elevation. **/
    //sim->fs_elevation_update (sim, t);

    /** Time integration of free-surface condition
        for disturbance potential **/
    //sim->fs_potential_update (sim, t);

    /** Solve boundary problem for disturbance potential **/
    /* solve_boundary_problem_for_disturbance_flow (sim); */


    /* // For leapfrog */
    /* spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 22); */

    /* sim->time.dt = sim->time.dt = /\* 0.001 *\/0.005; */

    /* if (1) { */
    /*   gsl_vector * gsl_rhs; */
      
    /*   //gsl_rhs = sp->build_fit_rhs (sp, explicit_metric_test_rhs_gauss, sim); */
      
    /*   gsl_rhs = sp->build_fit_rhs (sp, leapfrog_metric_test_rhs_gauss, sim, NULL, NULL); */
      
    /*   /\* Solve the problem using superlu *\/ */
    /*   ccs_problem_lu_solve (sp->fit, gsl_rhs); */
      
    /*   sp->copy_fit_solution (sp, gsl_rhs, 9); */
      
    /*   gsl_vector_free (gsl_rhs); */
    /* } */
    /* else { */
    /*   semi_implicit_test_advection (sim); */
    /* } */

    // Update time
    sim->time.itime++;
    /* if ( sim->time.itime%10 == 0 ) { */
    /*   spline2d_filter_variable (sim->hull->patches->data, 7); */
    /*   spline2d_filter_variable (sim->hull->patches->data, 6); */
    /*   spline2d_filter_variable (sim->hull->patches->data, 9); */
    /* } */


    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100 == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

gdouble test_wigley_flow (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = /* 0.3 *//* 0.289 */0.35;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  20.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.001 */ 0.0005 /* 0.005/sqrt(sim->g*L) *//* 0.003 ?? */;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = /* 70. *//* 40 */3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update;
  sim->fs_elevation_rhs_store = NULL;
  sim->fs_elevation_rhs_store = abm4_free_surface_elevation_disturbance_store;
  //sim->fs_elevation_update = explicit_free_surface_elevation_disturbance_update;
  
  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson
  sim->fs_potential_update = abm4_free_surface_disturbance_potential_update;
  sim->fs_potential_rhs_store = NULL;
  sim->fs_potential_rhs_store = abm4_free_surface_disturbance_potential_store;

  //sim->fs_potential_update = explicit_free_surface_disturbance_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = TRUE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (12 /*10*/, /* 45 */ /* 32 */25,
  								  wigley_x2,
  								  wigley_y2,
  								  wigley_z2,
  								  NULL, 3, 4, 3));
  
  
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (12, /* 45 */ /* 32 */25,
  								  wigley_x1,
  								  wigley_y1,
  								  wigley_z1,
  								  NULL, 3, 4, 3));
  

  hull_print (sim->hull, NULL);

  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Radius of domain
  sim->wp.r1 =  /* 5 */3./* 4 */;
  sim->wp.r2 =  /* 2 */1.5/* 1.5 */;
  
  sim->wp.r1_inner =  0.75;
  sim->wp.r2_inner = 0.2;

  sim->N = /* 45  *//* 10 */ /* 60 */40;
  sim->M = /* 45 */ /* 40 */ /* 85 */50;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");
 
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 3);


  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  

  
  
  solve_boundary_problem_for_basis_flow (sim);

  simulation_calculate_gradients_linear (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);

  //solve_boundary_problem_for_m_terms (sim);
  
  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tecplot  (sim->fs->s->patches, &sim->wp, sim->time.t);

  //g_assert_not_reached ();
  // Store old value of phi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of dzPhi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
  // Store old value of dzphi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);


  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  initialise_motion (sim);

  sim->forces = g_slist_append (sim->forces, add_disturbance_forces);  

  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    if ( sim->time.itime%10 == 0 ) {
      /* spline2d_filter_variable (sim->hull->patches->data, 5); */
      /* spline2d_filter_variable (sim->hull->patches->data, 18); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 8); */

      //periodic_fs_filter_variable (sim->fs->s->patches->data, 5);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 18);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 8);
    }

    // Store old value of phi
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of dzPhi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
    // Store old value of dzphi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));
    forces_set_to_zero (f);

    f = solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    

    // Update time
    sim->time.itime++;

     if ( sim->time.itime%15 == 0 ) {
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    sim->time.t += sim->time.dt;

    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100  == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_waterline (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
}

static void add_radiative_forces_wigley (Simulation * sim,
					 Forces * f, gdouble t,
					 gdouble u[6], gdouble x[6],
					 gboolean prediction)
{
  gint aa;
  for ( aa = 0; aa < 6; aa++ ) {
    sim->hull->m.x[aa] = sim->hull->m.v[aa] = sim->hull->m.u[aa] = 0.;
  }

  gint d = 4;
  sim->hull->m.x[d] = sin (sim->wp.w*t);
  sim->hull->m.v[d] = sim->hull->m.u[d] = sim->wp.w*cos (sim->wp.w*t);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.u,
			  sim->hull->m.x);

#if 1
  //  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim (sim);
  //solve_boundary_problem_for_disturbance_flow;

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]) + f->forces_fk[j];
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }
#endif
}

/**
 * Test case for the study of the waves radiated of a wigley hull.
 * Results can be compared to "Second-order steady forces on floating
 * bodies with forward speed" M. D. Ferreira, 1997, p.94 and ownwards.
 **/
gdouble test_wigley_diffraction (Simulation * sim,
				 char * argv[])
{
  
  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 1.;
  sim->rho = 1.;
  sim->U.x = 0./* Froude*sqrt(sim->g*L) */;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.001 */ 0.005 /* 0.005/sqrt(sim->g*L) *//* 0.003 ?? */;

  sim->wp.g = 1.;
  sim->wp.A = 1.;
  
  sim->wp.h = 5.;
  sim->wp.k = atof(argv[1]);
  sim->wp.w = sqrt(sim->wp.k*sim->wp.g);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  /* sim->wp.wave_potential = infinite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = infinite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative; */

  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;
  
  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (15 /*10*/, /* 45 */ 25,
  								  wigley_x2,
  								  wigley_y2,
  								  wigley_z2,
  								  NULL, 3, 4, 3));
  
  
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (15, /* 45 */ 25,
  								  wigley_x1,
  								  wigley_y1,
  								  wigley_z1,
  								  NULL, 3, 4, 3));
  
  /* gdouble ratio = 1./6.; */
  /* sim->hull->patches = g_slist_append (sim->hull->patches, */
  /* 				       spline2d_parametric_patch (12 /\*10*\/, /\* 45 *\/ 20, */
  /* 								  half_spheroid_x2, */
  /* 								  half_spheroid_y2, */
  /* 								  half_spheroid_z2, */
  /* 								  &ratio, 3, 4, 3)); */

  /* sim->hull->patches = g_slist_append (sim->hull->patches, */
  /* 				       spline2d_parametric_patch (12 /\*10*\/, /\* 45 *\/ 20, */
  /* 								  half_spheroid_x1, */
  /* 								  half_spheroid_y1, */
  /* 								  half_spheroid_z1, */
  /* 								  &ratio, 3, 4, 3)); */

  hull_print (sim->hull, NULL);

  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Radius of domain
  sim->wp.r1 =  /*6.*/ /* 20. */ MIN(18.,MAX(4.*2.*M_PI/sim->wp.k,3.));
  sim->wp.r2 =  /* 20. */ MIN(18.,MAX(4.*2.*M_PI/sim->wp.k,3.));
  
  sim->wp.r1_inner =  1.;
  sim->wp.r2_inner = 0.3;

  sim->N = /* 45  *//* 10 */60;
  sim->M = /* 45 */ /* 40 */85;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");
 
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 3);


  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t); */
  /* hull_print_gnuplot (sim->hull, NULL, 3, 0.); */
  /* g_assert_not_reached (); */

  /* calculate_added_mass_matrix (sim, sim->hull->xg); */

  /* gint a; */
  /* for ( a = 0; a < 6; a++) { */
  /*     fprintf (stdout, "A: %e %e %e %e %e %e\n", */
  /* 	       sim->hull->A[a][0], sim->hull->A[a][1], sim->hull->A[a][2], */
  /* 	       sim->hull->A[a][3], sim->hull->A[a][4], sim->hull->A[a][5]); */
  /* } */

  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t); */
  /* hull_print_gnuplot (sim->hull, NULL, 3, 0.); */
  /* g_assert_not_reached (); */

  //g_assert_not_reached ();

  simulation_calculate_gradients_linear (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);


  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tecplot  (sim->fs->s->patches, &sim->wp, sim->time.t);

  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);


  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  

  initialise_motion (sim);
 
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_wigley);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * fv = fopen ("v.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    if ( sim->time.itime%10 == 0 ) {
      periodic_fs_filter_variable (sim->fs->s->patches->data, 18);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
      /* spline2d_filter_variable (sim->hull->patches->data, 18); */
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
    }

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));
    forces_set_to_zero (f);

    f = solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    

    // Update time
    sim->time.itime++;

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
      	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fflush (fu);
      fprintf (fv, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
      	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
      fflush (fv);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
      fprintf (ffl, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_l[0],
      	       f->forces_l[1], f->forces_l[2], f->forces_l[3], f->forces_l[4], f->forces_l[5]);
      fflush (ffl);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_m[0],
      	       f->forces_m[1], f->forces_m[2], f->forces_m[3], f->forces_m[4], f->forces_m[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext[1], f->forces_ext[2], f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]);
      fflush (ffext);
    }

    sim->time.t += sim->time.dt;

    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100  == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
      //g_assert_not_reached ();
    }
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
}

gdouble test_s60_flow (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = 0.3;
  gdouble L = 100.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  20.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.001 */ 0.0005 /* 0.005/sqrt(sim->g*L) *//* 0.003 ?? */;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = /* 70. */40;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  //  sim->fs_potential_update = semi_test;
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  fp = fopen("S60-last.GDF","r");
  //fp = fopen("1704deck-flat-mesh-12.2.GDF","r");
  //hull_read_old (sim->hull, fp, 20, 12, /* TRUE */FALSE, TRUE, FALSE);
  hull_read (sim->hull, fp, 20, 10, TRUE, TRUE, TRUE, FALSE);
  fclose (fp);


  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  
  // Regridding of hull to get desired number of panels
  GSList * patches_tmp = sim->hull->patches;
  sim->hull->patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, 12, 45);
    sim->hull->patches = g_slist_append (sim->hull->patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Regridding of wet hull to get desired number of panels
  patches_tmp = sim->hull->wet_patches;
  sim->hull->wet_patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, 12, 45);
    sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Add other symmetrical hull
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));
  sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches,
  					   spline2d_symmetrical_y (sim->hull->wet_patches->data, 0));

  spline2d_translate  (sim->hull->patches->data, -50., 0., 0.);
  spline2d_translate  (sim->hull->patches->next->data , -50., 0., 0.);
  
  spline2d_translate  (sim->hull->wet_patches->data, -50., 0., 0.);
  spline2d_translate  (sim->hull->wet_patches->next->data , -50., 0., 0.);

  hull_print (sim->hull, NULL);

  fp = fopen ("wet_hull.tmp","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

    /* g_assert_not_reached (); */

  // Circular grid
  // fs->s->patches = g_slist_append (fs->s->patches, circular_fs (80, 80, 20, sim, 3, 4, 3));
   //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (50, 50, 20, sim, 3, 4, 3));
  gdouble r = 20;
  /* fs->s->patches = g_slist_append (fs->s->patches, spline2d_parametric_periodic_patch (50, 50, circ_x2, circ_y2, circ_z2, &r, 3, 4, 3)); */

  // Radius of domain
  sim->wp.r1 =  /* 5 *//* 6. */500;
  sim->wp.r2 =  /* 2 *//* 2.5 */300;
  

  sim->N = /* 45 */ 42;
  sim->M = /* 45 */ 42;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  //fs->s->patches = g_slist_append (fs->s->patches, circular_fs (60, 60, 60, sim, 3, 4, 3));

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");
  g_assert_not_reached (); 
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  //  spline2d_fit_galerkin (fs->s->patches->data, gaussian_ring, sim, 3);

  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 3);


  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  

  
  
  solve_boundary_problem_for_basis_flow (sim);

  //periodic_fs_filter_variable (sim->fs->s->patches->data, 3);

  simulation_calculate_gradients_linear (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);

  //solve_boundary_problem_for_m_terms (sim);
  
  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tecplot  (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();
  /* FILE * ffttmp = fopen ("tmpcheck.tmp","w"); */
  /* Spline2D * sptmp = sim->fs->s->patches->data; */

  /* while (sptmp) { */
  /*   gint ii; */
  /*   gint ng = sptmp->nouter; */
  /*   for ( ii = 0; ii < sptmp->panels->len; ii++) { */
  /*     SPPanel * spptmp = g_ptr_array_index (sptmp->panels, ii); */
  /*     gint m, n; */
  /*     GaussPoints * gp = spptmp->outer; */

  /*     for ( m = 0; m < ng; m++) { */
  /* 	for ( n = 0; n < ng; n++) { */
  /* 	  FSData fsd = g_array_index (gp->fsdata, FSData, m+n*ng); */
  /* 	  Point p = g_array_index (gp->Pi, Point, m+n*ng); */
  /* 	  Vector g = fsd.gradPhi2; */

  /* 	  fprintf (ffttmp, "%f %f %f %f %f \n", p.x, p.y, g.x, g.y, g.z); */
  /* 	} */
  /*     } */
  /*   } */
  /*   sptmp = sptmp->next; */
  /* } */

  /* fclose (ffttmp); */

  //print_hull_potential (sim->hull->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();
  // Store old value of phi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of dzPhi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
  // Store old value of dzphi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);


  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  initialise_motion (sim);

  //sim->forces = g_slist_append (sim->forces, add_time_local_forces);
  sim->forces = g_slist_append (sim->forces, add_disturbance_forces);
  

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    if ( sim->time.itime%10 == 0 ) {
      /* spline2d_filter_variable (sim->hull->patches->data, 5); */
      /* spline2d_filter_variable (sim->hull->patches->data, 18); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 8); */

      //periodic_fs_filter_variable (sim->fs->s->patches->data, 5);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 18);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 8);
    }

    // Store old value of phi
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of dzPhi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
    // Store old value of dzphi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

    /** Equation of motion for the hull **/
    Forces * f = g_malloc (sizeof(Forces));
    forces_set_to_zero (f);

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);
    

    // Update time
    sim->time.itime++;
    /* if ( sim->time.itime%10 == 0 ) { */
    /*   spline2d_filter_variable (sim->hull->patches->data, 7); */
    /*   spline2d_filter_variable (sim->hull->patches->data, 6); */
    /*   spline2d_filter_variable (sim->hull->patches->data, 9); */
    /* } */

    sim->time.t += sim->time.dt;

    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100  == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      //g_assert_not_reached ();
    }
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

static void test_half_sphere_in_oscillatory_flow (Simulation * sim)
{
  // All the way we will follow (Kim, 2011)'s formulation

  // free-surface resolution
  /* sim->N = 61; */
  /* sim->M = 50; */

  sim->N = 40;
  sim->M = 40;
  
  /* sim->N = 20; */
  /* sim->M = 20; */

  /* sim->N = 80; */
  /* sim->M = 60; */

  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.0025/* 0.005/sqrt(sim->g*L) */;

  sim->wp.g = 9.81;
  sim->wp.A = 0.015;
  sim->wp.w = 1.5*sqrt(0.5*9.81);
  sim->wp.h = 2.5;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  //sim->wp.k = M_PI;
  fprintf (stderr, " k is %e \n", sim->wp.k );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);
  
  // For monochronatic finite-depth forcing
  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;
  sim->wp.wave_normal_time_derivative = finite_depth_wave_normal_time_derivative;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 5.;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  sim->self_influence_function = lachat_watson_self_influence_coefficients;
  sim->continuity = TRUE;
  //sim->continuity = FALSE;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_circle;;
  sim->wp.Cs = 60.; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update_periodic;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("spheroid.GDF","r");
  GSList * patches = NULL;
  

  //sim->hull->patches = g_slist_append (sim->hull->patches, periodic_spheroid_surface (10, 40));

  sim->hull->patches = g_slist_append (sim->hull->patches, standard_spheroid_surface (80, 10));

  /* sim->hull->patches = g_slist_append (sim->hull->patches, standard_spheroid_surface (20, 10)); */
  

  fclose (fp);

  //freesurface_init (fs, &sim->wp);

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  
  sim->hull->wet_patches = sim->hull->patches;

  //  fs->s->b->dcb = hull_intersect_with_free_surface (sim->hull, fs->s->hz, sim->time.t, &sim->wp, sim->N);

  //bathymetry_init (bathy, fs->s->b->dcb, &sim->wp);
    
  //boundaries_init (fs->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  //boundaries_init (bathy->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  /* FILE * fout = fopen ("boundaries.tmp","w"); */
  /* boundaries_print (fs->s->b, fout); */
  /* fclose (fout); */
    
  /* fout = fopen ("boundaries2.tmp","w"); */
  /* boundaries_print (bathy->s->b, fout); */
  /* fclose (fout); */

  /* fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (50, 50, spheroid_of_fs_x, spheroid_of_fs_y, NULL)); */

  /* fs->s->patches = g_slist_append (fs->s->patches, (Spline2D *) parametric_grid2 (sim->M, sim->N, testfs_x2, testfs_y2, fs->s)); */

  /* Spline2D * test_fs = fs->s->patches->data; */
  /* test_fs->noflux = FALSE; */

  /* bathy->s->patches = g_slist_append (bathy->s->patches, parametric_grid (15, 15, spheroid_of_bathy_x, spheroid_of_bathy_y, NULL)); */

  /* coeff_set_var_to_constant (bathy->s->patches->data, 2, -sim->wp.h); */

  //  tmp_print (fs->s->patches->data, sim);

  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (sim->fs->s, fp);
  fclose (fp);


  FILE * ff = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  //surface_generate_grid (bathy->s, TRUE);

  //spline2d_discretize_bathymetry (bathy->s->patches->data, &sim->wp, sim->time.t);
  /* fp = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fp); */
  /* fclose (fp); */

  /* ff = fopen ("norm3.tmp","w"); */
  /* ppp = bathy->s->patches->data; */
  /* spline2d_print_normals (ppp, ff); */
  /* fclose(ff); */

  fprintf(stderr,"Grids done\n");


  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  /* // No basis flow */
  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */

  /* Spline2D * sp1 = sim->fs->s->patches->data; */
  /* Spline2D * sp2 = sp1->hull_patch; */
  /* GrevillePoints * gr = sp1->gr; */

  /* gint a; */

  /* for ( a = 0; a < sp1->NU; a++) { */
  /*   gdouble u = g_array_index (gr->ui, gdouble, a); */
  /*   Vector grad1 = potential_gradient_on_surface (sp1, 1.-u, 0., 3); */
  /*   Vector grad2 = potential_gradient_on_surface (sp2, u, 0., 3); */
  /*   Vector NFS = spline2d_normal (sp1, 1.-u, 0.); */

  /*   /\* fprintf (stdout, "%f %f %f  %f %f %f \n", grad1.x, grad1.y, grad1.z, *\/ */
  /*   /\* 	     grad2.x, grad2.y, grad2.z); *\/ */

  /*   fprintf (stdout, "%f %f \n", vector_scalar_product (&grad1, &NFS), vector_scalar_product (&grad2, &NFS)); */

  /*   /\* Point p1 = spline2d_eval_point (sp1, 1.-u, 0.); *\/ */
  /*   /\* Point p2 = spline2d_eval_point (sp2, u, 0.); *\/ */

  /*   /\* fprintf (stdout, "%f %f %f  %f %f %f \n", p1.x, p1.y, p1.z, p2.x, p2.y, p2.z); *\/ */

  /* } */

  /* g_assert_not_reached (); */

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);
    
    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    
    /** Equation of motion for the hull **/

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/

    /** Time integration of free-surface condition
        for wave elevation. **/
    sim->fs_elevation_update (sim, sim->time.t, FALSE);

    /** Time integration of free-surface condition
        for disturbance potential **/
    sim->fs_potential_update (sim, sim->time.t, FALSE);

    /** Solve boundary problem for disturbance potential **/
    solve_boundary_problem_for_disturbance_flow (sim);
    //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    //print_hull_potential (sim->hull->patches, &sim->wp, sim->time.t);
    /* if ( sim->time.itime%20 == 2 ) */
    /*   g_assert_not_reached (); */
    //sleep (1);

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
    }
    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}


/* static void add_analytic_sphere_buoyancy_force (Simulation * sim, Forces * f, gdouble t) */
/* { */
/*   // Here the forces should be expressed in the reference frame of the ship */
/*   // Moments are given at G */
/*   /\* f->forces_ext [0] = 0.; *\/ */
/*   /\* f->forces_ext [1] = 0.; *\/ */
/*   /\* f->forces_ext [2] = 0.; *\/ */
/*   /\* f->forces_ext [3] = 0.; *\/ */
/*   /\* f->forces_ext [4] = 0.; *\/ */
/*   /\* f->forces_ext [5] = 0.; *\/ */

/*   // Those forces will be transformed from the inertial frame of reference */
/*   // to that of the boat. Moments are given at G */
/*   Motion * m = &sim->hull->m;  */
/*   /\* Vector f_inertial, m_inertial; *\/ */
/*   /\* f_inertial.x = 0.; *\/ */
/*   /\* f_inertial.y = 0.; *\/ */
/*   /\* f_inertial.z = -sim->hull->mg*sim->g- 10000*sim->hull->m.v[2]*fabs(sim->hull->m.v[2]); *\/ */

/*   /\* m_inertial.x = 0.; *\/ */
/*   /\* m_inertial.y = 0.; *\/ */
/*   /\* m_inertial.z = 0.; *\/ */

/*   // Transform and add to the forces initially expressed in the inertial frame of reference */
  
/*   f->forces_ext[0] = -m->euler_m.a[2][0]*sim->hull->mg*sim->g; */
/*   f->forces_ext[1] = -m->euler_m.a[2][1]*sim->hull->mg*sim->g; */
/*   f->forces_ext[2] = -m->euler_m.a[2][2]*sim->hull->mg*sim->g; */
/*   f->forces_ext [3] = 0.; */
/*   f->forces_ext [4] = 0.; */
/*   f->forces_ext [5] = 0.; */
  
/*   /\* f->forces_ext[3] += m->euler_m.a[0][0]*m_inertial.x + m->euler_m.a[1][0]*m_inertial.y + m->euler_m.a[2][0]*m_inertial.z; *\/ */
/*   /\* f->forces_ext[4] += m->euler_m.a[0][1]*m_inertial.x + m->euler_m.a[1][1]*m_inertial.y + m->euler_m.a[2][1]*m_inertial.z; *\/ */
/*   /\* f->forces_ext[5] += m->euler_m.a[0][2]*m_inertial.x + m->euler_m.a[1][2]*m_inertial.y + m->euler_m.a[2][2]*m_inertial.z; *\/ */
/* } */

static void test_motion (Simulation * sim)
{
  // Initialising of simulation
  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 2000;
  sim->time.dt = 0.01;

  // Wave properties
  sim->wp.g = 9.81;
  sim->wp.A = 0.15; // 15 cm wave
  sim->wp.w = 2.*M_PI/60.; // = 2pi/period
  sim->wp.h = 2.5;
  sim->wp.k = solve_dispersion_relation (&sim->wp); // 2pi/wavelength
  fprintf (stderr, " k is %e \n", sim->wp.k );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // No waveforcing
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  GSList * patches = NULL;
  sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (40, 40, 3, 4, 3, 1.));

  /* FILE * ffp = fopen("sphere.GDF","r"); */
  /* hull_read (sim->hull, ffp, 20, 20, FALSE, FALSE, FALSE, FALSE); */
  /* fclose (ffp); */

  //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  // Initial position of center of gravity, initial velocities
  initialise_motion (sim);

  // Print initial hull
  FILE * fp = fopen ("hull.out","w");
  spline2d_print_transformed_panels (sim->hull->patches->data, fp, &sim->hull->xg, &sim->hull->m.t, &sim->hull->m.euler_m);
  fclose (fp);
  
  // Print the normals to the panel of the initial hull
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Set all variables to zero (in case)
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  FILE * fmotion = fopen ("motion.tmp","w");

  // Initial speed if required
  /* sim->hull->m.u[3] = 0.2; */
  /* sim->hull->m.u[4] = 0.1; */
  /* sim->hull->m.u[5] = 0.05; */
  
  // Change to the initial position if required
  //sim->hull->m.x[4] = M_PI/3.+0.14;
  //sim->hull->m.x[2] = -0.01;
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  GSList * forces = NULL;
  //forces = g_slist_append (forces, add_pressure_forces);
  forces = g_slist_append (forces, add_fh_fk_forces);
  forces = g_slist_append (forces, add_gravity_force);
  forces = g_slist_append (forces, add_viscous_drag_forces);

  // Time loop
  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {
    // Print time informations
    fprintf (stderr, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Print position info
    if (0) {
      fprintf (stderr, "X: %e %e %e %e %e %e \n", sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fprintf (stderr, "U: %e %e %e %e %e %e \n", sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2],
	       sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]);
      fprintf (stderr, "V: %e %e %e %e %e %e \n", sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2],
	       sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]);
    }

    // Integrates the pressure forces on the mean wetted hull
    /* Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL); */

    /* Vector test; // From sphere to inertial */
    /* Motion * m = &sim->hull->m; */
    /* test.x = m->euler_m.a[0][0]*f->forces_h[0] + m->euler_m.a[0][1]*f->forces_h[1] + m->euler_m.a[0][2]*f->forces_h[2]; */
    /* test.y = m->euler_m.a[1][0]*f->forces_h[0] + m->euler_m.a[1][1]*f->forces_h[1] + m->euler_m.a[1][2]*f->forces_h[2]; */
    /* test.z = m->euler_m.a[2][0]*f->forces_h[0] + m->euler_m.a[2][1]*f->forces_h[1] + m->euler_m.a[2][2]*f->forces_h[2]; */
    /* fprintf (stdout, " Forces: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z); */

    /* fprintf (stderr, "Angle: %f Total hydrostatic forces: %e dec: %e %e %e\n", (sim->hull->m.x[4]*180./M_PI)/\* %(2.*M_PI) *\/, sqrt(f->forces_h[0]*f->forces_h[0]+f->forces_h[1]*f->forces_h[1]+f->forces_h[2]*f->forces_h[2]), f->forces_h[0], f->forces_h[1], f->forces_h[2]); */

    /* fprintf (fmotion, "%f %f %f %f %f %f %f\n", */
    /* 	     sim->time.t, */
    /* 	     sim->hull->m.x[2], sim->hull->m.u[2], */
    /* 	     sim->hull->m.x[4], */
    /* 	     sqrt(f->forces_h[0]*f->forces_h[0]+f->forces_h[1]*f->forces_h[1]+f->forces_h[2]*f->forces_h[2]), */
    /* 	     f->forces_m[2]+f->forces_l[2]+f->forces_h[2]+f->forces_fk[2] +f->forces_r[2]+f->forces_e[2]+f->forces_ext[2], */
    /* 	     sim->hull->mg*9.81); */

    /* g_free (f); */

    // Add external forces like gravity on eventual viscous damping term
    /* add_gravity_force (sim, f, sim->time.t + sim->time.dt); */
    /* add_external_forces (sim, f, sim->time.t + sim->time.dt); */
    
    // Integration of the equation of motion
    // solve_equation_of_motion_pure_RK4 (sim->hull, &sim->time, sim, f, NULL);
    Forces * f = g_malloc (sizeof(Forces));
 
    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, forces);

    fprintf (fmotion, "%f %f %f %f %f %f %f\n",
	     sim->time.t,
	     sim->hull->m.x[0],
	     sim->hull->m.x[1],
	     sim->hull->m.x[2],
	     /* fmod ( */sim->hull->m.x[3]/* , 2*M_PI) */,
	     /* fmod ( */sim->hull->m.x[4]/* , 2*M_PI) */,
	     /* fmod ( */sim->hull->m.x[5]/* , 2*M_PI) */);
    fflush (fmotion);

    forces_total_print (f, stderr, &sim->time);

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      // Can be used to output data every X iterations
    }
    sim->time.t += sim->time.dt;
  }

  fclose (fmotion);
}

double delta_forces_z (double x, void * params)
{
  Simulation * sim = (Simulation *) params;

  sim->hull->m.x[2] = x;
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  //Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);
  /* Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, sim->wp.wave_elevation, sim->time.t, &sim->wp); */

  /* Forces * f = g_malloc (sizeof(Forces)); */

  /* forces_set_to_zero (f); */

  Forces ff;

  forces_set_to_zero (&ff);

  // Estimate forces
  GSList * forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
     /* fprintf (stderr, "F %f %f %f \n", ff.forces_h[0], ff.forces_h[1], ff.forces_h[2]); */
    forces = forces->next;
  }

  /* fprintf (stderr, "F %f %f %f \n", f->forces_h[0], f->forces_h[1], f->forces_h[2]); */
  /* fprintf (stderr, "%f %f %f \n", f->forces_fk[0], f->forces_fk[1], f->forces_fk[2]); */
  /* fprintf (stderr, "%f %f %f \n", f->forces_ext[0], f->forces_ext[1], f->forces_ext[2]); */
  /* fprintf (stderr, "M %f %f %f \n", f->forces_h[3], f->forces_h[4], f->forces_h[5]); */
  /* fprintf (stderr, "%f %f %f \n", f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]); */
  /* fprintf (stderr, "%f %f %f \n", f->forces_ext[3], f->forces_ext[4], f->forces_ext[5]); */
  

  /* while (forces) { */
  /*   ForceFunc forces_func = forces->data; */
  /*   forces_func (sim, fi, t); */
  /*   forces = forces->next; */
  /* } */

  /* gdouble delta = -sim->hull->mg*sim->g */
  /*   + sim->hull->m.euler_m.a[2][0]*(f->forces_h[0]+f->forces_fk[0]) */
  /*   + sim->hull->m.euler_m.a[2][1]*(f->forces_h[1]+f->forces_fk[1]) */
  /*   + sim->hull->m.euler_m.a[2][2]*(f->forces_h[2]+f->forces_fk[2]); */

  gdouble delta = -sim->hull->mg*sim->g
    + sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0])
    + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1])
    + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]);

  //fprintf (stderr, "%f \n", delta);

  /* g_free (f); */

  return delta;
}
 
void find_equilibrium_position_z (Hull * hull, Simulation * sim)
{
  const gsl_root_fsolver_type *T;
  gsl_root_fsolver *s;
  gsl_function F;
  F.function = &delta_forces_z;
  F.params = sim;

  T = gsl_root_fsolver_brent;
  s = gsl_root_fsolver_alloc (T);

  gdouble z0 = -1., z1 = 1.;

  gsl_root_fsolver_set (s, &F, z0, z1);
  
  gint iter = 0;
  int status;

  gdouble r;
  do {
    iter++;
    status = gsl_root_fsolver_iterate (s);
    r = gsl_root_fsolver_root (s);
    z0 = gsl_root_fsolver_x_lower (s);
    z1 = gsl_root_fsolver_x_upper (s);
    status = gsl_root_test_interval (z0, z1, 0, 0.000001);
  }
  while (status == GSL_CONTINUE && iter < 1000);

  gsl_root_fsolver_free (s);

  fprintf (stderr, "Equilibrium: %f \n", r);

  sim->hull->m.equilibrium.x = hull->m.equilibrium.y = 0.;
  sim->hull->m.equilibrium.z = r;
  update_rotation_matrix (&hull->m, hull->m.x,
			  hull->m.u);
}

void adjust_equilibrium_position_z (Hull * hull, Simulation * sim)
{
  const gsl_root_fsolver_type *T;
  gsl_root_fsolver *s;
  gsl_function F;
  F.function = &delta_forces_z;
  F.params = sim;

  T = gsl_root_fsolver_brent;
  s = gsl_root_fsolver_alloc (T);

  /* gdouble z0 = sim->hull->m.x[2]-0.001, z1 = sim->hull->m.x[2]+0.001; */

  gdouble z0 = sim->hull->m.x[2]-0.1, z1 = sim->hull->m.x[2]+0.1;

  gsl_root_fsolver_set (s, &F, z0, z1);
  
  gint iter = 0;
  int status;

  gdouble r;
  do {
    iter++;
    status = gsl_root_fsolver_iterate (s);
    r = gsl_root_fsolver_root (s);
    z0 = gsl_root_fsolver_x_lower (s);
    z1 = gsl_root_fsolver_x_upper (s);
    status = gsl_root_test_interval (z0, z1, 0, 0.000000001);
  }
  while (status == GSL_CONTINUE && iter < 1000);

  gsl_root_fsolver_free (s);

  fprintf (stderr, "Equilibrium: %f \n", r);
  
  sim->hull->m.x[2] = r;

  update_rotation_matrix (&hull->m, hull->m.x,
			  hull->m.u);
}

double delta_forces_xgx (double x, void * params)
{
  Simulation * sim = (Simulation *) params;

  sim->hull->xg.x = x;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, &sim->wp);

  gdouble delta = f->forces_h[4];

  fprintf (stderr, "Forces: %e %e %e Moments: %e %e %e \n",
  	   f->forces_h[0], f->forces_h[1], f->forces_h[2],
  	   f->forces_h[3], f->forces_h[4], f->forces_h[5]);

  g_free (f);

  return delta;
}

void adjust_equilibrium_position_xgx (Hull * hull, Simulation * sim)
{
  const gsl_root_fsolver_type *T;
  gsl_root_fsolver *s;
  gsl_function F;
  F.function = &delta_forces_xgx;
  F.params = sim;

  T = gsl_root_fsolver_brent;
  s = gsl_root_fsolver_alloc (T);

  gdouble z0 = sim->hull->xg.x-20., z1 = sim->hull->xg.x+20.;

  gsl_root_fsolver_set (s, &F, z0, z1);
  
  gint iter = 0;
  int status;

  gdouble r;
  do {
    iter++;
    status = gsl_root_fsolver_iterate (s);
    r = gsl_root_fsolver_root (s);
    z0 = gsl_root_fsolver_x_lower (s);
    z1 = gsl_root_fsolver_x_upper (s);
    status = gsl_root_test_interval (z0, z1, 0, 0.00000001);
  }
  while (status == GSL_CONTINUE && iter < 1000);

  gsl_root_fsolver_free (s);

  fprintf (stderr, "xg : %f \n", r);
  
  sim->hull->xg.x = r;

  update_rotation_matrix (&hull->m, hull->m.x,
			  hull->m.u);
}

double delta_forces_x (double x, void * params)
{
  Simulation * sim = (Simulation *) params;

  sim->hull->m.x[4] = x;
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  //Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);
  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, sim->wp.wave_elevation, sim->time.t, &sim->wp);

  // fprintf (stderr, "%f %f %f \n", f->forces_h[0], f->forces_h[1], f->forces_h[2]);

  /* while (forces) { */
  /*   ForceFunc forces_func = forces->data; */
  /*   forces_func (sim, fi, t); */
  /*   forces = forces->next; */
  /* } */

  gdouble delta = sim->hull->m.euler_m.a[0][0]*(f->forces_h[0]/* +f->forces_fk[0] */)
    + sim->hull->m.euler_m.a[0][1]*(f->forces_h[1]/* +f->forces_fk[1] */)
    + sim->hull->m.euler_m.a[0][2]*(f->forces_h[2]/* +f->forces_fk[2] */);
  /* gdouble delta = sim->hull->m.euler_m.a[0][0]*(f->forces_h[0]) */
  /*   + sim->hull->m.euler_m.a[0][1]*(f->forces_h[1]) */
  /*   + sim->hull->m.euler_m.a[0][2]*(f->forces_h[2]); */

  

  //gdouble delta = f->forces_h[0];

  fprintf (stderr, "Delta %e X: %e \n", delta, x);

  fprintf (stderr, "Forces: %e %e %e Moments: %e %e %e \n",
	   f->forces_h[0], f->forces_h[1], f->forces_h[2],
	   f->forces_h[3], f->forces_h[4], f->forces_h[5]);

  Vector test;
  Motion * m = &sim->hull->m;
  test.x = m->euler_m.a[0][0]*f->forces_h[0] + m->euler_m.a[0][1]*f->forces_h[1] + m->euler_m.a[0][2]*f->forces_h[2];
  test.y = m->euler_m.a[1][0]*f->forces_h[0] + m->euler_m.a[1][1]*f->forces_h[1] + m->euler_m.a[1][2]*f->forces_h[2];
  test.z = m->euler_m.a[2][0]*f->forces_h[0] + m->euler_m.a[2][1]*f->forces_h[1] + m->euler_m.a[2][2]*f->forces_h[2];
  fprintf (stdout, " Forces inertial: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z);

  g_free (f);

  return delta;
}
 
void find_equilibrium_position_x (Hull * hull, Simulation * sim)
{
  const gsl_root_fsolver_type *T;
  gsl_root_fsolver *s;
  gsl_function F;
  F.function = &delta_forces_x;
  F.params = sim;

  T = gsl_root_fsolver_brent;
  s = gsl_root_fsolver_alloc (T);

  // Rotation around y
  gdouble z0 = sim->hull->m.x[4]-0.1, z1 = sim->hull->m.x[4]+0.1;

  gsl_root_fsolver_set (s, &F, z0, z1);
  
  gint iter = 0;
  int status;

  gdouble r;
  do {
    iter++;
    status = gsl_root_fsolver_iterate (s);
    r = gsl_root_fsolver_root (s);
    z0 = gsl_root_fsolver_x_lower (s);
    z1 = gsl_root_fsolver_x_upper (s);
    status = gsl_root_test_interval (z0, z1, 0, 0.000001);
  }
  while (status == GSL_CONTINUE && iter < 1000);

  gsl_root_fsolver_free (s);

  fprintf (stderr, "X Equilibrium: %e \n", r);

  sim->hull->m.equilibrium.z = hull->m.equilibrium.y = 0.;
  sim->hull->m.equilibrium.x = r;
  update_rotation_matrix (&hull->m, hull->m.x,
			  hull->m.u);
}

static int delta_forces_3d_fdf (const gsl_vector * x, void *params,
				gsl_vector * delta, gsl_matrix * J)
{
  Simulation * sim = (Simulation *) params;

  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[4] = gsl_vector_get (x, 1);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces ff;

  forces_set_to_zero (&ff);

  // Estimate forces
  GSList * forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }
  
  gsl_vector_set (delta, 0, sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0])
		  + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1])
		  + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]));
  gsl_vector_set (delta, 1, ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]);

  fprintf (stderr, "Delta: %e %e  %e %e\n", gsl_vector_get (delta, 0),  gsl_vector_get (delta, 1), gsl_vector_get (x, 0), gsl_vector_get (x, 1));


  gdouble dx = 1e-5;

  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[4] = gsl_vector_get (x, 1);

  sim->hull->m.x[0] += dx;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
    
  forces_set_to_zero (&ff);
    
  // Estimate forces
  forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }

  gsl_matrix_set (J, 0, 0, ( (sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0])
		  + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1])
		  + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2])) - gsl_vector_get (delta, 0) )/dx );
  gsl_matrix_set (J, 0, 1, (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4] - gsl_vector_get (delta, 1) )/dx );


  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[4] = gsl_vector_get (x, 1);

  sim->hull->m.x[2] += dx;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
    
  forces_set_to_zero (&ff);
    
  // Estimate forces
  forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }


  gsl_matrix_set (J, 1, 0, ( (sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0])
		  + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1])
		  + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2])) - gsl_vector_get (delta, 0) )/dx );
  gsl_matrix_set (J, 1, 1, (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4] - gsl_vector_get (delta, 1) )/dx );




  /* gsl_matrix_set (J, 1, 0, ( (ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]) - gsl_vector_get (delta, 0) )/dx ); */
  /* gsl_matrix_set (J, 1, 1, ( (ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]) - gsl_vector_get (delta, 1) )/dx); */
  /* gsl_matrix_set (J, 1, 2, ( (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]) - gsl_vector_get (delta, 2) )/dx); */


 



  gint i, j;
  for ( i = 0; i <2; i++ ) {
    for ( j = 0; j < 2; j++ ) {
      fprintf (stderr, "%f ", gsl_matrix_get (J, i, j));
    }
    fprintf (stderr, "\n");
  }

  return GSL_SUCCESS;
}

static int delta_forces_3d_f (const gsl_vector * x, void *params,
			      gsl_vector * delta)
{
  Simulation * sim = (Simulation *) params;

  /* sim->hull->m.x[0] = gsl_vector_get (x, 0); */
  /* //sim->hull->m.x[1] = gsl_vector_get (x, 1); */
  /* sim->hull->m.x[2] = gsl_vector_get (x, 1); */
  /* sim->hull->m.x[3] = gsl_vector_get (x, 2); */
  /* sim->hull->m.x[4] = gsl_vector_get (x, 3); */
  /* sim->hull->m.x[5] = gsl_vector_get (x, 4); */

  //sim->hull->m.x[0] = gsl_vector_get (x, 0);
  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[4] = gsl_vector_get (x, 1);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);


  Forces ff;

  forces_set_to_zero (&ff);

  // Estimate forces
  GSList * forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }
  
  /* gsl_vector_set (delta, 0, ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]); */
  /* //gsl_vector_set (delta, 1, ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1]); */
  /* gsl_vector_set (delta, 1, ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]); */
  /* // gsl_vector_set (delta, 2, ff.forces_h[3]+ff.forces_fk[3]+ff.forces_ext[3]); */
  /* gsl_vector_set (delta, 2, ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]); */
  // gsl_vector_set (delta, 4, ff.forces_h[5]+ff.forces_fk[5]+ff.forces_ext[5]);

  gsl_vector_set (delta, 0, sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0])
		  + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1])
		  + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]));
  gsl_vector_set (delta, 1, ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]);

  fprintf (stderr, "Delta: %e %e  %e %e\n", gsl_vector_get (delta, 0),  gsl_vector_get (delta, 1), gsl_vector_get (x, 0), gsl_vector_get (x, 1));

  return GSL_SUCCESS;
}

static int delta_forces_3d_df (const gsl_vector * x, void *params,
				gsl_matrix * J)
{
  Simulation * sim = (Simulation *) params;

  //sim->hull->m.x[0] = gsl_vector_get (x, 0);
  //sim->hull->m.x[1] = gsl_vector_get (x, 1);
  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  //sim->hull->m.x[3] = gsl_vector_get (x, 2);
  sim->hull->m.x[4] = gsl_vector_get (x, 1);
  //sim->hull->m.x[5] = gsl_vector_get (x, 4);


  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);


  Forces ff;

  forces_set_to_zero (&ff);

  // Estimate forces
  GSList * forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }
  
  gdouble delta[6];

  /* delta[0] = ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]; */
  /* delta[1] = ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1]; */
  /* delta[2] = ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]; */
  /* delta[3] = ff.forces_h[3]+ff.forces_fk[3]+ff.forces_ext[3]; */
  /* delta[4] = ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]; */
  /* delta[5] = ff.forces_h[5]+ff.forces_fk[5]+ff.forces_ext[5]; */

  delta[0] = sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0])
		  + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1])
		  + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]);
  delta[1] = ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4];

  fprintf(stderr, "Forces: %f %f %f %f %f \n", delta[0],
	  delta[1], delta[2], delta[3], delta[4], delta[5]);


  gdouble dx = 1e-5;

  // Estimate of the Jacobian

  /* gint i; */
  /* for ( i = 0; i < 5; i++ ) { */
  /*   sim->hull->m.x[0] = gsl_vector_get (x, 0); */
  /*   //sim->hull->m.x[1] = gsl_vector_get (x, 1); */
  /*   sim->hull->m.x[2] = gsl_vector_get (x, 1); */
  /*   sim->hull->m.x[3] = gsl_vector_get (x, 2); */
  /*   sim->hull->m.x[4] = gsl_vector_get (x, 3); */
  /*   sim->hull->m.x[5] = gsl_vector_get (x, 4); */

  /*   sim->hull->m.x[i>0?i+1:i] += dx; */

  /*   update_rotation_matrix (&sim->hull->m, sim->hull->m.x, */
  /* 			  sim->hull->m.u); */
    
  /*   forces_set_to_zero (&ff); */
    
  /*   // Estimate forces */
  /*   forces = sim->forces; */
  /*   while (forces) { */
  /*     ForceFunc forces_func = forces->data; */
  /*     forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x); */
  /*     forces = forces->next; */
  /*   } */

  /*   gsl_matrix_set (J, i, 0, ( (ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]) - delta[0] )/dx ); */
  /*   //gsl_matrix_set (J, i, 1, ( (ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1]) - delta[1] )/dx); */
  /*   gsl_matrix_set (J, i, 1, ( (ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]) - delta[2] )/dx); */
  /*   gsl_matrix_set (J, i, 2, ( (ff.forces_h[3]+ff.forces_fk[3]+ff.forces_ext[3]) - delta[3] )/dx ); */
  /*   gsl_matrix_set (J, i, 3, ( (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]) - delta[4] )/dx); */
  /*   gsl_matrix_set (J, i, 4, ( (ff.forces_h[5]+ff.forces_fk[5]+ff.forces_ext[5]) - delta[5] )/dx); */

  /* } */

  
  
  /* sim->hull->m.x[0] = gsl_vector_get (x, 0); */
  /* sim->hull->m.x[2] = gsl_vector_get (x, 1); */
  /* sim->hull->m.x[4] = gsl_vector_get (x, 2); */

  /* sim->hull->m.x[0] += dx; */

  /* update_rotation_matrix (&sim->hull->m, sim->hull->m.x, */
  /* 			  sim->hull->m.u); */
    
  /* forces_set_to_zero (&ff); */
    
  /* // Estimate forces */
  /* forces = sim->forces; */
  /* while (forces) { */
  /*   ForceFunc forces_func = forces->data; */
  /*   forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x); */
  /*   forces = forces->next; */
  /* } */

  /* gsl_matrix_set (J, 0, 0, ( (ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]) - delta[0] )/dx ); */
  /* gsl_matrix_set (J, 0, 1, ( (ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]) - delta[2] )/dx); */
  /* gsl_matrix_set (J, 0, 2, ( (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]) - delta[4] )/dx); */

  /* // 2 */
  /* sim->hull->m.x[0] = gsl_vector_get (x, 0); */
  /* sim->hull->m.x[2] = gsl_vector_get (x, 1); */
  /* sim->hull->m.x[4] = gsl_vector_get (x, 2); */

  /* sim->hull->m.x[2] += dx; */

  /* update_rotation_matrix (&sim->hull->m, sim->hull->m.x, */
  /* 			  sim->hull->m.u); */
    
  /* forces_set_to_zero (&ff); */
    
  /* // Estimate forces */
  /* forces = sim->forces; */
  /* while (forces) { */
  /*   ForceFunc forces_func = forces->data; */
  /*   forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x); */
  /*   forces = forces->next; */
  /* } */

  /* gsl_matrix_set (J, 1, 0, ( (ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]) - delta[0] )/dx ); */
  /* gsl_matrix_set (J, 1, 1, ( (ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]) - delta[2] )/dx); */
  /* gsl_matrix_set (J, 1, 2, ( (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]) - delta[4] )/dx); */


  /* // 4 */
  /* sim->hull->m.x[0] = gsl_vector_get (x, 0); */
  /* sim->hull->m.x[2] = gsl_vector_get (x, 1); */
  /* sim->hull->m.x[4] = gsl_vector_get (x, 2); */

  /* sim->hull->m.x[4] += dx; */

  /* update_rotation_matrix (&sim->hull->m, sim->hull->m.x, */
  /* 			  sim->hull->m.u); */
    
  /* forces_set_to_zero (&ff); */
    
  /* // Estimate forces */
  /* forces = sim->forces; */
  /* while (forces) { */
  /*   ForceFunc forces_func = forces->data; */
  /*   forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x); */
  /*   forces = forces->next; */
  /* } */

  /* gsl_matrix_set (J, 2, 0, ( (ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]) - delta[0] )/dx ); */
  /* gsl_matrix_set (J, 2, 1, ( (ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]) - delta[2] )/dx); */
  /* gsl_matrix_set (J, 2, 2, ( (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]) - delta[4] )/dx); */

  //

  /* gint j; */
  /* for ( i = 0; i <5; i++ ) { */
  /*   for ( j = 0; j < 5; j++ ) { */
  /*     fprintf (stderr, "%f ", gsl_matrix_get (J, i, j)); */
  /*   } */
  /*   fprintf (stderr, "\n"); */
  /* } */
  
sim->hull->m.x[2] = gsl_vector_get (x, 0);
  //sim->hull->m.x[2] = gsl_vector_get (x, 1);
  sim->hull->m.x[4] = gsl_vector_get (x, 1);

  sim->hull->m.x[0] += dx;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
    
  forces_set_to_zero (&ff);
    
  // Estimate forces
  forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }

  gsl_matrix_set (J, 0, 0, ( (sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0])
		  + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1])
		  + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2])) - delta[0] )/dx );
  gsl_matrix_set (J, 0, 1, (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4] - delta[1] )/dx );

  /* gsl_matrix_set (J, 0, 0, ( (ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0]) - gsl_vector_get (delta, 0) )/dx ); */
  /* gsl_matrix_set (J, 0, 1, ( (ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2]) - gsl_vector_get (delta, 1) )/dx); */
  /* gsl_matrix_set (J, 0, 2, ( (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4]) - gsl_vector_get (delta, 2) )/dx); */

  // 2
  //sim->hull->m.x[0] = gsl_vector_get (x, 0);
  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[4] = gsl_vector_get (x, 1);

  sim->hull->m.x[2] += dx;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
    
  forces_set_to_zero (&ff);
    
  // Estimate forces
  forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }


  gsl_matrix_set (J, 1, 0, ( (sim->hull->m.euler_m.a[2][0]*(ff.forces_h[0]+ff.forces_fk[0]+ff.forces_ext[0])
		  + sim->hull->m.euler_m.a[2][1]*(ff.forces_h[1]+ff.forces_fk[1]+ff.forces_ext[1])
		  + sim->hull->m.euler_m.a[2][2]*(ff.forces_h[2]+ff.forces_fk[2]+ff.forces_ext[2])) - delta[0] )/dx );
  gsl_matrix_set (J, 1, 1, (ff.forces_h[4]+ff.forces_fk[4]+ff.forces_ext[4] - delta[1] )/dx );


  return GSL_SUCCESS;
}

void find_start_equilibrium (Hull * hull, Simulation * sim)
{
  const gsl_multiroot_fdfsolver_type *T;
  gsl_multiroot_fdfsolver *s;
  gsl_function F;

  const size_t n = 2;
  gsl_multiroot_function_fdf f = {&delta_forces_3d_f, &delta_forces_3d_df, &delta_forces_3d_fdf, n, sim};

  gsl_vector *x = gsl_vector_alloc (n);

  gint j;

  /* for ( j = 0; j < 5; j++) */
  /*   gsl_vector_set (x, 0, sim->hull->m.x[j>0?j+1:j]); */

  gsl_vector_set (x, 0, sim->hull->m.x[2]);
  gsl_vector_set (x, 1, sim->hull->m.x[4]);
  //gsl_vector_set (x, 2, sim->hull->m.x[4]);

  T = gsl_multiroot_fdfsolver_hybridsj;
  s = gsl_multiroot_fdfsolver_alloc (T, n);
  gsl_multiroot_fdfsolver_set (s, &f, x);

  int status;
  size_t i, iter = 0;
  
  //  print_state (iter, s);
     
  do {
      iter++;
      status = gsl_multiroot_fdfsolver_iterate (s);
     
      //print_state (iter, s);
     
      if (status)   /* check if solver is stuck */
  	break;
     
      status =
  	gsl_multiroot_test_residual (s->f, 1e-5);
  }
  while (status == GSL_CONTINUE && iter < 1000);
     
  printf ("status = %s\n", gsl_strerror (status));

  /* for ( j = 0; j < 5; j++) { */
  /*   sim->hull->m.x[j>0?j+1:j] = gsl_vector_get (x, j); */
  /* } */

  //sim->hull->m.x[0] = gsl_vector_get (x, 0);
  sim->hull->m.x[2] = gsl_vector_get (s->x, 0);
  sim->hull->m.x[4] = gsl_vector_get (s->x, 1);

  fprintf (stderr, "Result: %e %e \n", gsl_vector_get (s->x, 0), gsl_vector_get (s->x, 1));

  gsl_multiroot_fdfsolver_free (s);
  gsl_vector_free (x);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
}

static double forces_minimization_f (const gsl_vector * x,
				     void * params)
{
  Simulation * sim = (Simulation *) params;

  gint i;

  sim->hull->m.x[0] = gsl_vector_get (x, 0);
  sim->hull->m.x[1] = gsl_vector_get (x, 1);
  sim->hull->m.x[2] = gsl_vector_get (x, 2);
  sim->hull->m.x[3] = gsl_vector_get (x, 3);
  sim->hull->m.x[4] = gsl_vector_get (x, 4);
  sim->hull->m.x[5] = gsl_vector_get (x, 5);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces ff;

  forces_set_to_zero (&ff);
  
  // Estimate forces
  GSList * forces = sim->forces;
  while (forces) {
    ForceFunc forces_func = forces->data;
    forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
    forces = forces->next;
  }

  gdouble sum = 0.;

  for ( i = 0; i < 6; i++ )
    sum += fabs ( ff.forces_h[i] + ff.forces_fk[i] + ff.forces_ext[i]
		  + ff.forces_l[i] + ff.forces_m[i] + ff.forces_r[i]
		  + ff.forces_e[i] );

  fprintf (stderr, "Eval : %e \n", sum);

  return sum;
}

static void forces_minimization_at_start (Simulation * sim)
{
  const gsl_multimin_fminimizer_type *T = 
    gsl_multimin_fminimizer_nmsimplex2;
  gsl_multimin_fminimizer *s = NULL;
  gsl_vector *ss, *x;
  gsl_multimin_function minex_func;
     
  size_t iter = 0;
  int status;
  double size;
  gint i;
     
  /* Starting point */
  Motion m = sim->hull->m;
  x = gsl_vector_alloc (6);
  gsl_vector_set (x, 0, m.x[0]);
  gsl_vector_set (x, 1, m.x[1]);
  gsl_vector_set (x, 2, m.x[2]);
  gsl_vector_set (x, 3, m.x[3]);
  gsl_vector_set (x, 4, m.x[4]);
  gsl_vector_set (x, 5, m.x[5]);
     
  /* Set initial step sizes to 1 */
  ss = gsl_vector_alloc (6);
  gsl_vector_set (ss, 0, 0.03);
  gsl_vector_set (ss, 1, 0.03);
  gsl_vector_set (ss, 2, 0.03);
  gsl_vector_set (ss, 3, 0.00);
  gsl_vector_set (ss, 4, 0.003);
  gsl_vector_set (ss, 5, 0.00);
     
  /* Initialize method and iterate */
  minex_func.n = 6;
  minex_func.f = forces_minimization_f;
  minex_func.params = sim;
     
  s = gsl_multimin_fminimizer_alloc (T, 6);
  gsl_multimin_fminimizer_set (s, &minex_func, x, ss);
     
  do
    {
      iter++;
      status = gsl_multimin_fminimizer_iterate(s);
           
      if (status) 
	break;
     
      size = gsl_multimin_fminimizer_size (s);
      status = gsl_multimin_test_size (size, 1e-8);
     
      if (status == GSL_SUCCESS)
	{
	  printf ("converged to minimum at\n");
	}
     
      printf ("%5d %10.3e %10.3e f() = %7.3f size = %.3f\n", 
	      (gint) iter,
	      gsl_vector_get (s->x, 0), 
	      gsl_vector_get (s->x, 1), 
	      s->fval, size);
    }
  while (status == GSL_CONTINUE && iter < 1000);

  for ( i = 0; i < 6; i++ )
    sim->hull->m.x[i] = gsl_vector_get (s->x, i);
    
  fprintf (stderr, "End position: %e %e %e  %e %e %e \n",
	   sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	   sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);

   
  gsl_vector_free(x);
  gsl_vector_free(ss);
  gsl_multimin_fminimizer_free (s);
     
 
 update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

 Forces ff;
 forces_set_to_zero (&ff);
  
 // Estimate forces
 GSList * forces = sim->forces;
 while (forces) {
   ForceFunc forces_func = forces->data;
   forces_func (sim, &ff, sim->time.t, sim->hull->m.u, sim->hull->m.x, FALSE);
   forces = forces->next;
 }

 fprintf (stderr, "Forces summary: %e %e %e  %e %e %e \n",
	  ff.forces_h[0] + ff.forces_fk[0] + ff.forces_ext[0]
	  + ff.forces_l[0] + ff.forces_m[0] + ff.forces_r[0] + ff.forces_e[0],
	  ff.forces_h[1] + ff.forces_fk[1] + ff.forces_ext[1]
	  + ff.forces_l[1] + ff.forces_m[1] + ff.forces_r[1] + ff.forces_e[1],
	  ff.forces_h[2] + ff.forces_fk[2] + ff.forces_ext[2]
	  + ff.forces_l[2] + ff.forces_m[2] + ff.forces_r[2] + ff.forces_e[2],
	  ff.forces_h[3] + ff.forces_fk[3] + ff.forces_ext[3]
	  + ff.forces_l[3] + ff.forces_m[3] + ff.forces_r[3] + ff.forces_e[3],
	  ff.forces_h[4] + ff.forces_fk[4] + ff.forces_ext[4]
	  + ff.forces_l[4] + ff.forces_m[4] + ff.forces_r[4] + ff.forces_e[4],
	  ff.forces_h[5] + ff.forces_fk[5] + ff.forces_ext[5]
	  + ff.forces_l[5] + ff.forces_m[5] + ff.forces_r[5] + ff.forces_e[5]);

 // return status;
}

static int delta_forces_3d (const gsl_vector * x, void *params,
			    gsl_vector * delta)
{
  Simulation * sim = (Simulation *) params;

  sim->hull->m.x[0] = gsl_vector_get (x, 0);
  sim->hull->m.x[1] = gsl_vector_get (x, 1);
  sim->hull->m.x[2] = gsl_vector_get (x, 2);
  /* sim->hull->m.x[3] = gsl_vector_get (x, 3); */
  /* sim->hull->m.x[4] = gsl_vector_get (x, 4); */
  /* sim->hull->m.x[5] = gsl_vector_get (x, 5); */

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  /* gdouble delta = -sim->hull->mg*sim->g + sim->hull->m.euler_m.a[2][0]*f->forces_h[0] */
  /*   + sim->hull->m.euler_m.a[2][1]*f->forces_h[1] + sim->hull->m.euler_m.a[2][2]*f->forces_h[2]; */

  /* gdouble d = -sim->hull->mg*sim->g + sim->hull->m.euler_m.a[2][0]*f->forces_h[0] */
  /* 		  + sim->hull->m.euler_m.a[2][1]*f->forces_h[1] + sim->hull->m.euler_m.a[2][2]*f->forces_h[2]; */

  /* fprintf (stderr, " ff : %e %e \n", gsl_vector_get (x, 0), d); */

  fprintf (stderr, " ff : %e %e %e \n", gsl_vector_get (x, 0), gsl_vector_get (x, 1), gsl_vector_get (x, 2));

  /* gsl_vector_set (delta, 0, d); */

  gsl_vector_set (delta, 0, -sim->hull->m.euler_m.a[2][0]*sim->hull->mg*sim->g + f->forces_h[0]);
  gsl_vector_set (delta, 1, -sim->hull->m.euler_m.a[2][1]*sim->hull->mg*sim->g + f->forces_h[1]);
  gsl_vector_set (delta, 2, -sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]);
  /* gsl_vector_set (delta, 3, 0.); */
  /* gsl_vector_set (delta, 4, 0.); */
  /* gsl_vector_set (delta, 5, 0.); */

  g_free (f);

  return GSL_SUCCESS;
}
 
int print_state (size_t iter, gsl_multiroot_fsolver * s)
{
       printf ("iter = %3u x = % .3f % .3f  % .3f "
               "f(x) = % .3e % .3e % .3e\n",
               (int) iter,
               gsl_vector_get (s->x, 0),
               gsl_vector_get (s->x, 1),
       	       gsl_vector_get (s->x, 2),
               gsl_vector_get (s->f, 0),
               gsl_vector_get (s->f, 1),
       	       gsl_vector_get (s->f, 2));
  
}

int print_state_fdf (size_t iter, gsl_multiroot_fdfsolver * s)
{
       printf ("iter = %3u x = % .3f % .3f  % .3f "
               "f(x) = % .3e % .3e % .3e\n",
               (int) iter,
               gsl_vector_get (s->x, 0),
               gsl_vector_get (s->x, 1),
       	       gsl_vector_get (s->x, 2),
               gsl_vector_get (s->f, 0),
               gsl_vector_get (s->f, 1),
       	       gsl_vector_get (s->f, 2));
  
}

static int delta_forces_xg_fdf (const gsl_vector * x, void *params,
				gsl_vector * delta, gsl_matrix * J)
{
  Simulation * sim = (Simulation *) params;

  sim->hull->xg.x = gsl_vector_get (x, 0);
  sim->hull->xg.y = gsl_vector_get (x, 1);
  sim->hull->xg.z = gsl_vector_get (x, 2);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  fprintf (stderr, " xg : %e %e %e \n", gsl_vector_get (x, 0), gsl_vector_get (x, 1), gsl_vector_get (x, 2));

  gsl_vector_set (delta, 1, f->forces_h[3]);
  gsl_vector_set (delta, 2, f->forces_h[4]);
  gsl_vector_set (delta, 2, f->forces_h[4]);

  g_free (f);

  sim->hull->m.x[2] = gsl_vector_get (x, 0)+0.001;
  sim->hull->m.x[3] = gsl_vector_get (x, 1);
  sim->hull->m.x[4] = gsl_vector_get (x, 2);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  gsl_matrix_set (J, 0, 0, -(gsl_vector_get (delta, 0) - (-sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]))/0.001 );
  gsl_matrix_set (J, 0, 1, -(gsl_vector_get (delta, 1) - f->forces_h[3])/0.001);
  gsl_matrix_set (J, 0, 2, -(gsl_vector_get (delta, 2) - f->forces_h[4])/0.001);

  g_free (f);

  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[3] = gsl_vector_get (x, 1)+0.001;
  sim->hull->m.x[4] = gsl_vector_get (x, 2);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  gsl_matrix_set (J, 1, 0, -(gsl_vector_get (delta, 0) - (-sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]))/0.001 );
  gsl_matrix_set (J, 1, 1, -(gsl_vector_get (delta, 1) - f->forces_h[3])/0.001);
  gsl_matrix_set (J, 1, 2, -(gsl_vector_get (delta, 2) - f->forces_h[4])/0.001);

  g_free (f);

  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[3] = gsl_vector_get (x, 1);
  sim->hull->m.x[4] = gsl_vector_get (x, 2)+0.001;
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  gsl_matrix_set (J, 2, 0, -(gsl_vector_get (delta, 0) - (-sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]))/0.001 );
  gsl_matrix_set (J, 2, 1, -(gsl_vector_get (delta, 1) - f->forces_h[3])/0.001);
  gsl_matrix_set (J, 2, 2, -(gsl_vector_get (delta, 2) - f->forces_h[4])/0.001);

  g_free (f);

  fprintf (stderr, "J: %f %f %f \n", gsl_matrix_get (J, 0, 0), gsl_matrix_get (J, 0, 1), gsl_matrix_get (J, 0, 2));
  fprintf (stderr, "J: %f %f %f \n", gsl_matrix_get (J, 1, 0), gsl_matrix_get (J, 1, 1), gsl_matrix_get (J, 1, 2));
  fprintf (stderr, "J: %f %f %f \n", gsl_matrix_get (J, 2, 0), gsl_matrix_get (J, 2, 1), gsl_matrix_get (J, 2, 2));

  return GSL_SUCCESS;
}

static int delta_forces_xg_df (const gsl_vector * x, void *params, gsl_matrix * J)
{
  Simulation * sim = (Simulation *) params;

  gsl_vector * delta = gsl_vector_alloc (x->size);

  /* sim->hull->m.x[0] = gsl_vector_get (x, 0); */
  /* sim->hull->m.x[1] = gsl_vector_get (x, 1); */
  /* sim->hull->m.x[2] = gsl_vector_get (x, 2); */
  /* sim->hull->m.x[3] = gsl_vector_get (x, 3); */
  /* sim->hull->m.x[4] = gsl_vector_get (x, 4); */
  /* sim->hull->m.x[5] = gsl_vector_get (x, 5); */
  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[3] = gsl_vector_get (x, 1);
  sim->hull->m.x[4] = gsl_vector_get (x, 2);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  /* gdouble delta = -sim->hull->mg*sim->g + sim->hull->m.euler_m.a[2][0]*f->forces_h[0] */
  /*   + sim->hull->m.euler_m.a[2][1]*f->forces_h[1] + sim->hull->m.euler_m.a[2][2]*f->forces_h[2]; */

  /* gdouble d = -sim->hull->mg*sim->g + sim->hull->m.euler_m.a[2][0]*f->forces_h[0] */
  /* 		  + sim->hull->m.euler_m.a[2][1]*f->forces_h[1] + sim->hull->m.euler_m.a[2][2]*f->forces_h[2]; */

  /* fprintf (stderr, " ff : %e %e \n", gsl_vector_get (x, 0), d); */

  fprintf (stderr, " ff : %e %e %e \n", gsl_vector_get (x, 0), gsl_vector_get (x, 1), gsl_vector_get (x, 2));

  /* gsl_vector_set (delta, 0, d); */

  /* gsl_vector_set (delta, 0, -sim->hull->m.euler_m.a[2][0]*sim->hull->mg*sim->g + f->forces_h[0]); */
  /* gsl_vector_set (delta, 1, -sim->hull->m.euler_m.a[2][1]*sim->hull->mg*sim->g + f->forces_h[1]); */
  /* gsl_vector_set (delta, 2, -sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]); */
  /* gsl_vector_set (delta, 3, f->forces_h[3]); */
  /* gsl_vector_set (delta, 4, f->forces_h[4]); */
  /* gsl_vector_set (delta, 5, f->forces_h[5]); */
  gsl_vector_set (delta, 0, -sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]);
  gsl_vector_set (delta, 1, f->forces_h[3]);
  gsl_vector_set (delta, 2, f->forces_h[4]);

  g_free (f);

  sim->hull->m.x[2] = gsl_vector_get (x, 0)+0.001;
  sim->hull->m.x[3] = gsl_vector_get (x, 1);
  sim->hull->m.x[4] = gsl_vector_get (x, 2);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  gsl_matrix_set (J, 0, 0, -(gsl_vector_get (delta, 0) - (-sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]))/0.001 );
  gsl_matrix_set (J, 0, 1, -(gsl_vector_get (delta, 1) - f->forces_h[3])/0.001);
  gsl_matrix_set (J, 0, 2, -(gsl_vector_get (delta, 2) - f->forces_h[4])/0.001);

  g_free (f);

  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[3] = gsl_vector_get (x, 1)+0.001;
  sim->hull->m.x[4] = gsl_vector_get (x, 2);
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  gsl_matrix_set (J, 1, 0, -(gsl_vector_get (delta, 0) - (-sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]))/0.001 );
  gsl_matrix_set (J, 1, 1, -(gsl_vector_get (delta, 1) - f->forces_h[3])/0.001);
  gsl_matrix_set (J, 1, 2, -(gsl_vector_get (delta, 2) - f->forces_h[4])/0.001);

  g_free (f);

  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[3] = gsl_vector_get (x, 1);
  sim->hull->m.x[4] = gsl_vector_get (x, 2)+0.001;
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  gsl_matrix_set (J, 2, 0, -(gsl_vector_get (delta, 0) - (-sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]))/0.001 );
  gsl_matrix_set (J, 2, 1, -(gsl_vector_get (delta, 1) - f->forces_h[3])/0.001);
  gsl_matrix_set (J, 2, 2, -(gsl_vector_get (delta, 2) - f->forces_h[4])/0.001);

  g_free (f);
  gsl_vector_free (delta);

  
  fprintf (stderr, "J: %f %f %f \n", gsl_matrix_get (J, 0, 0), gsl_matrix_get (J, 0, 1), gsl_matrix_get (J, 0, 2));
  fprintf (stderr, "J: %f %f %f \n", gsl_matrix_get (J, 1, 0), gsl_matrix_get (J, 1, 1), gsl_matrix_get (J, 1, 2));
  fprintf (stderr, "J: %f %f %f \n", gsl_matrix_get (J, 2, 0), gsl_matrix_get (J, 2, 1), gsl_matrix_get (J, 2, 2));

  return GSL_SUCCESS;
}

static int delta_forces_xg_f (const gsl_vector * x, void *params,
			      gsl_vector * delta)
{
  Simulation * sim = (Simulation *) params;

  /* sim->hull->m.x[0] = gsl_vector_get (x, 0); */
  /* sim->hull->m.x[1] = gsl_vector_get (x, 1); */
  /* sim->hull->m.x[2] = gsl_vector_get (x, 2); */
  /* sim->hull->m.x[3] = gsl_vector_get (x, 3); */
  /* sim->hull->m.x[4] = gsl_vector_get (x, 4); */
  /* sim->hull->m.x[5] = gsl_vector_get (x, 5); */
  sim->hull->m.x[2] = gsl_vector_get (x, 0);
  sim->hull->m.x[3] = gsl_vector_get (x, 1);
  sim->hull->m.x[4] = gsl_vector_get (x, 2);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, NULL);

  /* gdouble delta = -sim->hull->mg*sim->g + sim->hull->m.euler_m.a[2][0]*f->forces_h[0] */
  /*   + sim->hull->m.euler_m.a[2][1]*f->forces_h[1] + sim->hull->m.euler_m.a[2][2]*f->forces_h[2]; */

  /* gdouble d = -sim->hull->mg*sim->g + sim->hull->m.euler_m.a[2][0]*f->forces_h[0] */
  /* 		  + sim->hull->m.euler_m.a[2][1]*f->forces_h[1] + sim->hull->m.euler_m.a[2][2]*f->forces_h[2]; */

  /* fprintf (stderr, " ff : %e %e \n", gsl_vector_get (x, 0), d); */

  fprintf (stderr, " ff : %e %e %e \n", gsl_vector_get (x, 0), gsl_vector_get (x, 1), gsl_vector_get (x, 2));

  /* gsl_vector_set (delta, 0, d); */

  /* gsl_vector_set (delta, 0, -sim->hull->m.euler_m.a[2][0]*sim->hull->mg*sim->g + f->forces_h[0]); */
  /* gsl_vector_set (delta, 1, -sim->hull->m.euler_m.a[2][1]*sim->hull->mg*sim->g + f->forces_h[1]); */
  /* gsl_vector_set (delta, 2, -sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]); */
  /* gsl_vector_set (delta, 3, f->forces_h[3]); */
  /* gsl_vector_set (delta, 4, f->forces_h[4]); */
  /* gsl_vector_set (delta, 5, f->forces_h[5]); */
  gsl_vector_set (delta, 0, -sim->hull->m.euler_m.a[2][2]*sim->hull->mg*sim->g + f->forces_h[2]);
  gsl_vector_set (delta, 1, f->forces_h[3]);
  gsl_vector_set (delta, 2, f->forces_h[4]);

  g_free (f);

  return GSL_SUCCESS;
}

void adjust_xg_3d (Hull * hull, Simulation * sim)
{
  const gsl_multiroot_fdfsolver_type *T;
  gsl_multiroot_fdfsolver *s;
  gsl_function F;
  /* F.function = &delta_forces_3d; */
  /* F.params = sim; */

  const size_t n = 3;
  /* struct rparams p = {1.0, 10.0}; */
  gsl_multiroot_function_fdf f = {&delta_forces_xg_f, &delta_forces_xg_df, &delta_forces_xg_fdf, n, sim};

  /* double x_init[3] = {sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2]}; */
  /* double x_init[1] = {sim->hull->m.x[0]}; */
  gsl_vector *x = gsl_vector_alloc (n);

  gsl_vector_set (x, 0, sim->hull->xg.x);
  gsl_vector_set (x, 1, sim->hull->xg.y);
  gsl_vector_set (x, 2, sim->hull->xg.z);

  /* T = gsl_multiroot_fsolver_hybrids; */
  /* // T = gsl_multiroot_fsolver_dnewton; */
  /* s = gsl_multiroot_fsolver_alloc (T, n); */
  /* gsl_multiroot_fsolver_set (s, &f, x); */

  T = gsl_multiroot_fdfsolver_gnewton;
  s = gsl_multiroot_fdfsolver_alloc (T, n);
  gsl_multiroot_fdfsolver_set (s, &f, x);

  int status;
  size_t i, iter = 0;
  
  print_state_fdf (iter, s);
     
  do {
      iter++;
      status = gsl_multiroot_fdfsolver_iterate (s);
     
      print_state_fdf (iter, s);
     
      if (status)   /* check if solver is stuck */
  	break;
     
      status =
  	gsl_multiroot_test_residual (s->f, 1e-2);
  }
  while (status == GSL_CONTINUE && iter < 1000);
     
  printf ("status = %s\n", gsl_strerror (status));

  sim->hull->xg.x = gsl_vector_get (x, 0);
  sim->hull->xg.y = gsl_vector_get (x, 1);
  sim->hull->xg.z = gsl_vector_get (x, 2);

  gsl_multiroot_fdfsolver_free (s);
  gsl_vector_free (x);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
}

void find_equilibrium_position_3d (Hull * hull, Simulation * sim)
{
  const gsl_multiroot_fsolver_type *T;
  gsl_multiroot_fsolver *s;
  gsl_function F;
  /* F.function = &delta_forces_3d; */
  /* F.params = sim; */

  const size_t n = 3;
  /* struct rparams p = {1.0, 10.0}; */
  gsl_multiroot_function f = {&delta_forces_3d, n, sim};

  /* double x_init[3] = {sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2]}; */
  /* double x_init[1] = {sim->hull->m.x[0]}; */
  gsl_vector *x = gsl_vector_alloc (n);

  gsl_vector_set (x, 0, sim->hull->m.x[0]);
  gsl_vector_set (x, 1, sim->hull->m.x[1]);
  gsl_vector_set (x, 2, sim->hull->m.x[2]);

  T = gsl_multiroot_fsolver_hybrids;
  s = gsl_multiroot_fsolver_alloc (T, n);
  gsl_multiroot_fsolver_set (s, &f, x);

  int status;
  size_t i, iter = 0;
  
  print_state (iter, s);
     
  do {
      iter++;
      status = gsl_multiroot_fsolver_iterate (s);
     
      print_state (iter, s);
     
      if (status)   /* check if solver is stuck */
  	break;
     
      status =
  	gsl_multiroot_test_residual (s->f, 1e-2);
  }
  while (status == GSL_CONTINUE && iter < 1000);
     
  printf ("status = %s\n", gsl_strerror (status));

  sim->hull->m.equilibrium.x = gsl_vector_get (x, 0);
  sim->hull->m.equilibrium.y = gsl_vector_get (x, 1);
  sim->hull->m.equilibrium.z = gsl_vector_get (x, 2);

  gsl_multiroot_fsolver_free (s);
  gsl_vector_free (x);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);
}

void test_motion_potential (Simulation * sim)
{
  // Initialising of simulation
  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  500.;
  sim->time.iend = 40000;
  sim->time.dt = /* 0.01 *//* 01 */0.005;

  // Wave properties
  sim->wp.g = 9.81;
  sim->wp.A = 0.15; // 15 cm wave
  sim->wp.w = 2.*M_PI/60.; // = 2pi/period
  sim->wp.h = 2.5;
  sim->wp.k = solve_dispersion_relation (&sim->wp); // 2pi/wavelength
  fprintf (stderr, " k is %e \n", sim->wp.k );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // For monochronatic finite-depth forcing
  /* sim->wp.wave_potential = finite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = finite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = finite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative; */
  /* sim->wp.wave_normal_time_derivative = finite_depth_wave_normal_time_derivative; */

  sim->wp.wave_potential = zero_scalar_wave_func;
  //sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  //sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  GSList * patches = NULL;
  FILE * fp /* = fopen("sphere.GDF","r") */;
  //  hull_read (sim->hull, fp, 15, 15, FALSE, FALSE, FALSE, FALSE);
  /* fclose (fp); */

  sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (20, 20, 3, 4, 3, 1.));

  simulation_set_to_zero (sim);

  fp = fopen ("hull.out","w");
  hull_print (sim->hull, fp);
  fclose (fp);


  //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = /* 900. */900.;

  // Center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  // Initial position of center of gravity, initial velocities
  initialise_motion (sim);
  //sim->hull->m.x[4] = M_PI/4.;
  //sim->hull->m.x[2] = /* M_PI/4. */0.5;
  /* update_rotation_matrix (&sim->hull->m, sim->hull->m.x, sim->hull->m.u); */

 

  /* find_equilibrium_position_z (sim->hull, sim); */

  /*  Forces * ff0 = wet_hull_pressure_force_integration (sim->hull, sim, sim->wp.wave_elevation, sim->time.t, &sim->wp); */

  /* fprintf (stderr, "%f %f %f \n", ff0->forces_h[0], ff0->forces_h[1], ff0->forces_h[2]); */

  /* calculate_mass_from_position_at_rest (sim->hull, sim); */

  /* calculate_center_of_buoyancy (sim->hull, sim); */

  //  g_assert_not_reached ();

  // Print initial hull
  fp = fopen ("hull.out","w");
  spline2d_print_transformed_panels (sim->hull->patches->data, fp, &sim->hull->xg, &sim->hull->m.t, &sim->hull->m.euler_m);
  fclose (fp);
  /* g_assert_not_reached (); */
  // Print the normals to the panel of the initial hull
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Set all variables to zero (in case)
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  // Initial speed if requiired
  /* sim->hull->m.u[3] = 0.2; */
  /* sim->hull->m.u[4] = 0.1; */
  /* sim->hull->m.u[5] = 0.05; */
  
  // Change to the initial position if required
  //sim->hull->m.x[4] = M_PI/3.+0.14;
  //sim->hull->m.x[2] = -0.01;
  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  //  GSList * forces = NULL;
  //sim->forces = g_slist_append (sim->forces, add_pressure_forces);
  sim->forces = g_slist_append (sim->forces, add_fh_fk_forces);
  sim->forces = g_slist_append (sim->forces, add_gravity_force);
  //  sim->forces = g_slist_append (sim->forces, add_viscous_drag_forces);

  // Finds the z-equilibrium position where the hydrostatic forces
  // compensate exactly for the gravity forces
  find_equilibrium_position_z (sim->hull, sim);
  // find_equilibrium_position_3d (sim->hull, sim);

  Forces * fcheck = wet_hull_pressure_force_integration (sim->hull, sim, sim->wp.wave_elevation, sim->time.t, &sim->wp);
  fprintf (stderr, " %e %e %e %e %e %e %e \n", sim->time.t, fcheck->forces_h[0],
	   fcheck->forces_h[1], fcheck->forces_h[2], fcheck->forces_h[3],
	   fcheck->forces_h[4], fcheck->forces_h[5]);
  g_free (fcheck);

  // g_assert_not_reached ();
  // find_equilibrium_position_3d (sim->hull, sim);

  // Time loop
  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {
    // Print time informations
    if ( sim->time.itime%10 == 0 )
      fprintf (stderr, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Print position info
    /* fprintf (stderr, "X: %e %e %e %e %e %e \n", sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2], */
    /* 	     sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]); */
    /* fprintf (stderr, "U: %e %e %e %e %e %e \n", sim->hull->m.u[0], sim->hull->m.u[1], sim->hull->m.u[2], */
    /* 	     sim->hull->m.u[3], sim->hull->m.u[4], sim->hull->m.u[5]); */
    /* fprintf (stderr, "V: %e %e %e %e %e %e \n", sim->hull->m.v[0], sim->hull->m.v[1], sim->hull->m.v[2], */
    /* 	     sim->hull->m.v[3], sim->hull->m.v[4], sim->hull->m.v[5]); */

    Forces * f = g_malloc (sizeof(Forces));

    // Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, sim->wp.wave_elevation, sim->time.t, &sim->wp);
    
    //Forces * f = wet_hull_pressure_force_integration (sim->hull, sim, flat_sea, sim->time.t, &sim->wp);

    //g_assert_not_reached ();

    // Of the integration, we only keep the hydrostatic and Froude-Krylov forces



    /* Vector test; // From sphere to inertial */
    /* Motion * m = &sim->hull->m; */
    /* test.x = m->euler_m.a[0][0]*f->forces_h[0] + m->euler_m.a[0][1]*f->forces_h[1] + m->euler_m.a[0][2]*f->forces_h[2]; */
    /* test.y = m->euler_m.a[1][0]*f->forces_h[0] + m->euler_m.a[1][1]*f->forces_h[1] + m->euler_m.a[1][2]*f->forces_h[2]; */
    /* test.z = m->euler_m.a[2][0]*f->forces_h[0] + m->euler_m.a[2][1]*f->forces_h[1] + m->euler_m.a[2][2]*f->forces_h[2]; */
    //fprintf (stdout, " Forces: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z);


    /* fprintf (stderr, "Angle: %f Total hydrostatic forces: %e dec: %e %e %e\n", (sim->hull->m.x[4]*180./M_PI)/\* %(2.*M_PI) *\/, sqrt(f->forces_h[0]*f->forces_h[0]+f->forces_h[1]*f->forces_h[1]+f->forces_h[2]*f->forces_h[2]), f->forces_h[0], f->forces_h[1], f->forces_h[2]); */

    /* fprintf (fmotion, "%f %f %f %f %f %f %f\n", */
    /* 	     sim->time.t, */
    /* 	     sim->hull->m.x[2], sim->hull->m.u[2], */
    /* 	     sim->hull->m.x[4], */
    /* 	     sqrt(f->forces_h[0]*f->forces_h[0]+f->forces_h[1]*f->forces_h[1]+f->forces_h[2]*f->forces_h[2]), */
    /* 	     f->forces_m[2]+f->forces_l[2]+f->forces_h[2]+f->forces_fk[2] +f->forces_r[2]+f->forces_e[2]+f->forces_ext[2], */
    /* 	     sim->hull->mg*9.81); */
    if ( sim->time.itime%20 == 0 ) {
      fprintf (fmotion, "%f %f %f %f %f %f %f\n",
	       sim->time.t,
	       sim->hull->m.x[0], sim->hull->m.x[1], sim->hull->m.x[2],
	       sim->hull->m.x[3], sim->hull->m.x[4], sim->hull->m.x[5]);
      fflush (fmotion);
    }

    // Add external forces like gravity on eventual viscous damping term
    //add_gravity_force (sim, f, sim->time.t + sim->time.dt);
    // add_external_forces (sim, f, sim->time.t + sim->time.dt);

    // Print Froude-Krylov forces
    /* test.x = m->euler_m.a[0][0]*f->forces_fk[0] + m->euler_m.a[0][1]*f->forces_fk[1] + m->euler_m.a[0][2]*f->forces_fk[2]; */
    /* test.y = m->euler_m.a[1][0]*f->forces_fk[0] + m->euler_m.a[1][1]*f->forces_fk[1] + m->euler_m.a[1][2]*f->forces_fk[2]; */
    /* test.z = m->euler_m.a[2][0]*f->forces_fk[0] + m->euler_m.a[2][1]*f->forces_fk[1] + m->euler_m.a[2][2]*f->forces_fk[2]; */
    /* fprintf (stderr, " Forces: %f %e %e %e \n", sim->time.t, test.x, test.y, test.z); */

    // Integration of the equation of motion
    //solve_equation_of_motion_pure_RK4 (sim->hull, &sim->time, sim, f, sim->forces);
    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces);

    //forces_total_print (f, stdout, &sim->time);

    if ( sim->time.itime%20 == 0 ) {
      fprintf (ffk, " %e %f %f %f %f %f %f \n", sim->time.t, f->forces_fk[0],
	       f->forces_fk[1], f->forces_fk[2], f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]);
      fflush (ffk);
      fprintf (ffh, " %e %f %f %f %f %f %f \n", sim->time.t, f->forces_h[0],
	       f->forces_h[1], f->forces_h[2], f->forces_h[3], f->forces_h[4], f->forces_h[5]);
      fflush (ffh);
    }
    

    //g_free (f);

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      // Can be used to output data every X iterations
    }
    sim->time.t += sim->time.dt;
  }

  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
}

static void add_external_forces_torsion (Simulation * sim, Forces * f,
					 gdouble t,
					 gdouble u[6], gdouble x[6])
{
  Motion * m = &sim->hull->m;
  gdouble dt = sim->time.dt;
  forces_set_to_zero (f);

  // Here the forces should be expressed in the reference frame of the ship
  // Moments are given at G
  f->forces_ext [0] = 0.;
  f->forces_ext [1] = 0.;
  f->forces_ext [2] = -M_PI*M_PI/4.*cos(sqrt(M_PI/5.)*(t));
  f->forces_ext [3] = 0.;
  f->forces_ext [4] = 0.;
  f->forces_ext [5] = /* -M_PI*m->x[5] */-M_PI*M_PI/4.*cos(sqrt(M_PI/5.)*(t));

  // Those forces will be transformed from the inertial frame of reference
  // to that of the boat. Moments are given at G
  Vector f_inertial, m_inertial;
  f_inertial.x = 0.;
  f_inertial.y = 0.;
  f_inertial.z = 0.;

  m_inertial.x = 0.;
  m_inertial.y = 0.;
  m_inertial.z = 0.;

  // Transform and add to the forces initially expressed in the inertial frame of reference
  
  f->forces_ext[0] += m->euler_m.a[0][0]*f_inertial.x + m->euler_m.a[1][0]*f_inertial.y + m->euler_m.a[2][0]*f_inertial.z;
  f->forces_ext[1] += m->euler_m.a[0][1]*f_inertial.x + m->euler_m.a[1][1]*f_inertial.y + m->euler_m.a[2][1]*f_inertial.z;
  f->forces_ext[2] += m->euler_m.a[0][2]*f_inertial.x + m->euler_m.a[1][2]*f_inertial.y + m->euler_m.a[2][2]*f_inertial.z;
  f->forces_ext[3] += m->euler_m.a[0][0]*m_inertial.x + m->euler_m.a[1][0]*m_inertial.y + m->euler_m.a[2][0]*m_inertial.z;
  f->forces_ext[4] += m->euler_m.a[0][1]*m_inertial.x + m->euler_m.a[1][1]*m_inertial.y + m->euler_m.a[2][1]*m_inertial.z;
  f->forces_ext[5] += m->euler_m.a[0][2]*m_inertial.x + m->euler_m.a[1][2]*m_inertial.y + m->euler_m.a[2][2]*m_inertial.z;
}

static void test_torsion (Simulation * sim)
{
  // free-surface resolution
  sim->N = 40;
  sim->M = 40;

  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 10e6;
  sim->time.dt = 0.01;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 10.;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_circle;
  sim->wp.Cs = 60.; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update_periodic;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("sphere.GDF","r");
  GSList * patches = NULL;

  sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (40, 40, 3, 4, 3, 1.));
  fclose (fp);

  //sphere of radius 1
  gdouble radius = 1.;
  gdouble density = 900.;
  // Center of mass
  sim->hull->xg.x = 0.75*sin(M_PI/3.);
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.75*cos(M_PI/3.);
  
  gdouble mg = 5.;
  gdouble h = 1.;

  // Mass of right
  sim->hull->mg = mg;
  // For solid right cone the matrix of inertia is:
  sim->hull->Ig[0][0] = /* 0.6*mg*h*h+3./20.*mg*0.25*0.25 */3.;
  sim->hull->Ig[1][1] = /* 3./5.*mg*h*h+3./20.*mg*0.25*0.25 */3.;
  sim->hull->Ig[2][2] = /* 3./10.*mg*0.25*.25 */5.;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  // Initial position of center of gravity, initial velocities
  initialise_motion (sim);

  for ( i = 0; i < 6; i++ ) {
    sim->hull->m.x[i] = 0.;
    sim->hull->m.u[i] = 0.;
    sim->hull->m.v[i] = 0.;
  }

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  // No basis flow

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fspeed = fopen ("speed.tmp","w");

  sim->hull->m.u[5] = 0.; // Initial spin
  sim->hull->m.x[5] = M_PI/4.;

  sim->hull->m.u[2] = 0.; // Initial spin
  sim->hull->m.x[2] = M_PI/4.;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  // Set forces
  GSList * forces = NULL;
  forces = g_slist_append (forces, add_external_forces_torsion);

  sim->time.iend = 20000;
  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    if ( sim->time.itime%20 == 0 )
      fprintf (stderr, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, forces);

    // Print motion
    // Analytical solution : x[5] = pi/4.*cos(sqrt(pi/5.)*x)
    fprintf (fmotion, "%f %f %f %f %f %f %f\n",
	     sim->time.t,
	     sim->hull->m.x[0],
	     sim->hull->m.x[1],
	     sim->hull->m.x[2],
	     fmod (sim->hull->m.x[3], 2*M_PI),
	     fmod (sim->hull->m.x[4], 2*M_PI),
	     fmod (sim->hull->m.x[5], 2*M_PI));

    // Print velocity
    // Analytical solutio :  u[5] = -pi/4.*sqrt(pi/5.)*sin(sqrt(pi/5.)*x)
    fprintf (fspeed, "%f %f %f %f %f %f %f\n",
	     sim->time.t,
	     sim->hull->m.u[0],
	     sim->hull->m.u[1],
	     sim->hull->m.u[2],
	     sim->hull->m.u[3],
	     sim->hull->m.u[4],
	     sim->hull->m.u[5]);

    // Update time
    sim->time.itime++;
    sim->time.t += sim->time.dt;
  }

  fclose (fmotion);
  fclose (fspeed);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

static void add_external_forces_gyro (Simulation * sim, Forces * f,
				      gdouble t, gdouble u[6], gdouble x[6])
{
  Motion * m = &sim->hull->m;
  gdouble dt = sim->time.dt;
  forces_set_to_zero (f);

  // Here the forces should be expressed in the reference frame of the ship
  // Moments are given at G
  f->forces_ext [0] = 0.;
  f->forces_ext [1] = 0.;
  f->forces_ext [2] = 0.;
  f->forces_ext [3] = 0.;
  f->forces_ext [4] = 0.;
  f->forces_ext [5] = /* -M_PI*m->x[5] */-M_PI*M_PI/4.*cos(sqrt(M_PI/5.)*(t));

  // Those forces will be transformed from the inertial frame of reference
  // to that of the boat. Moments are given at G
  Vector f_inertial, m_inertial;
  f_inertial.x = 0.;
  f_inertial.y = 0.;
  f_inertial.z = 0.;

  m_inertial.x = 0.;
  m_inertial.y = 0.;
  m_inertial.z = 0.;

  // Transform and add to the forces initially expressed in the inertial frame of reference
  
  f->forces_ext[0] += m->euler_m.a[0][0]*f_inertial.x + m->euler_m.a[1][0]*f_inertial.y + m->euler_m.a[2][0]*f_inertial.z;
  f->forces_ext[1] += m->euler_m.a[0][1]*f_inertial.x + m->euler_m.a[1][1]*f_inertial.y + m->euler_m.a[2][1]*f_inertial.z;
  f->forces_ext[2] += m->euler_m.a[0][2]*f_inertial.x + m->euler_m.a[1][2]*f_inertial.y + m->euler_m.a[2][2]*f_inertial.z;
  f->forces_ext[3] += m->euler_m.a[0][0]*m_inertial.x + m->euler_m.a[1][0]*m_inertial.y + m->euler_m.a[2][0]*m_inertial.z;
  f->forces_ext[4] += m->euler_m.a[0][1]*m_inertial.x + m->euler_m.a[1][1]*m_inertial.y + m->euler_m.a[2][1]*m_inertial.z;
  f->forces_ext[5] += m->euler_m.a[0][2]*m_inertial.x + m->euler_m.a[1][2]*m_inertial.y + m->euler_m.a[2][2]*m_inertial.z;
}

static void test_gyro (Simulation * sim)
{
  // free-surface resolution
  sim->N = 40;
  sim->M = 40;

  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 10e6;
  sim->time.dt = 0.01;

  sim->wp.g = 9.81;
  sim->wp.A = 0.015;
  sim->wp.w = sqrt(0.5*9.81);
  sim->wp.h = 2.5;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  //sim->wp.k = M_PI;
  fprintf (stderr, " k is %e \n", sim->wp.k );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);
  
#if 1
  // For constant unidirectional flow
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
#endif
  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 10.;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_circle;
  sim->wp.Cs = 60.; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update_periodic;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("sphere.GDF","r");
  GSList * patches = NULL;

  sim->hull->patches = g_slist_append (sim->hull->patches, periodic_sphere (40, 40, 3, 4, 3, 1.));
  fclose (fp);

  //sphere of radius 1
  gdouble radius = 1.;
  gdouble density = 900.;
  // Center of mass
  sim->hull->xg.x = 0.75*sin(M_PI/3.);
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.75*cos(M_PI/3.);
  
  gdouble mg = 10.;
  gdouble h = 1.;

  // Mass of right
  sim->hull->mg = mg;
  // For solid right cone the matrix of inertia is:
  sim->hull->Ig[0][0] = /* 0.6*mg*h*h+3./20.*mg*0.25*0.25 */3.;
  sim->hull->Ig[1][1] = /* 3./5.*mg*h*h+3./20.*mg*0.25*0.25 */3.;
  sim->hull->Ig[2][2] = /* 3./10.*mg*0.25*.25 */5.;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  // Initial position of center of gravity, initial velocities
  initialise_motion (sim);
  for ( i = 0; i < 6; i++ ) {
    sim->hull->m.x[i] = 0.;
    sim->hull->m.u[i] = 0.;
    sim->hull->m.v[i] = 0.;
  }

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  // No basis flow

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fspeed = fopen ("speed.tmp","w");

  sim->hull->m.u[5] = 0.; // Initial spin
  sim->hull->m.x[5] = M_PI/4.;

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  // Set forces
  GSList * forces = NULL;
  forces = g_slist_append (forces, add_external_forces_gyro);

  sim->time.iend = 20000;
  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    if ( sim->time.itime%20 == 0 )
      fprintf (stderr, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    Forces * f = g_malloc (sizeof(Forces));

    f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, forces);

    // Print motion
    // Analytical solution : x[5] = pi/4.*cos(sqrt(pi/5.)*x)
    fprintf (fmotion, "%f %f %f %f %f %f %f\n",
	     sim->time.t,
	     sim->hull->m.x[0],
	     sim->hull->m.x[1],
	     sim->hull->m.x[2],
	     fmod (sim->hull->m.x[3], 2*M_PI),
	     fmod (sim->hull->m.x[4], 2*M_PI),
	     fmod (sim->hull->m.x[5], 2*M_PI));

    // Print velocity
    // Analytical solutio :  u[5] = -pi/4.*sqrt(pi/5.)*sin(sqrt(pi/5.)*x)
    fprintf (fspeed, "%f %f %f %f %f %f %f\n",
	     sim->time.t,
	     sim->hull->m.u[0],
	     sim->hull->m.u[1],
	     sim->hull->m.u[2],
	     sim->hull->m.u[3],
	     sim->hull->m.u[4],
	     sim->hull->m.u[5]);

    // Update time
    sim->time.itime++;
    sim->time.t += sim->time.dt;
  }

  fclose (fmotion);
  fclose (fspeed);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

/******************************************************/

typedef struct {
  gdouble x, y, z;
  gdouble u, v;
} PPoint;

PPoint * ppoint_new (Spline2D * sp, Hull * h, 
			      gdouble u, gdouble v)
{
  PPoint * p = g_malloc (sizeof(PPoint));
  //  Point pp = spline2d_hull_eval_point (sp, h, u, v);
  Point pp = hull_transformed_eval_point (h, sp , u, v);

  p->u = u; p->v = v;
  p->x = pp.x;
  p->y = pp.y;
  p->z = pp.z;

  return p;
}

void ppoint_destroy (PPoint * pp)
{
  g_free (pp);
}

GSList * point_location_recursive (Spline2D * patch,
				   gdouble x, gdouble z,
				   PPoint * p00, PPoint * p10,
				   PPoint * p01, PPoint * p11,
				   Hull * h)
{
  gint i;
  gdouble tolerance = 1.e-6;
  GSList * l = NULL;

  gdouble dx[4], dz[4];
  dx[0] = p00->x-x;
  dx[1] = p10->x-x;
  dx[2] = p01->x-x;
  dx[3] = p11->x-x;

  dz[0] = p00->z-z;
  dz[1] = p10->z-z;
  dz[2] = p01->z-z;
  dz[3] = p11->z-z;

  // Test that get out of the loop
  if ( (dx[0] < 0 && dx[1] < 0 && dx[2] < 0 && dx[3] < 0) ||
       (dx[0] > 0 && dx[1] > 0 && dx[2] > 0 && dx[3] > 0) ||
       (dz[0] < 0 && dz[1] < 0 && dz[2] < 0 && dz[3] < 0) ||
       (dz[0] > 0 && dz[1] > 0 && dz[2] > 0 && dz[3] > 0) ) {
    
    return l;
  }  
  gdouble um = 0.5*(p00->u+p10->u);
  gdouble vm = 0.5*(p00->v+p01->v);
  
  // Tolerance reached on physical distance
  gdouble d1 = sqrt( pow(p00->x-p11->x,2.) + pow(p00->y-p11->y,2.) + pow(p00->z-p11->z,2.));
  gdouble d2 = sqrt( pow(p10->x-p01->x,2.) + pow(p10->y-p01->y,2.) + pow(p10->z-p01->z,2.));
  
  if ( (d1 < tolerance)
       && (d2 < tolerance) ) {
    // Return value in (um, vm)
    Point * p = g_malloc (sizeof(Point));
    //*p = spline2d_hull_eval_point (patch, h, um, vm);
    *p = hull_transformed_eval_point (h, patch, um, vm);
    l = g_slist_append (l, p);
    return l;
  }

  // More refinement needed
  PPoint * pmm = ppoint_new (patch, h, um, vm);
  PPoint * pm0 = ppoint_new (patch, h, um, p00->v);
  PPoint * pm1 = ppoint_new (patch, h, um, p01->v);
  PPoint * p0m = ppoint_new (patch, h, p00->u, vm);
  PPoint * p1m = ppoint_new (patch, h, p10->u, vm);

  l = g_slist_concat (l, point_location_recursive (patch, x, z, p00, pm0, p0m, pmm, h));
  l = g_slist_concat (l, point_location_recursive (patch, x, z, pm0, p10, pmm, p1m, h));
  l = g_slist_concat (l, point_location_recursive (patch, x, z, p0m, pmm, p01, pm1, h));
  l = g_slist_concat (l, point_location_recursive (patch, x, z, pmm, p1m, pm1, p11, h));

  ppoint_destroy (pmm);
  ppoint_destroy (pm0);
  ppoint_destroy (pm1);
  ppoint_destroy (p0m);
  ppoint_destroy (p1m);

  return l;
}

GSList * sppanel_point_location (SPPanel * spp,
				 gdouble x, gdouble z,
				 Hull * h)
{
  Spline2D * patch = spp->sp;
  GSList * l = NULL;

  PPoint * p00 = ppoint_new (patch, h, spp->u0, spp->v0);
  PPoint * p10 = ppoint_new (patch, h, spp->u1, spp->v0);
  PPoint * p01 = ppoint_new (patch, h, spp->u0, spp->v1);
  PPoint * p11 = ppoint_new (patch, h, spp->u1, spp->v1);

  l = g_slist_concat (l, point_location_recursive (patch, x, z,
						   p00, p10, p01, p11,
						   h));

  ppoint_destroy (p00);
  ppoint_destroy (p10);
  ppoint_destroy (p01);
  ppoint_destroy (p11);

  return l;
}

void find_buoyancy_center_postion (Simulation * sim)
{
  find_equilibrium_position_z (sim->hull, sim);
}

static void local_netcdf_fh_fk_forces_contribution (Spline2D * sp,
						    Simulation * sim,
						    gpointer data,
						    gdouble u, gdouble v,
						    gdouble weight, 
						    HeightCurve hz,
						    gdouble t,
						    gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  gdouble Ph = 0., Pfk = 0.;
  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  /* gdouble v5n = 0., v3n = 0., v7n = 0.; */
  /* gdouble d5u = 0., d3u = 0., d7u = 0.; */
  /* gdouble d5v = 0., d3v = 0., d7v = 0.; */
  /* Vector gradphi, gradPhi, gradPhi2; */

  /* gdouble var5 = 0., var7 = 0., var11 = 0., var12 = 0., var23 = 0.; */

  gint  i, j;
  size_t /* istart, */ iend, jstart, jend, istart_x;
  /* gsl_matrix * Bu = gsl_matrix_alloc (k, 2); */
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  /* gsl_bspline_deriv_eval_nonzero (MIN(1.-1e-12,u), 1, Bu, &istart, &iend, sp->w_u, sp->wd_u); */
  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */v/* ) */, 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */u/* ) */, 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  /* if (sp->periodic) */
  /*   istart -= sp->k-1; */

  gdouble eta = 0.;

  for ( i = 0; i < k; i++) {
    /* gdouble cu = gsl_matrix_get (Bu, i, 0); */
    /* gdouble cdu = gsl_matrix_get (Bu, i, 1); */
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    /* gint ii = istart; */
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      /* gdouble cudv = cu*cdv; */
      /* gdouble cvdu = cv*cdu; */
      /* gdouble cuv = cu*cv; */
      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
      /* gdouble v3 = coeff (sp,ii,jj,3); */
      /* gdouble v5 = coeff (sp,ii,jj,5); */
      /* gdouble v7 = coeff (sp,ii,jj,7); */

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;

      eta += coeff (sp, iix, jj, 31)*cuvx;

      /* d3u += v3*cvdu; */
      /* d3v += v3*cudv; */
      /* v3n += coeff (sp,ii,jj,4)*cuv; */

      /* d5u += v5*cvdu; */
      /* d5v += v5*cudv; */
      /* v5n += coeff (sp,ii,jj,6)*cuv; */

      /* d7u += v7*cvdu; */
      /* d7v += v7*cudv; */
      /* v7n += coeff (sp,ii,jj,8)*cuv; */

      /* var5 += v5*cuv; */
      /* var7 += v7*cuv; */
      /* var11 += coeff (sp,ii,jj,11)*cuv; */
      /* var12 += coeff (sp,ii,jj,12)*cuv; */
      /* var23 += coeff (sp,ii,jj,23)*cuv; */
    }
    /* istart++; */
    istart_x++;
  }

 // Position in inertial reference frame
 Point p_inertial = hull_transformed_point (sim->hull, p);
 
 /* gsl_matrix_free (Bu); */
 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.x /= J; N.y /= J; N.z /= J;



 Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  
 //gdouble dt = sim->time.dt;

 /* gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t); */





 /* Hydrostatic pressure */
 Ph = -/* sim->rho*sim->g* */(p_inertial.z-hz(p_inertial.x, p_inertial.y, t, hz_data));
 /* Ph = 1.; */
 J *= sim->rho*sim->g*weight;

 /* Froude Krylov-Forces */
 //Pfk = sim->rho*dtphi0;

 // For linear waves dt phi = - g*eta
 Pfk = /* - *//* sim->rho*sim->g* */eta;

 /* Forces */
 /* forces_add_contribution_forces (f, &N, 0., 0., Ph*J, Pfk*J, 0.); */

 gdouble wh = J*Ph;
 gdouble wfk = J*Pfk;

 *(f + 0) += wh*N.x;
 *(f + 1) += wh*N.y;
 *(f + 2) += wh*N.z;
 *(f + 3) += wfk*N.x;
 *(f + 4) += wfk*N.y;
 *(f + 5) += wfk*N.z;
    
 /* Moments */
 Vector x;
 Point xg = sim->hull->xg;
 x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z;
 x = vector_vector_product (&x, &N);

 *(f + 6) += wh*x.x;
 *(f + 7) += wh*x.y;
 *(f + 8) += wh*x.z;
 *(f + 9) += wfk*x.x;
 *(f + 10) += wfk*x.y;
 *(f + 11) += wfk*x.z;
}

static Vector local_netcdf_fh_fk_gauss (SPPanel * spp, gint m, gint n, Simulation * sim,
				      HeightCurve hz, gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  Spline2D * sp = spp->sp;
  Vector pressure;

  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  /* Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t); */

  //gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  // For linear waves dt phi = -g eta
  gdouble dtphi0 = -sim->g*spline2d_eval_gauss_point (sp, gp, m, n, 31);


  /* Hydrostatic pressure */
  pressure.x = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data));

  /* Non-linear Froude-Krylov forces */
  pressure.y = -sim->rho*dtphi0;

  /* /\* Non-linear restoring forces *\/ */
  /* pressure.Pr = 0.; */

  return pressure;
}

static void sppanel_netcdf_fh_fk_forces_integral_gauss (SPPanel * spp,
							Simulation * sim,
							gpointer data,
							gint m, gint n,
							HeightCurve hz,
							gdouble t,
							gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Vector lp = local_netcdf_fh_fk_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.x;
  gdouble wfk = wij*lp.y;

  *(f + 0) += wh*N.x;
  *(f + 1) += wh*N.y;
  *(f + 2) += wh*N.z;
  *(f + 3) += wfk*N.x;
  *(f + 4) += wfk*N.y;
  *(f + 5) += wfk*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  *(f + 6) += wh*x.x;
  *(f + 7) += wh*x.y;
  *(f + 8) += wh*x.z;
  *(f + 9) += wfk*x.x;
  *(f + 10) += wfk*x.y;
  *(f + 11) += wfk*x.z;
}

static void local_netcdf_fh_fk_uv_forces_contribution (Spline2D * sp,
						       Simulation * sim,
						       gpointer data,
						       gdouble u, gdouble v,
						       gdouble weight, 
						       HeightCurve hz,
						       gdouble t,
						       gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  gdouble Ph = 0., Pfk = 0.;
  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  gdouble dtphi0 = 0., eta = 0.;

  gint  i, j;
  size_t istart, iend, jstart, jend, istart_x;
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */v/* ) */, 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */u/* ) */, 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  /* if (sp->periodic) */
  /*   istart -= sp->k-1; */

  for ( i = 0; i < k; i++) {
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    /* gint ii = istart; */
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      /* gdouble cudv = cu*cdv; */

      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
      /* gdouble v3 = coeff (sp,ii,jj,3); */
      /* gdouble v5 = coeff (sp,ii,jj,5); */
      /* gdouble v7 = coeff (sp,ii,jj,7); */

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;

      eta += coeff (sp, iix, jj, 31)*cuvx;

      /* dtphi0 += coeff (sp,iix,jj,30)*cuvx; */
      /* elevation += coeff (sp,iix,jj,31)*cuvx; */
    }
    //istart++;
    istart_x++;
  }

 // Position in inertial reference frame
 Point p_inertial = hull_transformed_point (sim->hull, p);
 
 /* gsl_matrix_free (Bu); */
 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.x /= J; N.y /= J; N.z /= J;



 /* Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t); */
  
 //gdouble dt = sim->time.dt;

 /* gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t); */

 dtphi0 = -sim->g*eta;
 

 /* Hydrostatic pressure */
 /* Ph = -sim->rho*sim->g*(p_inertial.z-hz(p_inertial.x, p_inertial.y, t, hz_data)); */
 Ph = -sim->rho*sim->g*(p_inertial.z-eta);
 /* Ph = 1.; */
 J *= weight;

 /* Froude Krylov-Forces */
 Pfk = -sim->rho*dtphi0;

 /* Forces */
 /* forces_add_contribution_forces (f, &N, 0., 0., Ph*J, Pfk*J, 0.); */

 gdouble wh = J*Ph;
 gdouble wfk = J*Pfk;

 *(f + 0) += wh*N.x;
 *(f + 1) += wh*N.y;
 *(f + 2) += wh*N.z;
 *(f + 3) += wfk*N.x;
 *(f + 4) += wfk*N.y;
 *(f + 5) += wfk*N.z;
    
 /* Moments */
 Vector x;
 Point xg = sim->hull->xg;
 x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z;
 x = vector_vector_product (&x, &N);

 *(f + 6) += wh*x.x;
 *(f + 7) += wh*x.y;
 *(f + 8) += wh*x.z;
 *(f + 9) += wfk*x.x;
 *(f + 10) += wfk*x.y;
 *(f + 11) += wfk*x.z;

}

static void local_netcdf_fh_fk_uv_linear_forces_contribution (Spline2D * sp,
							      Simulation * sim,
							      gpointer data,
							      gdouble u, gdouble v,
							      gdouble weight, 
							      HeightCurve hz,
							      gdouble t,
							      gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  gdouble Ph = 0., Pfk = 0.;
  gint k = sp->k;

  Vector xu, xv;
  xu.x = xu.y = xu.z = 0.;
  xv.x = xv.y = xv.z = 0.;
  Point p;
  p.x = p.y = p.z = 0.;
  gdouble dtphi0 = 0., eta = 0.;

  gint  i, j;
  size_t istart, iend, jstart, jend, istart_x;
  gsl_matrix * Bv = gsl_matrix_alloc (k, 2);
  gsl_matrix * Bux = gsl_matrix_alloc (k, 2);

  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */v/* ) */, 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v);
  gsl_bspline_deriv_eval_nonzero (/* MIN(1.-1e-12, */u/* ) */, 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u);

  /* if (sp->periodic) */
  /*   istart -= sp->k-1; */

  for ( i = 0; i < k; i++) {
    gdouble cux = gsl_matrix_get (Bux, i, 0);
    gdouble cdux = gsl_matrix_get (Bux, i, 1);
    /* gint ii = istart; */
    gint iix = istart_x;
    for ( j = 0; j < k; j++) {
      gint jj = (jstart+j);
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      /* gdouble cudv = cu*cdv; */

      gdouble cudvx = cux*cdv;
      gdouble cvdux = cv*cdux;
      gdouble cuvx = cux*cv;

      gdouble v0 = coeff (sp,iix,jj,0);
      gdouble v1 = coeff (sp,iix,jj,1);
      gdouble v2 = coeff (sp,iix,jj,2);
      /* gdouble v3 = coeff (sp,ii,jj,3); */
      /* gdouble v5 = coeff (sp,ii,jj,5); */
      /* gdouble v7 = coeff (sp,ii,jj,7); */

      xu.x += v0*cvdux;
      xu.y += v1*cvdux;
      xu.z += v2*cvdux;
      xv.x += v0*cudvx;
      xv.y += v1*cudvx;
      xv.z += v2*cudvx;

      p.x += v0*cuvx;
      p.y += v1*cuvx;
      p.z += v2*cuvx;

      eta += coeff (sp, iix, jj, 31)*cuvx;

      /* dtphi0 += coeff (sp,iix,jj,30)*cuvx; */
      /* elevation += coeff (sp,iix,jj,31)*cuvx; */
    }
    //istart++;
    istart_x++;
  }

 // Position in inertial reference frame
 
 /* gsl_matrix_free (Bu); */
 gsl_matrix_free (Bv);
 gsl_matrix_free (Bux);

 /* Normal to the surface */
 Vector N = vector_vector_product (&xu, &xv);
 gdouble J = vector_norm (N);
 N.x /= J; N.y /= J; N.z /= J;



 /* Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t); */
  
 //gdouble dt = sim->time.dt;

 /* gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t); */

 dtphi0 = -sim->g*eta;
 

 /* Hydrostatic pressure */
 //Ph = -sim->rho*sim->g*(p.z-eta);

 J *= weight;

 /* Froude Krylov-Forces */
 Pfk = -sim->rho*dtphi0;

 /* Forces */
 /* forces_add_contribution_forces (f, &N, 0., 0., Ph*J, Pfk*J, 0.); */

 gdouble wh = J*Ph;
 gdouble wfk = J*Pfk;

 *(f + 0) += wh*N.x;
 *(f + 1) += wh*N.y;
 *(f + 2) += wh*N.z;
 *(f + 3) += wfk*N.x;
 *(f + 4) += wfk*N.y;
 *(f + 5) += wfk*N.z;
    
 /* Moments */
 Vector x;
 Point xg = sim->hull->xg;
 x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z;
 x = vector_vector_product (&x, &N);

 *(f + 6) += wh*x.x;
 *(f + 7) += wh*x.y;
 *(f + 8) += wh*x.z;
 *(f + 9) += wfk*x.x;
 *(f + 10) += wfk*x.y;
 *(f + 11) += wfk*x.z;

}

static Vector local_netcdf_fh_fk_uv_gauss (SPPanel * spp, gint m, gint n, Simulation * sim,
					   HeightCurve hz, gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  //gint ng = spp->sp->nouter;
  Spline2D * sp = spp->sp;
  Vector pressure;
  //Vector force;

  //gdouble dt = sim->time.dt;
  //Vector N = g_array_index (gp->Ni, Vector, m + n*ng);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  /* Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t); */

  //gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  //gdouble dtphi0 = spline2d_eval_gauss_point (sp, gp, m, n, 30);

  gdouble eta = spline2d_eval_gauss_point (sp, gp, m, n, 31);

  gdouble dtphi0 = -sim->g*eta;

  /* Hydrostatic pressure */
  pressure.x = -sim->rho*sim->g *( p_inertial.z - eta);

  /* Non-linear Froude-Krylov forces */
  pressure.y = -sim->rho*dtphi0;

  return pressure;
}

static void sppanel_netcdf_fh_fk_uv_forces_integral_gauss (SPPanel * spp,
						    Simulation * sim,
						    gpointer data,
						    gint m, gint n,
						    HeightCurve hz,
						    gdouble t,
						    gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Vector lp = local_netcdf_fh_fk_uv_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.x;
  gdouble wfk = wij*lp.y;

  *(f + 0) += wh*N.x;
  *(f + 1) += wh*N.y;
  *(f + 2) += wh*N.z;
  *(f + 3) += wfk*N.x;
  *(f + 4) += wfk*N.y;
  *(f + 5) += wfk*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  *(f + 6) += wh*x.x;
  *(f + 7) += wh*x.y;
  *(f + 8) += wh*x.z;
  *(f + 9) += wfk*x.x;
  *(f + 10) += wfk*x.y;
  *(f + 11) += wfk*x.z;
}

static Vector local_netcdf_fh_fk_uv_linear_gauss (SPPanel * spp, gint m, gint n, Simulation * sim,
						  HeightCurve hz, gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  Spline2D * sp = spp->sp;
  Vector pressure;
  //Vector force;

  //gdouble dt = sim->time.dt;
  //Vector N = g_array_index (gp->Ni, Vector, m + n*ng);
  /* Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n); */
  
  Point p = g_array_index (gp->Pi, Point, m + n*ng);
  
  /* Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t); */

  //gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t);

  //gdouble dtphi0 = spline2d_eval_gauss_point (sp, gp, m, n, 30);

  gdouble eta = spline2d_eval_gauss_point (sp, gp, m, n, 31);

  gdouble dtphi0 = -sim->g*eta;

  /* Hydrostatic pressure */
  //pressure.x = -sim->rho*sim->g *( p.z - eta);

  /* Non-linear Froude-Krylov forces */
  pressure.y = -sim->rho*dtphi0;

  return pressure;
}

static void sppanel_netcdf_fh_fk_uv_linear_forces_integral_gauss (SPPanel * spp,
								  Simulation * sim,
								  gpointer data,
								  gint m, gint n,
								  HeightCurve hz,
								  gdouble t,
								  gpointer hz_data)
{
  gdouble * f = (gdouble *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Vector lp = local_netcdf_fh_fk_uv_linear_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.x;
  gdouble wfk = wij*lp.y;

  *(f + 0) += wh*N.x;
  *(f + 1) += wh*N.y;
  *(f + 2) += wh*N.z;
  *(f + 3) += wfk*N.x;
  *(f + 4) += wfk*N.y;
  *(f + 5) += wfk*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  *(f + 6) += wh*x.x;
  *(f + 7) += wh*x.y;
  *(f + 8) += wh*x.z;
  *(f + 9) += wfk*x.x;
  *(f + 10) += wfk*x.y;
  *(f + 11) += wfk*x.z;
}

void add_netcdf_fk_fh_forces (Simulation * sim, Forces * f, gdouble t,
			      gdouble u[6], gdouble x[6])
{
  Hull * hull = sim->hull;
  NetCDFForcing * ncdf = sim->ncdf;
  Point xg = sim->hull->xg;
  gdouble rho = sim->rho;
  
  g_assert (ncdf != NULL);
  
  ncdf->time = t;
    
  // Find time position
  gint it = MAX(1, ncdf->it-1);
  gdouble t1 = 0.;
  // Get time ?
  while ( it < ncdf->nt && *(ncdf->t+it-1) < t )
    it++;
    
  if ( *(ncdf->t+it-1) >= t && it > 1)
    it--;

  t1 = *(ncdf->t + it -1);


  // READ DATA IF REQUIRED
  if (ncdf->phi_1 == NULL) { // No data has ever been loaded
    //ncdf->phi_1 = netcdf_load_array (ncdf, ncdf->phi_1, "phi", it);
    ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);
      
    //ncdf->phi_2 = netcdf_load_array (ncdf, ncdf->phi_2, "phi", it+1);
    ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
  }
  else if (ncdf->phi_1->it != it) {
    if (ncdf->phi_2->it == it) { // Can keep half of the data and move them
      NetCDFData * tmp = ncdf->phi_1;
      /* ncdf->phi_1 = ncdf->phi_2; */
      /* ncdf->phi_2 = tmp; */
      /* ncdf->phi_2 = netcdf_load_array (ncdf, ncdf->phi_2, "phi", it+1); */

      tmp = ncdf->elevation_1;
      ncdf->elevation_1 = ncdf->elevation_2;
      ncdf->elevation_2 = tmp;
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
    }
    else { // Need to read two slices
      //ncdf->phi_1 = netcdf_load_array (ncdf, ncdf->phi_1, "phi", it);
      ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);
      
      //ncdf->phi_2 = netcdf_load_array (ncdf, ncdf->phi_2, "phi", it+1);
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
    }
  }
  g_assert (ncdf->elevation_2->it == it+1);
  g_assert (ncdf->elevation_2 != NULL);
  /* fprintf (stderr, "LOAD DATA %f \n", g_test_timer_elapsed()); */

  // Put the interpolated dt phi and elevation on the hull
  GSList * patches = hull->patches;
  while ( patches ) {
    Spline2D * sp = patches->data;

#if 1
    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sp, ncdf, sim->hull, sim->force_coeff);
#else
    DoubleRhs * rhs = netcdf_build_double_galerkin_rhs (sp, ncdf, sim->hull);
#endif

    if (sp->fit == NULL)
      sp->fit = sp->build_fit_matrix (sp);

    /* ccs_problem_lu_solve (sp->fit, rhs->rhs_phi); */
    /* sp->copy_fit_solution (sp, rhs->rhs_phi, 30); */
    
    ccs_problem_lu_solve (sp->fit, rhs->rhs_elevation);
    sp->copy_fit_solution (sp, rhs->rhs_elevation, 31);

    //gsl_vector_free (rhs->rhs_phi);
    gsl_vector_free (rhs->rhs_elevation);
    g_free (rhs);

    patches = patches->next;
  }

  // Integration Froude-Krylov forces
  
  gdouble ff[12];
  gint i;
  for ( i = 0; i < 12; i++)
    ff[i] = 0.;

#if 1
  // Linear formulation
  wet_hull_integration (sim->hull, sim, &ff[0],
  			local_netcdf_fh_fk_uv_linear_forces_contribution,
  			sppanel_netcdf_fh_fk_uv_linear_forces_integral_gauss,
  			pressure_force_integration_tolerance,
  			corner_point_new_uv_linear,
  			uv_elevation, t, &sim->wp);
#else
#if 1 // Integration under the free-surface as given by eta in the netcdf file (var 31)
  wet_hull_integration (sim->hull, sim, &ff[0],
  			local_netcdf_fh_fk_uv_forces_contribution,
  			sppanel_netcdf_fh_fk_uv_forces_integral_gauss,
  			pressure_force_integration_tolerance,
  			corner_point_new_uv,
  			uv_elevation, t, &sim->wp);

  

#else // Integration under the mean-free surface
  wet_hull_integration (sim->hull, sim, &ff[0],
  			local_netcdf_fh_fk_forces_contribution,
  			sppanel_netcdf_fh_fk_forces_integral_gauss,
  			pressure_force_integration_tolerance,
  			corner_point_new,
  			sim->wp.wave_elevation, t, &sim->wp);
#endif
#endif

  /* gdouble ramp = (1.-exp(-t/40.)); */

  f->forces_h[0] += ff[0];
  f->forces_h[1] += ff[1];
  f->forces_h[2] += ff[2];

  f->forces_fk[0] += ff[3]/* *ramp */;
  f->forces_fk[1] += ff[4]/* *ramp */;
  f->forces_fk[2] += ff[5]/* *ramp */;


  f->forces_h[3] += ff[6];
  f->forces_h[4] += ff[7];
  f->forces_h[5] += ff[8];

  f->forces_fk[3] += ff[9]/* *ramp */;
  f->forces_fk[4] += ff[10]/* *ramp */;
  f->forces_fk[5] += ff[11]/* *ramp */;

  /* fprintf (stdout, "%f %f %f %f  %f %f %f \n", t, */
  /* 	   f->forces_fk[0], f->forces_fk[1], f->forces_fk[2], */
  /* 	   f->forces_fk[3], f->forces_fk[4], f->forces_fk[5]); */
}


/**************** FINAL ****************/

static Pressure local_linear_netcdf_nospeed_gauss (SPPanel * spp,
						   gint m, gint n,
						   Simulation * sim,
						   HeightCurve hz,
						   gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m + n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.Pm = pressure.Pl = pressure.Ph = 0.;
  pressure.Pfk = pressure.Pr = pressure.phi2 = 0.;

  Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);


  // Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  Vector gradphi0;
  gradphi0.x = gradphi0.y = gradphi0.z = 0.;

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble Phi2n = 0., Phi2 = 0., dPhi2du = 0., dPhi2dv = 0., eta = 0.;
  Vector gradPhi2;
 
  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc =
	g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

      dPhi2du += v7*cv*cdu;
      dPhi2dv += v7*cu*cdv;
      Phi2n += sc->v[8]*cuv;
      Phi2 += v7*cuv;
      eta += sc->v[31]*cuv;
      gradphi0.x += sc->v[32]*cuv;
      gradphi0.y += sc->v[33]*cuv;
    }
  }
   
  gdouble dtphi0 = -sim->g*eta;

  gradPhi2.x = Phi2n*N.x + c1*dPhi2du + c2*dPhi2dv;
  gradPhi2.y = Phi2n*N.y + c3*dPhi2du + c4*dPhi2dv;
  gradPhi2.z = Phi2n*N.z + c5*dPhi2du + c6*dPhi2dv;

  /* Hydrostatic pressure */

  // Takes FS deformation into account for hydrostatic forces
  //  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  // Does not take FS deformation into account for hydrostatic forces
  /* pressure.Ph = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data)); */
  pressure.Ph = -sim->rho*sim->g *( p_inertial.z - eta);
  // Which one should be used ??

  /* Froude-Krylov forces */
  pressure.Pfk = -sim->rho*(dtphi0 + vector_scalar_product (&gradphi0, &gradphi0));
  //pressure.Pfk = -sim->rho*dtphi0;

  /* Time local /radiation forces */
  pressure.Pl = -sim->rho*vector_scalar_product (&gradphi0, &gradPhi2);

  /* Phi2 */
  pressure.phi2 = -sim->rho*Phi2;

  return pressure;
}

static void sppanel_linear_netcdf_nospeed_forces_integral_gauss (SPPanel * spp,
							  Simulation * sim,
							  gpointer data,
							  gint m, gint n,
							  HeightCurve hz,
							  gdouble t,
							  gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_netcdf_nospeed_gauss (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph;
  gdouble wfk = wij*lp.Pfk;
  gdouble wl = wij*lp.Pl;
  gdouble wphi2 = wij*lp.phi2;

  f->forces_h[0] += wh*N.x;
  f->forces_h[1] += wh*N.y;
  f->forces_h[2] += wh*N.z;
  
  f->forces_fk[0] += wfk*N.x;
  f->forces_fk[1] += wfk*N.y;
  f->forces_fk[2] += wfk*N.z;

  f->forces_l[0] += wl*N.x;
  f->forces_l[1] += wl*N.y;
  f->forces_l[2] += wl*N.z;

  f->phi2[0] += wphi2*N.x;
  f->phi2[1] += wphi2*N.y;
  f->phi2[2] += wphi2*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h[3] += wh*x.x;
  f->forces_h[4] += wh*x.y;
  f->forces_h[5] += wh*x.z;

  f->forces_fk[3] += wfk*x.x;
  f->forces_fk[4] += wfk*x.y;
  f->forces_fk[5] += wfk*x.z;

  f->forces_l[3] += wl*x.x;
  f->forces_l[4] += wl*x.y;
  f->forces_l[5] += wl*x.z;

  f->phi2[3] += wphi2*x.x;
  f->phi2[4] += wphi2*x.y;
  f->phi2[5] += wphi2*x.z;
}


/* static void local_netcdf_nospeed_forces_contribution (Spline2D * sp, */
/* 						      Simulation * sim, */
/* 						      gpointer data, */
/* 						      gdouble u, gdouble v, */
/* 						      gdouble weight,  */
/* 						      HeightCurve hz, */
/* 						      gdouble t, */
/* 						      gpointer hz_data) */
/* { */
/*   Forces * f = (Forces *) data; */

/*   // Time local forces and Pl are not defined on the whole of the hull and will remain 0 */
/*   gdouble Ph = 0., Pfk = 0., Pl = 0., phi2 = 0.; */
/*   gint k = sp->k; */

/*   Vector xu, xv; */
/*   xu.x = xu.y = xu.z = 0.; */
/*   xv.x = xv.y = xv.z = 0.; */
/*   Point p; */
/*   p.x = p.y = p.z = 0.; */
/*   gdouble dtphi0 = 0., elevation = 0.; */

/*   gint  i, j; */
/*   size_t istart, iend, jstart, jend, istart_x; */
/*   gsl_matrix * Bv = gsl_matrix_alloc (k, 2); */
/*   gsl_matrix * Bux = gsl_matrix_alloc (k, 2); */

/*   gsl_bspline_deriv_eval_nonzero (v, 1, Bv, &jstart, &jend, sp->w_v, sp->wd_v); */
/*   gsl_bspline_deriv_eval_nonzero (u, 1, Bux, &istart_x, &iend, sp->wx_u, sp->wxd_u); */


/*   for ( i = 0; i < k; i++) { */
/*     gdouble cux = gsl_matrix_get (Bux, i, 0); */
/*     gdouble cdux = gsl_matrix_get (Bux, i, 1); */
/*     gint iix = istart_x; */
/*     for ( j = 0; j < k; j++) { */
/*       gint jj = (jstart+j); */
/*       gdouble cv = gsl_matrix_get (Bv, j, 0); */
/*       gdouble cdv = gsl_matrix_get (Bv, j, 1); */

/*       gdouble cudvx = cux*cdv; */
/*       gdouble cvdux = cv*cdux; */
/*       gdouble cuvx = cux*cv; */

/*       gdouble v0 = coeff (sp,iix,jj,0); */
/*       gdouble v1 = coeff (sp,iix,jj,1); */
/*       gdouble v2 = coeff (sp,iix,jj,2); */

/*       xu.x += v0*cvdux; */
/*       xu.y += v1*cvdux; */
/*       xu.z += v2*cvdux; */
/*       xv.x += v0*cudvx; */
/*       xv.y += v1*cudvx; */
/*       xv.z += v2*cudvx; */

/*       p.x += v0*cuvx; */
/*       p.y += v1*cuvx; */
/*       p.z += v2*cuvx; */

/*       dtphi0 += coeff (sp,iix,jj,30)*cuvx; */
/*       elevation += coeff (sp,iix,jj,31)*cuvx; */
/*     } */
/*     istart_x++; */
/*   } */

/*  // Position in inertial reference frame */
/*  Point p_inertial = hull_transformed_point (sim->hull, p); */
 
/*  /\* gsl_matrix_free (Bu); *\/ */
/*  gsl_matrix_free (Bv); */
/*  gsl_matrix_free (Bux); */

/*  /\* Normal to the surface *\/ */
/*  Vector N = vector_vector_product (&xu, &xv); */
/*  gdouble J = vector_norm (N); */
/*  N.x /= J; N.y /= J; N.z /= J; */



/*  /\* Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t); *\/ */
  
/*  gdouble dt = sim->time.dt; */

/*  /\* gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p_inertial, t); *\/ */




/*  /\* Hydrostatic pressure *\/ */
/*  /\* Ph = -sim->rho*sim->g*(p_inertial.z-hz(p_inertial.x, p_inertial.y, t, hz_data)); *\/ */
/*  Ph = -sim->rho*sim->g*(p_inertial.z-elevation); */
/*  /\* Ph = 1.; *\/ */
/*  J *= weight; */

/*  /\* Froude Krylov-Forces *\/ */
/*  Pfk = -sim->rho*dtphi0; */






/*  gdouble wh = J*lp.Ph; */
/*  gdouble wfk = J*lp.Pfk; */
/*  gdouble wl = J*lp.Pl; */
/*  gdouble wphi2 = J*lp.phi2; */




/*  /\* Forces *\/ */
/*  /\* forces_add_contribution_forces (f, &N, 0., 0., Ph*J, Pfk*J, 0.); *\/ */

/*  gdouble wh = J*Ph; */
/*  gdouble wfk = J*Pfk; */

/*  *(f + 0) += wh*N.x; */
/*  *(f + 1) += wh*N.y; */
/*  *(f + 2) += wh*N.z; */
/*  *(f + 3) += wfk*N.x; */
/*  *(f + 4) += wfk*N.y; */
/*  *(f + 5) += wfk*N.z; */
    
/*  /\* Moments *\/ */
/*  Vector x; */
/*  Point xg = sim->hull->xg; */
/*  x.x = p.x-xg.x; x.y = p.y-xg.y; x.z = p.z-xg.z; */
/*  x = vector_vector_product (&x, &N); */

/*  *(f + 6) += wh*x.x; */
/*  *(f + 7) += wh*x.y; */
/*  *(f + 8) += wh*x.z; */
/*  *(f + 9) += wfk*x.x; */
/*  *(f + 10) += wfk*x.y; */
/*  *(f + 11) += wfk*x.z; */

/* } */



void spline2d_print_panels_gnuplot_tmp (Spline2D * sp, FILE * fp, gint var, gint var2, gint var3)
{
  g_assert (fp != NULL);

  gdouble u, v;
  gdouble du = 0.00999999999;

  for ( u = 0; u+du < 1.; u+=du) {
    for ( v = 0; v+du < 1.; v+=du) {
      Point p = spline2d_eval_point (sp, u, v);
      fprintf(fp, "%f %f %f %f %f %f\n", p.x, p.y, p.z,
	      spline2d_eval (sp, u, v, var),
	      spline2d_eval (sp, u, v, var2),
	      spline2d_eval (sp, u, v, var3));
      p = spline2d_eval_point (sp, u+du, v);
      fprintf(fp, "%f %f %f %f %f %f \n\n", p.x, p.y, p.z,
	      spline2d_eval (sp, u+du, v, var),
	      spline2d_eval (sp, u+du, v, var2),
	      spline2d_eval (sp, u+du, v, var3));
      
      p = spline2d_eval_point (sp, u, v+du);
      fprintf(fp, "%f %f %f %f %f %f \n", p.x, p.y, p.z,
	      spline2d_eval (sp, u, v+du, var),
	      spline2d_eval (sp, u, v+du, var2),
	      spline2d_eval (sp, u, v+du, var3));
      p = spline2d_eval_point (sp, u+du, v+du);
      fprintf(fp, "%f %f %f %f %f %f \n\n\n", p.x, p.y, p.z,
	      spline2d_eval (sp, u+du, v+du, var),
	      spline2d_eval (sp, u+du, v+du, var2),
	      spline2d_eval (sp, u+du, v+du, var3));
    }
  }

}

/* static gdouble ggrid_x (SPPanel * spp, gint m, gint n, gpointer data) */
/* { */
/*   gdouble u = g_array_index (spp->outer->ui, gdouble, m); */
/*   gdouble v = g_array_index (spp->outer->vj, gdouble, n); */

/*   return /\* 500 *\/400*(u-0.5); */
/* } */

/* static gdouble ggrid_y (SPPanel * spp, gint m, gint n, gpointer data) */
/* { */
/*   gdouble u = g_array_index (spp->outer->ui, gdouble, m); */
/*   gdouble v = g_array_index (spp->outer->vj, gdouble, n); */

/*   return 400*(v-0.5); */
/* } */

void add_full_netcdf_fk_fh_forces (Simulation * sim,
				   Forces * f, gdouble t,
				   gdouble u[6], gdouble x[6],
				   gboolean prediction)
{
  Hull * hull = sim->hull;
  NetCDFForcing * ncdf = sim->ncdf;
  Point xg = sim->hull->xg;
  gdouble rho = sim->rho;
  
  g_assert (ncdf != NULL);
  
  ncdf->time = t;
    
  // Find time position
  gint it = MAX(1, ncdf->it-1);
  gdouble t1 = 0.;
  // Get time ?
  while ( it < ncdf->nt && *(ncdf->t+it-1) < t )
    it++;
    
  if ( *(ncdf->t+it-1) >= t && it > 1)
    it--;

  t1 = *(ncdf->t + it -1);


  // READ DATA IF REQUIRED
  if (ncdf->phi_1 == NULL) { // No data has ever been loaded
    ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);      
    ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
    ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);      
    ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);

    ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);      
    ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
  }
  else if (ncdf->phi_1->it != it) {
    if (ncdf->phi_2->it == it) { // Can keep half of the data and move them
      NetCDFData * tmp = ncdf->phi_1;
      tmp = ncdf->elevation_1;
      ncdf->elevation_1 = ncdf->elevation_2;
      ncdf->elevation_2 = tmp;
      tmp = ncdf->u_1;
      ncdf->u_1 = ncdf->u_2;
      ncdf->u_2 = tmp;
      tmp = ncdf->v_1;
      ncdf->v_1 = ncdf->v_2;
      ncdf->v_2 = tmp;
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
    else { // Need to read two slices
      //ncdf->phi_1 = netcdf_load_array (ncdf, ncdf->phi_1, "phi", it);
      ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);
      ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);
      ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);

      //ncdf->phi_2 = netcdf_load_array (ncdf, ncdf->phi_2, "phi", it+1);
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
  }
  g_assert (ncdf->elevation_2->it == it+1);
  g_assert (ncdf->elevation_2 != NULL);

  // Put the interpolated dt phi and elevation on the hull
  GSList * patches = /* hull->patches */hull->wet_patches;
  while ( patches ) {
    Spline2D * sp = patches->data;

    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sp, ncdf, sim->hull, sim->force_coeff);

    if (sp->fit == NULL)
      sp->fit = sp->build_fit_matrix (sp);
    
    ccs_problem_lu_solve (sp->fit, rhs->rhs_elevation);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_u);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_v);

    sp->copy_fit_solution (sp, rhs->rhs_elevation, 31);
    sp->copy_fit_solution (sp, rhs->rhs_u, 32);
    sp->copy_fit_solution (sp, rhs->rhs_v, 33);

    gsl_vector_free (rhs->rhs_elevation);
    gsl_vector_free (rhs->rhs_u);
    gsl_vector_free (rhs->rhs_v);
    g_free (rhs);

    patches = patches->next;
  }

#if 0
  //*** Check print ***//
  if (sim->time.itime%1000 == 0) {
    FILE * fp = fopen (g_strdup_printf ("nc_%5.4f.tmp", sim->time.t),"w");

    patches = /* hull->patches */hull->wet_patches;
    while (patches) {
      Spline2D * sptmp = patches->data;
      spline2d_print_panels_gnuplot_tmp (sptmp, fp, 31, 32, 33);
      patches = patches->next;
    }

    fclose (fp);
  }

  if (sim->time.itime%1000 == 0) {
    /* Spline2D * grid = parametric_grid (60, 60, ggrid_x, ggrid_y, NULL); */

    /* if (grid->fit == NULL) */
    /*   grid->fit = grid->build_fit_matrix (grid); */

    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sim->tmp, ncdf, sim->hull, sim->force_coeff);

    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_elevation);
    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_u);
    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_v);
  
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_elevation, 31);
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_u, 32);
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_v, 33);
  
    gsl_vector_free (rhs->rhs_elevation);
    gsl_vector_free (rhs->rhs_u);
    gsl_vector_free (rhs->rhs_v);

    g_free (rhs);

    FILE * fp = fopen (g_strdup_printf ("ncgrid_%5.4f.tmp", sim->time.t),"w");
    spline2d_print_panels_gnuplot_tmp (sim->tmp, fp, 31, 32, 33);
    fclose (fp);
    
    //spline2d_destroy (grid);
  }
#endif

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_netcdf_boundary_problem_for_disturbance_flow_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_netcdf_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  /* static void whole_hull_integration (Hull * hull, Simulation * sim, gpointer int_data, */
  /* 				    LocalGaussIntegrationFunc local_gauss_integration_func, */
  /* 				    HeightCurve hz, gdouble t, */
  /* 				    gpointer hz_data) */

  /* wet_hull_integration (sim->hull, sim, &ff[0], */
  /* 			local_fh_fk_uv_forces_contribution, */
  /* 			sppanel_fh_fk_uv_forces_integral_gauss, */
  /* 			pressure_force_integration_tolerance, */
  /* 			corner_point_new_uv, */
  /* 			uv_elevation, t, &sim->wp); */

  /* wet_hull_integration (hull, sim, forces, */
  /* 			local_pressure_forces_contribution, */
  /* 			sppanel_pressure_force_integral_gauss, */
  /* 			pressure_force_integration_tolerance, */
  /* 			corner_point_new, */
  /* 			hz, t, hz_data); */


  /* wet_hull_integration (sim->hull, sim, f, */
  /* 				  LocalIntegrationFunc local_integration_func, */
  /* 				  sppanel_linear_netcdf_nospeed_forces_integral_gauss, */
  /* 				  pressure_force_integration_tolerance, */
  /* 				  corner_point_new_uv, */
  /* 				  uv_elevation, t, */
  /* 				  &sim->wp) */

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      /* f->forces_m[j]  = 1./(6.*dt)*(11.*f->phi2[j] - 18.*phi2[3][j] + 9.*phi2[2][j] - 2.*phi2[1][j]); */
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }

    // fprintf (stdout, "phi2 %f %f %f %f %f %f\n", t, f->phi2[5], phi2[3][5], phi2[2][5], phi2[1][5], phi2[0][5]);

  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
    	f->forces_m[i] += sim->hull->A[i][j]*a[j];
	/* f->forces_m[i] = phi2[3][i]; */
      }
    }
  }

  // f->forces_h[0] = f->forces_fk[0] = f->forces_e [0] = 0.;
}

void add_full_netcdf_fk_fh_forces_implicit (Simulation * sim,
					    Forces * f, gdouble t,
					    gdouble u[6], gdouble x[6])
{
  Hull * hull = sim->hull;
  NetCDFForcing * ncdf = sim->ncdf;
  Point xg = sim->hull->xg;
  gdouble rho = sim->rho;
  
  g_assert (ncdf != NULL);
  
  ncdf->time = t;
    
  // Find time position
  gint it = MAX(1, ncdf->it-1);
  gdouble t1 = 0.;
  // Get time ?
  while ( it < ncdf->nt && *(ncdf->t+it-1) < t )
    it++;
    
  if ( *(ncdf->t+it-1) >= t && it > 1)
    it--;

  t1 = *(ncdf->t + it -1);


  // READ DATA IF REQUIRED
  if (ncdf->phi_1 == NULL) { // No data has ever been loaded
    ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);      
    ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
    ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);      
    ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);

    ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);      
    ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
  }
  else if (ncdf->phi_1->it != it) {
    if (ncdf->phi_2->it == it) { // Can keep half of the data and move them
      NetCDFData * tmp = ncdf->phi_1;
      tmp = ncdf->elevation_1;
      ncdf->elevation_1 = ncdf->elevation_2;
      ncdf->elevation_2 = tmp;
      tmp = ncdf->u_1;
      ncdf->u_1 = ncdf->u_2;
      ncdf->u_2 = tmp;
      tmp = ncdf->v_1;
      ncdf->v_1 = ncdf->v_2;
      ncdf->v_2 = tmp;
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
    else { // Need to read two slices
      //ncdf->phi_1 = netcdf_load_array (ncdf, ncdf->phi_1, "phi", it);
      ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);
      ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);
      ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);

      //ncdf->phi_2 = netcdf_load_array (ncdf, ncdf->phi_2, "phi", it+1);
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
  }
  g_assert (ncdf->elevation_2->it == it+1);
  g_assert (ncdf->elevation_2 != NULL);

  // Put the interpolated dt phi and elevation on the hull
  GSList * patches = hull->patches;
  while ( patches ) {
    Spline2D * sp = patches->data;

    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sp, ncdf, sim->hull, sim->force_coeff);

    if (sp->fit == NULL)
      sp->fit = sp->build_fit_matrix (sp);
    
    ccs_problem_lu_solve (sp->fit, rhs->rhs_elevation);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_u);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_v);

    sp->copy_fit_solution (sp, rhs->rhs_elevation, 31);
    sp->copy_fit_solution (sp, rhs->rhs_u, 32);
    sp->copy_fit_solution (sp, rhs->rhs_v, 33);

    gsl_vector_free (rhs->rhs_elevation);
    gsl_vector_free (rhs->rhs_u);
    gsl_vector_free (rhs->rhs_v);
    g_free (rhs);

    patches = patches->next;
  }

#if 0
  //*** Check print ***//
  if (sim->time.itime%1000 == 0) {
    FILE * fp = fopen (g_strdup_printf ("nc_%5.4f.tmp", sim->time.t),"w");

    patches = hull->patches;
    while (patches) {
      Spline2D * sptmp = patches->data;
      spline2d_print_panels_gnuplot_tmp (sptmp, fp, 31, 32, 33);
      patches = patches->next;
    }

    fclose (fp);
  }

  if (sim->time.itime%1000 == 0) {
    /* Spline2D * grid = parametric_grid (60, 60, ggrid_x, ggrid_y, NULL); */

    /* if (grid->fit == NULL) */
    /*   grid->fit = grid->build_fit_matrix (grid); */

    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sim->tmp, ncdf, sim->hull, sim->force_coeff);

    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_elevation);
    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_u);
    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_v);
  
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_elevation, 31);
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_u, 32);
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_v, 33);
  
    gsl_vector_free (rhs->rhs_elevation);
    gsl_vector_free (rhs->rhs_u);
    gsl_vector_free (rhs->rhs_v);

    g_free (rhs);

    FILE * fp = fopen (g_strdup_printf ("ncgrid_%5.4f.tmp", sim->time.t),"w");
    spline2d_print_panels_gnuplot_tmp (sim->tmp, fp, 31, 32, 33);
    fclose (fp);
    
    //spline2d_destroy (grid);
  }
#endif

  solve_boundary_problem_for_disturbance_flow_nospeed_kim (sim);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_netcdf_nospeed_forces_integral_gauss,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi2[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi2[i][j] = forces->phi2[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_m[j]  = 1./(12.*dt)*(25.*f->phi2[j] - 48.*phi2[3][j] + 36.*phi2[2][j] - 16.*phi2[1][j] + 3.*phi2[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_m[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

}

/**************************************/
static gdouble test_func (gdouble u, gdouble v)
{
  return sin(u*u+v*v);
}

static gdouble transformed_test_func (gdouble uu, gdouble vv)
{
  gdouble u0, u1, v0, v1, up, vp, um, vm;

  u0 = -1.2;
  u1 = -0.8;
  v0 = 0.25;
  v1 = 0.37;
  up = - 1.1;
  vp = 0.3;
  gdouble u, v, J;

  if ( uu < 0 && vv < 0 ) {
    u = u0 + (up-u0)*(1.+uu);
    v = v0 + (vp-v0)*(1.+vv);
    J = (up-u0)*(vp-v0);
  }

  if ( uu > 0 && vv < 0 ) {
    u = up + (u1-up)*uu;
    v = v0 + (vp-v0)*(1.+vv);
    J = (u1-up)*(vp-v0);
  }
      
  if ( uu < 0 && vv > 0) {
    u = u0 + (up-u0)*(1.+uu);
    v = vp + (v1-vp)*vv;
    J = (up-u0)*(v1-vp);
  }

  if ( uu > 0 && vv > 0 ) {
    u = up + (u1-up)*uu;
    v = vp + (v1-vp)*vv;
    J = (u1-up)*(v1-vp);
  }

  return test_func (u,v)*J*sqrt(uu*uu+vv*vv);
}

/* static void integration_qcheb (double a, double b, double *cheb12, double *cheb24) */
/* { */
/*   size_t i; */
/*   double fval[25], v[12]; */

/*   /\* These are the values of cos(pi*k/24) for k=1..11 needed for the */
/*      Chebyshev expansion of f(x) *\/ */
  
/*   const double x[11] = { 0.9914448613738104,      */
/*                          0.9659258262890683, */
/*                          0.9238795325112868,      */
/*                          0.8660254037844386, */
/*                          0.7933533402912352,      */
/*                          0.7071067811865475, */
/*                          0.6087614290087206,      */
/*                          0.5000000000000000, */
/*                          0.3826834323650898,      */
/*                          0.2588190451025208, */
/*                          0.1305261922200516 }; */
  
/*   const double center = 0.5 * (b + a); */
/*   const double half_length =  0.5 * (b - a); */
  
/*   fval[0] = 0.5 * GSL_FN_EVAL (f, b); */
/*   fval[12] = GSL_FN_EVAL (f, center); */
/*   fval[24] = 0.5 * GSL_FN_EVAL (f, a); */

/*   for (i = 1; i < 12; i++) */
/*     { */
/*       const size_t j = 24 - i; */
/*       const double u = half_length * x[i-1]; */
/*       fval[i] = GSL_FN_EVAL(f, center + u); */
/*       fval[j] = GSL_FN_EVAL(f, center - u); */
/*     } */

/*   for (i = 0; i < 12; i++) */
/*     { */
/*       const size_t j = 24 - i; */
/*       v[i] = fval[i] - fval[j]; */
/*       fval[i] = fval[i] + fval[j]; */
/*     } */

/*   { */
/*     const double alam1 = v[0] - v[8]; */
/*     const double alam2 = x[5] * (v[2] - v[6] - v[10]); */

/*     cheb12[3] = alam1 + alam2; */
/*     cheb12[9] = alam1 - alam2; */
/*   } */

/*   { */
/*     const double alam1 = v[1] - v[7] - v[9]; */
/*     const double alam2 = v[3] - v[5] - v[11]; */
/*     { */
/*       const double alam = x[2] * alam1 + x[8] * alam2; */

/*       cheb24[3] = cheb12[3] + alam; */
/*       cheb24[21] = cheb12[3] - alam; */
/*     } */

/*     { */
/*       const double alam = x[8] * alam1 - x[2] * alam2; */
/*       cheb24[9] = cheb12[9] + alam; */
/*       cheb24[15] = cheb12[9] - alam; */
/*     } */
/*   } */

/*   { */
/*     const double part1 = x[3] * v[4]; */
/*     const double part2 = x[7] * v[8]; */
/*     const double part3 = x[5] * v[6]; */
    
/*     { */
/*       const double alam1 = v[0] + part1 + part2; */
/*       const double alam2 = x[1] * v[2] + part3 + x[9] * v[10]; */
      
/*       cheb12[1] = alam1 + alam2; */
/*       cheb12[11] = alam1 - alam2; */
/*     } */
    
/*     { */
/*       const double alam1 = v[0] - part1 + part2; */
/*       const double alam2 = x[9] * v[2] - part3 + x[1] * v[10]; */
/*       cheb12[5] = alam1 + alam2; */
/*       cheb12[7] = alam1 - alam2; */
/*     } */
/*   } */

/*   { */
/*     const double alam = (x[0] * v[1] + x[2] * v[3] + x[4] * v[5] */
/*                 + x[6] * v[7] + x[8] * v[9] + x[10] * v[11]); */
/*     cheb24[1] = cheb12[1] + alam; */
/*     cheb24[23] = cheb12[1] - alam; */
/*   } */

/*   { */
/*     const double alam = (x[10] * v[1] - x[8] * v[3] + x[6] * v[5]  */
/*                 - x[4] * v[7] + x[2] * v[9] - x[0] * v[11]); */
/*     cheb24[11] = cheb12[11] + alam; */
/*     cheb24[13] = cheb12[11] - alam; */
/*   } */

/*   { */
/*     const double alam = (x[4] * v[1] - x[8] * v[3] - x[0] * v[5]  */
/*                 - x[10] * v[7] + x[2] * v[9] + x[6] * v[11]); */
/*     cheb24[5] = cheb12[5] + alam; */
/*     cheb24[19] = cheb12[5] - alam; */
/*   } */

/*   { */
/*     const double alam = (x[6] * v[1] - x[2] * v[3] - x[10] * v[5]  */
/*                 + x[0] * v[7] - x[8] * v[9] - x[4] * v[11]); */
/*     cheb24[7] = cheb12[7] + alam; */
/*     cheb24[17] = cheb12[7] - alam; */
/*   } */

/*   for (i = 0; i < 6; i++) */
/*     { */
/*       const size_t j = 12 - i; */
/*       v[i] = fval[i] - fval[j]; */
/*       fval[i] = fval[i] + fval[j]; */
/*     } */

/*   { */
/*     const double alam1 = v[0] + x[7] * v[4]; */
/*     const double alam2 = x[3] * v[2]; */

/*     cheb12[2] = alam1 + alam2; */
/*     cheb12[10] = alam1 - alam2; */
/*   } */

/*   cheb12[6] = v[0] - v[4]; */

/*   { */
/*     const double alam = x[1] * v[1] + x[5] * v[3] + x[9] * v[5]; */
/*     cheb24[2] = cheb12[2] + alam; */
/*     cheb24[22] = cheb12[2] - alam; */
/*   } */

/*   { */
/*     const double alam = x[5] * (v[1] - v[3] - v[5]); */
/*     cheb24[6] = cheb12[6] + alam; */
/*     cheb24[18] = cheb12[6] - alam; */
/*   } */

/*   { */
/*     const double alam = x[9] * v[1] - x[5] * v[3] + x[1] * v[5]; */
/*     cheb24[10] = cheb12[10] + alam; */
/*     cheb24[14] = cheb12[10] - alam; */
/*   } */

/*   for (i = 0; i < 3; i++) */
/*     { */
/*       const size_t j = 6 - i; */
/*       v[i] = fval[i] - fval[j]; */
/*       fval[i] = fval[i] + fval[j]; */
/*     } */

/*   cheb12[4] = v[0] + x[7] * v[2]; */
/*   cheb12[8] = fval[0] - x[7] * fval[2]; */

/*   { */
/*     const double alam = x[3] * v[1]; */
/*     cheb24[4] = cheb12[4] + alam; */
/*     cheb24[20] = cheb12[4] - alam; */
/*   } */

/*   { */
/*     const double alam = x[7] * fval[1] - fval[3]; */
/*     cheb24[8] = cheb12[8] + alam; */
/*     cheb24[16] = cheb12[8] - alam; */
/*   } */

/*   cheb12[0] = fval[0] + fval[2]; */

/*   { */
/*     const double alam = fval[1] + fval[3]; */
/*     cheb24[0] = cheb12[0] + alam; */
/*     cheb24[24] = cheb12[0] - alam; */
/*   } */

/*   cheb12[12] = v[0] - v[2]; */
/*   cheb24[12] = cheb12[12]; */

/*   for (i = 1; i < 12; i++) */
/*     { */
/*       cheb12[i] *= 1.0 / 6.0; */
/*     } */

/*   cheb12[0] *= 1.0 / 12.0; */
/*   cheb12[12] *= 1.0 / 12.0; */

/*   for (i = 1; i < 24; i++) */
/*     { */
/*       cheb24[i] *= 1.0 / 12.0; */
/*     } */

/*   cheb24[0] *= 1.0 / 24.0; */
/*   cheb24[24] *= 1.0 / 24.0; */
/* } */

static void test_wamit ()
{
  gint ng =  2000, i, j;
  gsl_integration_glfixed_table * itable =  gsl_integration_glfixed_table_alloc (ng);
  gsl_integration_glfixed_table * jtable =  gsl_integration_glfixed_table_alloc (ng);
  gdouble ui, wi, vj, wj;

  gdouble u0, u1, v0, v1, up, vp, um, vm;

  u0 = -1.2;
  u1 = -0.8;
  v0 = 0.25;
  v1 = 0.37;
  up = - 1.1;
  vp = 0.3;
  um = (u0+u1)/2.;
  vm = (v0+v1)/2.;


  gdouble sum1 = 0., sum2 = 0.;;

  gdouble A = 0.881373587019543; // asinh (1)

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (-1., 1, i, &ui, &wi, itable);

    for ( j = 0; j < ng; j++) {
      gsl_integration_glfixed_point (-1, 1., j, &vj, &wj, jtable);

      gdouble uu = u0 + (ui+1.)/2.*(u1-u0);
      gdouble vv = v0 + (vj+1.)/2.*(v1-v0);

      sum1 += wi*wj*test_func (uu,vv)*(u1-u0)/2.*(v1-v0)/2.;

    }
  }

  
  sum2 = 0.;
   
 /* for ( i = 0; i < ng; i++) { */
 /*    gsl_integration_glfixed_point (-1., 1, i, &ui, &wi, itable); */

 /*    for ( j = 0; j < ng; j++) { */
 /*      gsl_integration_glfixed_point (-1, 1., j, &vj, &wj, jtable); */

      

 /*      sum2 += wi*wj*transformed_test_func (ui, vj)/sqrt(ui*ui+vj*vj); */

 /*    } */
 /*  } */

 
  /* for ( i = 0; i < ng; i++) { */
  /*   gsl_integration_glfixed_point (0, 1, i, &ui, &wi, itable); */

  /*   for ( j = 0; j < ng; j++) { */
  /*     gsl_integration_glfixed_point (-ui, ui, j, &vj, &wj, jtable); */

  /*     sum2 += wi*wj*transformed_test_func (ui, vj)/sqrt(ui*ui+vj*vj); */
  /*     sum2 += wi*wj*transformed_test_func (-ui, vj)/sqrt(ui*ui+vj*vj); */
  /*     sum2 += wi*wj*transformed_test_func (vj, ui)/sqrt(ui*ui+vj*vj); */
  /*     sum2 += wi*wj*transformed_test_func (vj, -ui)/sqrt(ui*ui+vj*vj); */
      
  /*   } */
  /* } */
 

  /* for ( i = 0; i < ng; i++) { */
  /*   gsl_integration_glfixed_point (0, 1, i, &ui, &wi, itable); */

  /*   for ( j = 0; j < ng; j++) { */
  /*     gsl_integration_glfixed_point (-1, 1, j, &vj, &wj, jtable); */
      
  /*     sum2 += wi*wj*transformed_test_func (ui, ui*vj)/sqrt(1.+vj*vj); */
  /*     sum2 += wi*wj*transformed_test_func (-ui, ui*vj)/sqrt(1.+vj*vj); */
  /*     sum2 += wi*wj*transformed_test_func (ui*vj, ui)/sqrt(1.+vj*vj); */
  /*     sum2 += wi*wj*transformed_test_func (ui*vj, -ui)/sqrt(1.+vj*vj); */


  /*   } */
  /* } */

  /* for ( i = 0; i < ng; i++) { */
  /*   gsl_integration_glfixed_point (-1, 1, i, &ui, &wi, itable); */

  /*   for ( j = 0; j < ng; j++) { */
  /*     gsl_integration_glfixed_point (-1, 1, j, &vj, &wj, jtable); */
      
  /*     sum2 += wi*wj*transformed_test_func (ui, ui*vj)/sqrt(1.+vj*vj); */
  /*     sum2 += wi*wj*transformed_test_func (ui*vj, ui)/sqrt(1.+vj*vj); */
  /*   } */
  /* } */

  for ( i = 0; i < ng; i++) {
    gsl_integration_glfixed_point (-1, 1, i, &ui, &wi, itable);

    for ( j = 0; j < ng; j++) {
      gsl_integration_glfixed_point (-1, 1, j, &vj, &wj, jtable);
      
      sum2 += A*wi*wj*(transformed_test_func (ui, ui*sinh(A*vj)) + transformed_test_func (ui*sinh(A*vj), ui));

    }
  }


  // Clenshaw-Curtis

  


  //g_assert_not_reached ();

  fprintf (stderr, "%e %e \n", sum1, sum2);

  
  gsl_integration_glfixed_table_free (itable);
  gsl_integration_glfixed_table_free (jtable);
}

static Forces forces (gdouble t, gdouble t0, gdouble dt, gdouble v, gdouble x)
{
  Forces f;

  gdouble xi = 2;
  gdouble omega = M_PI;


  /* Test for harmonic oscillator */
  /* Type of formula we will be using */
  f.fv = -2.*xi*v - x + (t0+dt-t)/dt*cos(omega*t0) + (t-t0)/dt*cos(omega*(t0+dt));
  f.fx = v;

  /* Standard analytical */
  /* f.fv = -2.*xi*v - x + cos(omega*t); */
  /* f.fx = v; */

  return f;
}

void initialise_motion (Simulation * sim)
{
  Hull * h = sim->hull;

  gint i, j;
  for ( i = 0; i < 6; i++) {
    h->m.x[i] = h->m.v[i] = h->m.u[i] = 0.;
  }

  h->m.t.x = h->m.x[0];
  h->m.t.y = h->m.x[1];
  h->m.t.z = h->m.x[2];

  update_rotation_matrix (&h->m, h->m.x, h->m.u);

  //Build the mass matrix
  for ( i = 0; i < 3; i++) {
    for ( j = 0; j < 3; j++) {
      h->M[i][j] = 0.;
      h->M[i+3][j] = h->M[i][j+3] = 0.;
      h->M[i+3][j+3] = h->Ig[i][j];
    }
  }

  for ( i = 0; i < 3; i++)
    h->M[i][i] = h->mg;


  

  /* // Add added mass matrix */
  /* for ( i = 0; i < 6; i++) { */
  /*   for ( j = 0; j < 6; j++) { */
  /*     h->M[i][j] += h->A[i][j]; */
  /*   } */
  /* } */

  // Fix added mass matrix for symmetry
  for ( i = 0; i < 6; i++)
    for ( j = 0; j < 6; j++)
      if ( (i+j)%2 == 0)
  	h->M[i][j] += (h->A[i][j]+h->A[j][i])/2.;

  /* for ( i = 0; i < 6; i++) */
  /*   h->M[i][i] += h->A[i][i] /\* = 1. *\/; */

  

  // Allocates memory to store Forces History required by ABM4
  h->fh = g_malloc (sizeof(ForcesHistory));

  // Creates an "empty vector" and add forces to history
  h->fh->f = NULL; // List initially empty
  for ( i = 0; i < 4; i++) {
    Forces * f0 = g_malloc (sizeof(Forces));
    forces_set_to_zero (f0);
    h->fh->f = g_slist_append (h->fh->f, f0);
  }
}

static Vector6 spp_mode_added_mass (SPPanel * spp, gint m, gint n, gpointer data)
{
  Vector6 val;
  Point * xg = (Point *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);

  // We calculate the matrix at the center of gravity
  P.x -= xg->x; P.y -= xg->y; P.z -= xg->z;

  val.x[0] = N.x*spline2d_eval_gauss_point (spp->sp, gp, m, n, 12);
  val.x[1] = N.y*spline2d_eval_gauss_point (spp->sp, gp, m, n, 12);
  val.x[2] = N.z*spline2d_eval_gauss_point (spp->sp, gp, m, n, 12);

  val.x[3] = (P.y*N.z-P.z*N.y)*spline2d_eval_gauss_point (spp->sp, gp, m, n, 12);
  val.x[4] = (P.z*N.x-P.x*N.z)*spline2d_eval_gauss_point (spp->sp, gp, m, n, 12);
  val.x[5] = (P.x*N.y-P.y*N.x)*spline2d_eval_gauss_point (spp->sp, gp, m, n, 12);

  return val;
}

void store_mode_added_mass (Hull * hull, gint mode, Point * xg)
{
  GSList * patches = hull->wet_patches;
  Vector6 val;
  gint ii, m, n;
  
  vector6_set_to_zero (&val);

  while (patches) {
    Spline2D * patch = patches->data;

    while (patch) {
      for (ii = 0; ii < patch->panels->len; ii++) {
	SPPanel * panel = g_ptr_array_index (patch->panels, ii);
	GaussPoints * gp = panel->outer;
	gint ng = gp->ui->len;

	for ( m = 0; m < ng; m++) {	  
	  for ( n = 0; n < ng; n++) {

	    val = vector6_sum (val, vector6_times_constant (spp_mode_added_mass (panel, m, n, xg), g_array_index (gp->wJij, gdouble, m+n*ng)));

	  } 
	}

      }
      patch = patch->next;
    }

    patches = patches->next;
  }

  for ( m = 0; m < 6; m++)
    hull->A[mode][m] = val.x[m];
}

void print_tmp (Hull * hull)
{
  Spline2D * sp = hull->patches->data;
  gint ii, m, n;
  FILE * fp = fopen ("velocity.tmp","w");
  
  for ( ii = 0; ii < sp->panels->len; ii++) {
    SPPanel * spp = g_ptr_array_index (sp->panels, ii);
    GaussPoints * gp = spp->outer;
    gint ng = sp->nouter;

    for ( m = 0; m < ng; m++) {
      for ( n = 0; n < ng; n++) {
	Point P = g_array_index (gp->Pi, Point, m+n*ng);
	Vector v = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 12);
	/* fprintf (fp, "%f %f %f \n %f %f %f \n\n\n", */
	/* 	 P.x, P.y, P.z, P.x+(v.x/\* -P.y *\/)/5., P.y+(v.y/\* +P.x *\/)/5., P.z+(v.z)/5.); */
	fprintf (fp, "%f %f %f \n %f %f %f \n\n\n",
		 P.x, P.y, P.z, P.x+(v.x/* +P.z */)/5., P.y+(v.y)/5., P.z+(v.z/* -P.x */)/5.);
      }
    }
  }

  fclose (fp);
}

void calculate_added_mass_matrix (Simulation * sim, Point xg)
{
  // Start timer
  g_test_timer_start ();
  Hull * hull = sim->hull;

  // We use temporary variables 12 and 13

  // Apply Phi = 0 on the free-surface (stored in variable 12)
  GSList * patches = sim->fs->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, zero_potential, NULL, 12);
    patches = patches->next;
  }

  // Apply Phi = 0 on the bathymetry (stored in variable 12)
  patches = sim->bathy->s->patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, zero_potential, NULL, 12);
    patches = patches->next;
  }
#if 1
  gint i, j;
  for ( i = 0; i < 6; i++) {
    GaussFunc mode_func;

    // Choose the mode forcing function
    switch (i) {
    case 0:
      mode_func = mode_forcing_1; break;
    case 1:
      mode_func = mode_forcing_2; break;
    case 2:
      mode_func = mode_forcing_3; break;
    case 3:
      mode_func = mode_forcing_4; break;
    case 4:
      mode_func = mode_forcing_5; break;
    case 5:
      mode_func = mode_forcing_6; break;
    default : g_assert_not_reached ();
    }

    // Apply neumann condition corresponding to the mode on the hull (stored in variable 13)
    patches = sim->hull->wet_patches;
    while (patches) {
      apply_dirichlet_conditions (patches->data, mode_func, &xg, 13);
      patches = patches->next;
    }

    // Get all patches of the simulation
    patches = simulation_all_patches_list (sim);
  
    // Build the rhs corresponding to the mixed problem for each subproblem
    // using the Dirichlet condition stored in variable 12 or
    // the Neumann condition stored in variable 13
    simulation_build_mixed_sub_problems_rhs (sim, 12, 13);

    // Assemble the total mixed boundary problem rhs
    boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

    // Solve the Neumann problem using the LU method
    sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

    // Copies the solution back to the patches
    cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							  sim, 12, 13);

    // Calculate added mass coefficients
    store_mode_added_mass (sim->hull, i, &xg);
  }

  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ )
      sim->hull->A[i][j] *= sim->rho;
#endif
  // Stops the timer
  fprintf (stderr, "   Calculate added mass coefficients : %f \n", g_test_timer_elapsed());
}

static gdouble grid_x (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return /* 500 */450*(u-0.5);
}

static gdouble grid_y (SPPanel * spp, gint m, gint n, gpointer data)
{
  gdouble u = g_array_index (spp->outer->ui, gdouble, m);
  gdouble v = g_array_index (spp->outer->vj, gdouble, n);

  return 400*(v-0.5);
}

void nc_test2 (Simulation * sim)
{


  // Initialising of simulation
  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  3600.;
  sim->time.iend = 40000;
  sim->time.dt = /* 0.005 */0.01;
  // Recommanded 0.005
  // Possibly of 0.01

  // Wave properties
  sim->wp.g = 9.81;
  sim->wp.A = 0.15; // 15 cm wave
  sim->wp.w = 2.*M_PI/60.; // = 2pi/period
  sim->wp.h = 2.5;
  sim->wp.k = solve_dispersion_relation (&sim->wp); // 2pi/wavelength
  fprintf (stderr, " k is %e \n", sim->wp.k );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // For monochronatic finite-depth forcing
  /* sim->wp.wave_potential = finite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = finite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = finite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative; */
  /* sim->wp.wave_normal_time_derivative = finite_depth_wave_normal_time_derivative; */

  sim->wp.wave_potential = zero_scalar_wave_func;
  //sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  //sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  sim->wp.r1 = 10.;
  sim->wp.r2 = 10.;

  g_test_timer_start ();
  /* NetCDFForcing * ncdf =  netcdf_forcing_new ("phi_2.nc"); */
  gdouble t;
  sim->ncdf = netcdf_forcing_new ("phi_real_test.nc", 1689540.7934, 5676464.0678, 21.128*M_PI/180.);
  NetCDFForcing * ncdf = sim->ncdf;

  fprintf (stderr, "netcdf_forcing_new %f \n", g_test_timer_elapsed());

  FILE * fin = fopen("1704deck-flat-mesh-12.2.GDF","r");
  hull_read (sim->hull, fin, 25, 15, TRUE, FALSE, TRUE, FALSE);
  fclose (fin);
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));
  spline2d_translate (sim->hull->patches->data, -86., -16.-2., 0.);
  spline2d_translate (sim->hull->patches->next->data , -86., -16.-2., 0.);

  /* sim->hull->patches = g_slist_append (sim->hull->patches, */
  /* 				       parametric_grid (60, 60, grid_x, grid_y, NULL)); */


  GSList * patches = sim->hull->patches;
  while (patches) {
    Spline2D * sp = patches->data;
    if (sp->fit == NULL)
      sp->fit = sp->build_fit_matrix (sp);
    patches = patches->next;
  }

  initialise_motion (sim);
  Forces ff;
  forces_set_to_zero (&ff);
  
  gint iter = 0;
  for ( t = 0.63; t < 3000.52; t += 1.0) {

    add_netcdf_fk_fh_forces (sim, &ff, t, sim->hull->m.u, sim->hull->m.x);

    gdouble u, v;

    for ( u = 0.; u <1.; u += 0.01) {
      for ( v = 0.; v <1.; v += 0.01) {
    	gdouble var = spline2d_eval (sim->hull->patches->data, u, v, 31);

    	if (fabs (var) > 1.) {
    	   FILE *ffp = fopen ("nc.tmp","w");

    	   patches = sim->hull->patches;
    	   while (patches) {
    	     Spline2D * sp = patches->data;
	     
    	     spline2d_print_panels_gnuplot (sp, ffp, 31);
	     
    	     patches = patches->next;
    	   }
    	   fclose (ffp);
    	   fprintf (stderr, "Beserck at %f \n", t);
    	   g_assert_not_reached ();
    	}
      }
    }



    /* FILE *ffp = fopen ("nc.tmp","w"); */

    /* patches = sim->hull->patches; */
    /* while (patches) { */
    /*   Spline2D * sp = patches->data; */
      
    /*   spline2d_print_panels_gnuplot (sp, ffp, 31); */
    
    /*   patches = patches->next; */
    /* } */
    /* fclose (ffp); */
    
    iter++;
    if (iter % 100 == 0)
      fprintf (stderr, "Time: %f iter: %i \n", t, iter);
  }

  FILE * fp = fopen ("grid.tmp","w");

  /* spline2d_print_panels (grid, fp); */
  patches = sim->hull->patches;
  while (patches) {
    Spline2D * sp = patches->data;
    
    spline2d_print_panels (sp, fp);

    patches = patches->next;
  }

  fclose (fp);
  
  fp = fopen ("nc.tmp","w");

  patches = sim->hull->patches;
  while (patches) {
    Spline2D * sp = patches->data;
    
    spline2d_print_panels_gnuplot (sp, fp, 31);

    patches = patches->next;
  }

  // spline2d_print_panels_gnuplot (grid, fp, 30);
  fclose (fp);

  patches = sim->hull->patches;
  while (patches) {
    Spline2D * sp = patches->data;
    
    spline2d_destroy (sp);

    patches = patches->next;
  }

  /* spline2d_destroy (grid); */

  netcdf_forcing_destroy (ncdf);

  g_assert_not_reached ();
}

static void test_half_sphere (Simulation * sim)
{
  sim->N = 40;
  sim->M = 40;

  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005/sqrt(sim->g*L);

  sim->wp.g = 9.81;
  sim->wp.A = 0.015;
  sim->wp.w = 1.5*sqrt(0.5*9.81);
  sim->wp.h = 2.5;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  //sim->wp.k = M_PI;
  fprintf (stderr, " k is %e \n", sim->wp.k );
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);
  
  // For monochronatic finite-depth forcing
  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;
  sim->wp.wave_normal_time_derivative = finite_depth_wave_normal_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  sim->self_influence_function = lachat_watson_self_influence_coefficients;
  sim->continuity = TRUE;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_circle;;
  sim->wp.Cs = 60.; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_no_speed_elevation_update;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update_periodic;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 10.;

  GSList * patches = NULL;
  FILE * fp;

  // Initial estimate of position of centre of gravity of hull
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;


  //sim->hull->patches = g_slist_append (sim->hull->patches, periodic_spheroid_surface (10, 25));

  //sim->hull->patches = g_slist_append (sim->hull->patches, parametric_grid (10, 25, sphere_xp, sphere_yp, NULL));

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 100, sphere_xp, sphere_yp, sphere_zp, NULL, 3, 4, 3));

  /* // Read half of the hull */
  /* fp = fopen("1704deck-flat-mesh-12.2.GDF","r"); */
  /* hull_read (sim->hull, fp, 25, 15, TRUE, FALSE, TRUE, FALSE); */
  /* fclose (fp); */

  /* // Creates the other half */
  /* sim->hull->patches = g_slist_append (sim->hull->patches, */
  /* 				       spline2d_symmetrical_y (sim->hull->patches->data, 0)); */

  /* // Translate hull at right position */
  /* spline2d_translate  (sim->hull->patches->data, -86., -16.-2., 0.); */
  /* spline2d_translate  (sim->hull->patches->next->data , -86., -16.-2., 0.); */

  // Print hull
  fp = fopen ("hull.out","w");
  hull_print (sim->hull, fp);
  fclose (fp);
  fprintf (stderr, "Hull printed\n");

  // Print normals
  fp = fopen ("normals.tmp","w");
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // generating the wet hull
  calculate_mass_from_position_at_rest (sim->hull, sim);

  update_rotation_matrix (&sim->hull->m, sim->hull->m.x,
			  sim->hull->m.u);

  // Finds position of centre of buoyancy
  Point cob = find_center_of_buoyancy (sim->hull, sim, flat_sea, sim->time.t, NULL);

  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = cob.z;

   // WET HULL
  //hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  sim->hull->wet_patches = sim->hull->patches; 
  fprintf (stderr, "Wet hull \n");


  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  build_free_surface (sim, 3, 4, 3);
  fprintf (stderr, "Built free surface \n");

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (sim->fs->s, fp);
  fclose (fp);

  fp = fopen ("grid-normals.tmp","w");
  spline2d_print_normals (sim->fs->s->patches->data, fp);
  fclose (fp);

  fprintf (stderr, "Hydrostatic restoring coeffs \n");
  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  fprintf (stderr, "Fit matrixes \n");
  simulation_build_galerkin_fit_matrixes (sim);

  /* g_test_timer_start (); */
  fprintf (stderr, "Problems \n");
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  sim->U.x = 1.;
  solve_boundary_problem_for_basis_flow (sim);
  sim->U.x = 0.;

  calculate_added_mass_matrix (sim, sim->hull->xg);

  print_free_surface_potential (sim->fs->s->patches, &sim->wp, sim->time.t);

  print_hull_potential (sim->hull->patches, &sim->wp, sim->time.t);

  hull_print_gnuplot (sim->hull, NULL, 3, 0.);

  sim->hull->Ig[0][0] = 2./5.*sim->hull->mg*0.5*0.5;
  sim->hull->Ig[1][1] = 2./5.*sim->hull->mg*0.5*0.5;
  sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*0.5*0.5;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  

  // Initial position of center of gravity, initial velocities
  initialise_motion (sim);
}

/*****************************************************/
/*                 CLEAN FORMULATION                 */
/*****************************************************/

gdouble hull_no_speed_disturbance_bc_1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Hull * hull = sim->hull;
  Motion m1 = hull->m;

  //Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector n0 = g_array_index (gp->Ni, Vector, m + n*ng);
  //  Vector n1 = hull_normal_1 (hull, &n0);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);
  Vector gradphi0 = sim->wp.wave_potential_gradient (&sim->wp, P, sim->time.t);

  Vector x;
  Point xg = sim->hull->xg;
  x.x = P.x-xg.x; x.y = P.y-xg.y; x.z = P.z-xg.z;
  //x = vector_vector_product (&x, &Ni);

  gdouble N[6];
  N[0] = n0.x;
  N[1] = n0.y;
  N[2] = n0.z;
  N[3] = x.y*n0.z - x.z*n0.y;
  N[4] = x.z*n0.x - x.x*n0.z;
  N[5] = x.x*n0.y - x.y*n0.x;

  gint i;

  // bc = sum xi_t * n + xi * m
  gdouble val = 0.;
  for ( i = 0; i < 6; i++)
    val += m1.u1[i]*N[i]; // Might be u ??

  return val-vector_scalar_product (&gradphi0, &n0);
}

void solve_boundary_problem_for_disturbance_flow_1 (Simulation * sim)
{
  // Start timer
  if (sim->verbose)
    g_test_timer_start ();

  // Apply phin = d delta/dt.N on the hull (stored in variable 8)
  GSList * patches = sim->hull->wet_patches;
  while (patches) {
    apply_dirichlet_conditions (patches->data, hull_no_speed_disturbance_bc_1, sim, 8);
    patches = patches->next;
  }

  // No need to apply the dirichlet conditions on the free surface as this
  // was done when applying the free-surface conditions and is already stored in
  // variable 7

  // Apply phin = 0 on the bathymetry (stored in variable 8)
  patches = sim->bathy->s->patches;
  while (patches) {
    coeff_set_var_to_zero (patches->data, 8);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichlet condition stored in variable 7 or
  // the Neumann condition stored in variable 8
  simulation_build_mixed_sub_problems_rhs (sim, 7, 8);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_mixed_continuity_conditions_rhs (sim, sim->mixed_problem, 7, 8);

  // Solve the Neumann problem using the LU method 
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 7, 8);

  // Stops the timer
  if (sim->verbose)
    fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}

Forces forces_evaluation (Hull * hull,
			  gdouble t,
			  Time * time,
			  Motion m,
			  Simulation * sim,
			  GSList * forces,
			  gboolean prediction)
{
  Forces f;
  gint i, j;

  forces_set_to_zero (&f);
  
  motion_update_rotation_matrix_1 (&hull->m, m.x1);
  motion_update_rotation_matrix_2 (&hull->m, m.x1, m.x2);

  gdouble t0 = sim->time.t;
  Motion m0 = sim->hull->m;
  sim->hull->m = m;
  sim->time.t = t; // Allows potential evaluation at right time
  // Estimate forces
  while (forces) {
    ForceFunc1 forces_func = forces->data;
    forces_func (sim, &f, t, m, prediction);
    forces = forces->next;
  }
  sim->time.t = t0;
  sim->hull->m = m0;

  motion_update_rotation_matrix_1 (&hull->m, hull->m.x1);
  motion_update_rotation_matrix_2 (&hull->m, hull->m.x1,
				   hull->m.x2);

  return f;
}

Motion motion_RK4_time_integration_1  (Hull * hull,
				       Time * time,
				       Simulation * sim,
				       GSList * forces)
{
  Motion m0 = hull->m, m1;

  gdouble k1du1[6], k2du1[6], k3du1[6], k4du1[6];
  gdouble k1dx1[6], k2dx1[6], k3dx1[6], k4dx1[6];

  /* gdouble k1du2[6], k2du2[6], k3du2[6], k4du2[6]; */
  /* gdouble k1dx2[6], k2dx2[6], k3dx2[6], k4dx2[6]; */
  
  Forces f1;
  gdouble t = time->t;
  gdouble dt = time->dt;
  gint i, j;

  gsl_vector * du = gsl_vector_alloc (6);

  Forces * f0 = g_slist_last (hull->fh->f)->data;

  if (hull->mass_lu1 == NULL) {
    gsl_matrix * M = gsl_matrix_alloc (6,6);
    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++)
	gsl_matrix_set (M, i, j, /* hull->M1[j][i] */hull->M1[i][j]);
    hull->mass_lu1 = sim->lu_factorise (M);
  }

  /* if (hull->mass_lu2 == NULL) { */
  /*   gsl_matrix * M = gsl_matrix_alloc (6,6); */
  /*   for ( i = 0; i < 6; i++ ) */
  /*     for ( j = 0; j < 6; j++) */
  /* 	gsl_matrix_set (M, i, j, hull->M2[j][i]); */
  /*   hull->mass_lu2 = sim->lu_factorise (M); */
  /* } */

  if (sim->time.itime < 1)
    *f0 = forces_evaluation (hull, t, time, m0, sim, forces, FALSE);

  gdouble k1du5[6];
  // k1 = dt*f(t0, y0)
  for ( i = 0; i < 6; i++) {
    k1du1[i] = dt*(f0->forces_1[i] + f0->forces_ext1[i]
		   + f0->forces_h1[i] + f0->forces_fk1[i] + f0->forces_v1[i]);
    k1dx1[i] = dt*m0.u1[i];
  }
  
  // k2 = dt*f(t0+dt/2, y0+k1/2.)
  for ( i = 0; i < 6; i++)
    gsl_vector_set (du, i, 0.5*k1du1[i]);

  sim->lu_factorised_solve (hull->mass_lu1, du);

  for ( i = 0; i < 6; i++) {
    m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i);
    m1.x1[i] = m0.x1[i] + 0.5*k1dx1[i];
  }

  motion_update_rotation_matrix_1 (&m1, m1.x1);
  f1 = forces_evaluation (hull, t+0.5*time->dt, time, m1, sim, forces, TRUE);

  for ( i = 0; i < 6; i++) {
    k2du1[i] = dt*(f1.forces_1[i] +f1.forces_ext1[i]
		  + f1.forces_h1[i] + f1.forces_fk1[i] + f1.forces_v1[i]);
    k2dx1[i] = dt*m1.u1[i];
  }
  
  // k3 = dt*f(t0+dt/2, y0+k2/2)
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (du, i, 0.5*k2du1[i]);

  sim->lu_factorised_solve (hull->mass_lu1, du);

  for ( i = 0; i < 6; i++) {
    m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i);
    m1.x1[i] = m0.x1[i] + 0.5*k2dx1[i];
  }

  motion_update_rotation_matrix_1 (&m1, m1.x1);
  f1 = forces_evaluation (hull, t+0.5*dt, time, m1, sim, forces, FALSE);

  for ( i = 0; i < 6; i++) {
    k3du1[i] = dt*(f1.forces_1[i] +f1.forces_ext1[i]
		   + f1.forces_h1[i] + f1.forces_fk1[i] + f1.forces_v1[i]);
    k3dx1[i] = dt*m1.u1[i];
  }


  // k4 = dt*f(t0+dt, y0+k3)
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (du, i, k3du1[i]);

  sim->lu_factorised_solve (hull->mass_lu1, du);

  for ( i = 0; i < 6; i++) {
    m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i);
    m1.x1[i] = m0.x1[i] + k3dx1[i];
  }
  
  motion_update_rotation_matrix_1 (&m1, m1.x1);
  f1 = forces_evaluation (hull, t+time->dt, time,
			    m1, sim, forces, FALSE);

  for ( i = 0; i < 6; i++) {
    k4du1[i] = dt*(f1.forces_1[i] + f1.forces_ext1[i]
		   + f1.forces_h1[i] + f1.forces_fk1[i] + f1.forces_v1[i]);
    k4dx1[i] = dt*m1.u1[i];
  }

  // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6
  for ( i = 0; i < 6; i++ )
    gsl_vector_set (du, i, (k1du1[i] + 2.*k2du1[i] + 2.*k3du1[i] + k4du1[i])/6.);

  sim->lu_factorised_solve (hull->mass_lu1, du);

  for ( i = 0; i < 6; i++) {
    m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i);
    m1.x1[i] = m0.x1[i] + (k1dx1[i] + 2.*k2dx1[i] + 2.*k3dx1[i] + k4dx1[i])/6.;
  }

  gsl_vector_free (du);

  motion_update_rotation_matrix_1 (&hull->m, m1.x1);
  //motion_update_rotation_matrix_2 (&hull->m, m.x1, m.x2);

  // Forces that are stored
  motion_update_rotation_matrix_1 (&m1, m1.x1);
  f1 = forces_evaluation (hull, t+time->dt, time,
			   m1, sim, forces, FALSE);

  for ( i = 0; i < 6; i++ ) {
    f1.x1[i] = m1.x1[i];
    f1.u1[i] = m1.u1[i];
  }
  
  add_force_to_history (hull->fh, f1);

  return m1;
}

Motion motion_ABM4_time_integration_1 (Hull * hull,
				       Time * time,
				       Simulation * sim,
				       GSList * forces)
{
  gint i = 0, j;
  gdouble t = time->t;
  gdouble dt = time->dt;
  Forces f[4];

  Motion m0 = hull->m;

  gdouble k1du1[6], k2du1[6], k3du1[6], k4du1[6];
  gdouble k1dx1[6], k2dx1[6], k3dx1[6], k4dx1[6];

  /* gdouble k1du2[6], k2du2[6], k3du2[6], k4du2[6]; */
  /* gdouble k1dx2[6], k2dx2[6], k3dx2[6], k4dx2[6]; */

  // Store relevant force history
  GSList * fl = hull->fh->f;
  while (fl) {
    f[i] = *(Forces *) fl->data;
    fl = fl->next;
    i++;
  }

  Motion m1 = m0;
  gsl_vector * du = gsl_vector_alloc (6);

  /* Prediction */
  for ( i = 0; i < 6; i++) {
    gsl_vector_set (du, i,
		    dt/24.*( -9.*(f[0].forces_1[i] + f[0].forces_ext1[i]
				  + f[0].forces_h1[i] + f[0].forces_fk1[i]
				  + f[0].forces_v1[i])
			     + 37.*(f[1].forces_1[i] + f[1].forces_ext1[i]
				    + f[1].forces_h1[i] + f[1].forces_fk1[i]
				    + f[1].forces_v1[i])
			     - 59.*(f[2].forces_1[i] + f[2].forces_ext1[i]
				    + f[2].forces_h1[i] + f[2].forces_fk1[i]
				    + f[2].forces_v1[i])
			     + 55.*(f[3].forces_1[i] + f[3].forces_ext1[i]
				    + f[3].forces_h1[i] + f[3].forces_fk1[i]
				    + f[3].forces_v1[i])));
  }

  sim->lu_factorised_solve (hull->mass_lu1, du);

  for ( i = 0; i < 6; i++) {
    m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i);
    m1.x1[i] = m0.x1[i] + dt/24.*( -9.*f[0].u1[i] + 37.*f[1].u1[i]
		       - 59.*f[2].u1[i] + 55.*f[3].u1[i] );
  }

  /* Correction */
  motion_update_rotation_matrix_1 (&m1, m1.x1);
  Forces f4 = forces_evaluation (hull, t+time->dt, time,
				 m1, sim, forces, TRUE);

  for ( i = 0; i < 6; i++) {
    gsl_vector_set (du, i,
		    dt/24.*( (f[1].forces_1[i] + f[1].forces_ext1[i]
			      + f[1].forces_h1[i] + f[1].forces_fk1[i]
			      + f[1].forces_v1[i])
			     - 5.*(f[2].forces_1[i] + f[2].forces_ext1[i]
				   + f[2].forces_h1[i] + f[2].forces_fk1[i]
				   + f[2].forces_v1[i])
			     + 19.*(f[3].forces_1[i] + f[3].forces_ext1[i]
				    + f[3].forces_h1[i] + f[3].forces_fk1[i]
				    + f[3].forces_v1[i])
			     + 9.*(f4.forces_1[i] + f4.forces_ext1[i]
				   + f4.forces_h1[i] + f4.forces_fk1[i]
				   + f4.forces_v1[i])));
  }

  sim->lu_factorised_solve (hull->mass_lu1, du);

  for ( i = 0; i < 6; i++) {
    m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i);
    m1.x1[i] = m0.x1[i] + dt/24.*( f[1].u1[i] - 5.*f[2].u1[i]
		       + 19.*f[3].u1[i] + 9.*m1.u1[i]);
  }

  gsl_vector_free (du);

  //motion_update_rotation_matrix_2 (&hull->m, m.x1, m.x2);

  // Forces that are stored
  motion_update_rotation_matrix_1 (&m1, m1.x1);
  f4 = forces_evaluation (hull, t+time->dt, time,
			   m1, sim, forces, FALSE);

  for ( i = 0; i < 6; i++ ) {
    f4.x1[i] = m1.x1[i];
    f4.u1[i] = m1.u1[i];
  }
  
  add_force_to_history (hull->fh, f4);

  return m1;
}

void solve_equation_of_motion_1 (Hull * hull,
				 Time * time,
				 Simulation * sim,
				 GSList * forces)
{
  // Initialise with 3 steps of RK4
  g_assert (hull->fh);

  if (time->itime < 5)
    hull->m = motion_RK4_time_integration_1 (hull, time,
					     sim, forces);
  else
    hull->m = motion_ABM4_time_integration_1 (hull, time, sim, forces);
}

static void add_external_forces_torsion2 (Simulation * sim, Forces * f,
					  gdouble t, Motion m,
					  gboolean prediction)
{
  gdouble period = 4.5;

  f->forces_ext1 [0] = 0.;
  f->forces_ext1 [1] = 0.;
  f->forces_ext1 [2] = 0.;
  f->forces_ext1 [3] = 0.;
  f->forces_ext1 [4] = 0.;
  f->forces_ext1 [5] = -M_PI*M_PI/4.*cos(sqrt(M_PI/5.)*(t));
}

static void add_fake_fk (Simulation * sim,
			 Forces * f,
			 gdouble t,
			 Motion m,
			 gboolean prediction)
{
  gdouble period = /* 2*M_PI/sim->wp.w */4.5;

  f->forces_fk1[0] = 685.289*cos(2.*M_PI/period*t); 
  f->forces_fk1[1] = 0.; 
  f->forces_fk1[2] = 0.;
  f->forces_fk1[3] = 0.;
  gint np = 5.;
  if (t < np*2.*M_PI/sim->wp.w)
    f->forces_fk1[4] = sin (0.25*t/(np/sim->wp.w))*685.289*cos(sim->wp.w*t);
  else
    f->forces_fk1[4] = 685.289*cos(sim->wp.w*t);
  f->forces_fk1[5] = 0.;
}

static void test_torsion_2 (Simulation * sim)
{
  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e8;
  sim->time.dt = 0.01;

  // Mass
  sim->hull->mg = 10;

  // MAtrix of inertia
  sim->hull->Ig[0][0] = 3.;
  sim->hull->Ig[1][1] = 3.;
  sim->hull->Ig[2][2] = 5.;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;

  hull_initialise_motion (sim->hull);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fspeed = fopen ("speed.tmp","w");

  sim->hull->m.u1[5] = 0.; // Initial spin
  sim->hull->m.x1[5] = M_PI/4.;

  motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);

  // Set forces
  GSList * forces = NULL;
  forces = g_slist_append (forces, add_external_forces_torsion2);

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    if ( sim->time.itime%20 == 0 )
      fprintf (stderr, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    solve_equation_of_motion_1 (sim->hull, &sim->time, sim, forces);
    
    // Print motion
    // Analytical solution : x[5] = pi/4.*cos(sqrt(pi/5.)*x)
    fprintf (fmotion, "%f %f %f %f %f %f %f\n",
    	     sim->time.t+sim->time.dt,
    	     sim->hull->m.x1[0],
    	     sim->hull->m.x1[1],
    	     sim->hull->m.x1[2],
    	     fmod (sim->hull->m.x1[3], 2*M_PI),
    	     fmod (sim->hull->m.x1[4], 2*M_PI),
    	     fmod (sim->hull->m.x1[5], 2*M_PI));

    // Print velocity
    // Analytical solutio :  u[5] = -pi/4.*sqrt(pi/5.)*sin(sqrt(pi/5.)*x)
    fprintf (fspeed, "%f %f %f %f %f %f %f\n",
	     sim->time.t+sim->time.dt,
	     sim->hull->m.u1[0],
	     sim->hull->m.u1[1],
	     sim->hull->m.u1[2],
	     sim->hull->m.u1[3],
	     sim->hull->m.u1[4],
	     sim->hull->m.u1[5]);

    // Update time
    sim->time.itime++;
    sim->time.t += sim->time.dt;
  }

  fclose (fmotion);
  fclose (fspeed);
}

void calculate_nemoh_radiation_matrix (Simulation * sim, gchar * f_a_name, gchar * f_b_name)
{
  int i, j, k, l;
  double aa, bb;
  float aatmp, bbtmp;
  float we;

  // g_assert ( fam != NULL );

  double dt = /* 5* */ sim->time.dt;

  GArray * wes = g_array_new (FALSE, FALSE, sizeof(float));
  GPtrArray * A = g_ptr_array_new ();
  GPtrArray * B = g_ptr_array_new ();

  double AA0[6][6];
  double BB0[6][6];

  FILE * f_a = fopen (f_a_name,"r");
  FILE * f_b = fopen (f_b_name,"r");

  int ndir;

  g_assert ( fscanf (f_a, "%i\n", &ndir) != EOF );
  g_assert ( fscanf (f_b, "%i\n", &ndir) != EOF );

  

  // Read from PDSTrip complex added mass outputs
  /* FILE * fadd = fopen("potential_damping.tmp","w"); */
  while (fscanf (f_a, "%f ",&we) != EOF && fscanf (f_b, "%f ",&we) != EOF ) {
    g_array_append_val (wes, we);
    fprintf (stdout, "%f \n", we);
    gsl_matrix * atmp = gsl_matrix_alloc (6,6);
    gsl_matrix * btmp = gsl_matrix_alloc (6,6);
    /* fprintf (fadd, "%f ", we); */
    for ( i  = 0; i < 6; i++ ) {
      for ( j  = 0; j < 6; j++ ) {
	g_assert ( fscanf (f_a, "%lf ", &aa) != EOF );
	g_assert ( fscanf (f_b, "%lf ", &bb) != EOF );


	/* fprintf (stderr, "%lf %lf\n", aa, bb); */
	
	AA0[i][j] = aa;
	BB0[i][j] = bb;
	/* if ( i == j ) */
	/*   fprintf (fadd, "%f ", BB0[i][j]); */
      }
    }
    //g_assert_not_reached ();
    //fprintf (fadd, "\n");

    // Enforce symmetry
    for ( i = 0; i < 6; i++ ) {
      for ( j  = 0; j < 6; j++ ) {
    	gsl_matrix_set (atmp, i, j, /* 0.5*( */AA0[i][j]/* +AA0[j][i]) */);
    	gsl_matrix_set (btmp, i, j, /* 0.5*( */BB0[i][j]/* +BB0[j][i]) */);
      }
    }
    
    g_ptr_array_add (A, atmp);
    g_ptr_array_add (B, btmp);
  }
  /* fclose (fadd); */


  /********** Bij(t) = 2/pi int_{0}^{om} bij(w) cos(wt) dt *************/

  float dw[wes->len-1];
  double db[i][j][wes->len-1];
  double B0[6][6], gamma[6][6];
  
  // Calculate B0, gamma, dw, db
  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ )
      B0[i][j] = gamma[i][j] = 0.;

  for ( k = 0; k < wes->len-1; k++ ) {
    gsl_matrix * btmp0 = g_ptr_array_index (B, k);
    gsl_matrix * btmp1 = g_ptr_array_index (B, k+1);
    float w0 = g_array_index (wes, float, k);
    float w1 = g_array_index (wes, float, k+1);

    dw[k] = w1-w0;
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	db[i][j][k] = (gsl_matrix_get (btmp1, i, j) - gsl_matrix_get (btmp0, i, j))/dw[k];

	B0[i][j] += (gsl_matrix_get (btmp1, i, j) + gsl_matrix_get (btmp0, i, j))*dw[k];
	gamma[i][j] += fabs(db[i][j][k]);
      }
    }

  }

  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ )
      B0[i][j] /= M_PI; // 2 and 0.5 from previous block of code cancel out
  

  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ ) {
      if ( B0[i][j] != 0. )
	gamma[i][j] = 2*sqrt(gamma[i][j]/(M_PI/* *dw[0] */*0.01*B0[i][j]));
      else
	gamma[i][j] = 0.;
    }

  // Take the largest of the gammas as the time integration limit for the retardation functions
  double gmax = 0;
  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ ) {
      fprintf (stdout, "%i %i %f %f \n", i, j, gamma[i][j], B0[i][j]);
      if ( gmax < gamma[i][j] )
	gmax = gamma[i][j];
    }

  gmax = 250;

  int nt = gmax/dt + 1; // Number of timesteps the retardation function are + 1
  sim->hull->nt = nt;
  fprintf (stderr, "NT: %i %f %f\n", nt, gmax, dt);
  
  sim->hull->RET = g_malloc0(36*nt*sizeof(double));

  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) {
      *(sim->hull->RET + i + j*6 + 0) = B0[i][j];
    }
  }

#if 0
  // Simple trapeze formula
  for ( l = 1; l < nt; l++) {
    gdouble tau = l*dt;

    for ( k = 0; k < wes->len-1; k++ ) {
      gsl_matrix * btmp0 = g_ptr_array_index (B, k);
      gsl_matrix * btmp1 = g_ptr_array_index (B, k+1);
      gdouble c1 = cos(g_array_index(wes, float, k+1)*tau);
      gdouble c0 = cos(g_array_index(wes, float, k)*tau);

      for ( i = 0; i < 6; i++ ) {
   	for ( j = 0; j < 6; j++ ) {
	  *(sim->hull->RET + i + j*6 + l*36) += c1*gsl_matrix_get (btmp1,i,j) + c0*gsl_matrix_get (btmp0, i, j);
	}
      }
    }

    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	*(sim->hull->RET + i + j*6 + l*36) *= dw[0]/M_PI;
      }
    }
  }

#else
  // From (Journee, 1993)
  for ( l = 1; l < nt; l++) {
    double tau = l*dt;
    for ( k = 0; k < wes->len-1; k++ ) {
      gdouble cc = ( cos(g_array_index(wes, float, k+1)*tau)
  		     - cos(g_array_index(wes, float, k)*tau) );
      for ( i = 0; i < 6; i++ ) {
  	for ( j = 0; j < 6; j++ ) {
  	  *(sim->hull->RET + i + j*6 + l*36) += db[i][j][k]*cc ;
  	}
      }
    }
  }

  gsl_matrix * btmp = g_ptr_array_index (B, B->len-1);
  for ( l = 1; l < nt; l++) {
    double tau = l*dt;
    gdouble c1 = 2/(M_PI*tau*tau);
    gdouble c2 = 2/(M_PI*tau)*sin(g_array_index (wes, float, wes->len-1)*tau);
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
  	*(sim->hull->RET + i + j*6 + l*36) *= c1;
  	*(sim->hull->RET + i + j*6 + l*36) += c2*gsl_matrix_get(btmp,i,j);
      }
    }
  }
#endif


  FILE * fout = fopen ("fcheck.tmp", "w");
  FILE * fout2 = fopen ("fcheck2.tmp", "w");
  
  for ( l = 0; l < nt; l++) {
    fprintf (fout, "%f %f %f %f %f %f %f\n", l*dt, *(sim->hull->RET + 0 + 0*6 + l*6*6), *(sim->hull->RET + 1 + 1*6 + l*6*6), *(sim->hull->RET + 2 + 2*6 + l*6*6), *(sim->hull->RET + 3 + 3*6 + l*6*6) , *(sim->hull->RET + 4 + 4*6 + l*6*6) , *(sim->hull->RET + 5 + 5*6 + l*6*6));
    fprintf (fout2, "%f %f %f %f %f %f %f %f %f\n", l*dt, *(sim->hull->RET + 1 + 3*6 + l*6*6), *(sim->hull->RET + 1 + 5*6 + l*6*6), *(sim->hull->RET + 2 + 4*6 + l*6*6), *(sim->hull->RET + 3 + 5*6 + l*6*6) , *(sim->hull->RET + 3 + 1*6 + l*6*6) , *(sim->hull->RET + 5 + 1*6 + l*6*6),*(sim->hull->RET + 4 + 2*6 + l*6*6) , *(sim->hull->RET + 5 + 3*6 + l*6*6));
  }
  fclose (fout);
  fclose (fout2);
  

#if 0
  // Simple trapeze formula
  FILE * fa = fopen ("acheck.tmp","w");
  for ( k = 0; k < wes->len; k+= 1 ) {

    gsl_matrix * atmp = g_ptr_array_index (A, k);
    float w0 = g_array_index (wes, float, k);

    /* gsl_matrix * atmp = g_ptr_array_index (A, 120); */
    /* float w0 = g_array_index (wes, float, 120); */
    
    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++ )
    	sim->hull->A[i][j] = 0;
    
    // Time integral part
    for ( l = 0; l < nt-1; l++) {
      gdouble s1 = sin(w0*(l+1)*dt);
      gdouble s0 = sin(w0*l*dt);
      for ( i = 0; i < 6; i++ ) {
    	for ( j = 0; j < 6; j++ ) {
    	  sim->hull->A[i][j] += *(sim->hull->RET + i + j*6 + (l+1)*36)*s1
    	    + *(sim->hull->RET + i + j*6 + l*36)*s0;
    	}
      }
    }

    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
    	sim->hull->A[i][j] *= 0.5*dt/w0;
    	sim->hull->A[i][j] += gsl_matrix_get (atmp, i, j);
      }
    }

    fprintf (fa, "%f %f %f %f %f %f %f\n", w0, sim->hull->A[3][1], sim->hull->A[1][1], sim->hull->A[2][2],
  	     sim->hull->A[3][3], sim->hull->A[4][4], sim->hull->A[5][5]);
  }
  fclose (fa);

#else
   // Journee's formula (p13)
  
  /* FILE * fa = fopen ("acheck.tmp","w"); */
  /* for ( k = 0; k < wes->len; k+= 1 ) { */
  /*   gsl_matrix * atmp = g_ptr_array_index (A, k); */
  /*   float w0 = g_array_index (wes, float, k); */

  gsl_matrix * atmp = g_ptr_array_index (A, 100); // was 200
  float w0 = g_array_index (wes, float, 100); // was 200

    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++ )
  	sim->hull->A[i][j] = 0;

    for  ( l = 0; l < nt-1; l++) {
      gdouble c1 = sin(w0*(l+1)*dt) - sin(w0*l*dt);

      for ( i = 0; i < 6; i++ ) {
  	for ( j = 0; j < 6; j++ ) {
  	  sim->hull->A[i][j] += c1*( *(sim->hull->RET + i + j*6 + (l+1)*36) - *(sim->hull->RET + i + j*6 + l*36) );
  	}
      }

    }

  
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
  	sim->hull->A[i][j] /= (w0*w0*dt);
  	sim->hull->A[i][j] += ( *(sim->hull->RET + i + j*6 ) - *(sim->hull->RET + i + j*6 + (nt-1)*36)*cos(w0*(nt-1)*dt) ) / w0;
      }
    }

    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
  	sim->hull->A[i][j] /= w0;
  	sim->hull->A[i][j] += gsl_matrix_get (atmp, i, j);
      }
    }

    /* fprintf (fa, "%f %f %f %f %f %f %f\n", w0, sim->hull->A[3][1], sim->hull->A[1][1], sim->hull->A[2][2], */
    /* 	     sim->hull->A[3][3], sim->hull->A[4][4], sim->hull->A[5][5]); */
    /* fprintf (fa, "%f %f %f %f %f %f %f\n", w0, sim->hull->A[0][4], sim->hull->A[1][3], sim->hull->A[1][5], */
    /* 	     sim->hull->A[2][4], sim->hull->A[3][5], sim->hull->A[5][5]); */
  /* } */
  /* fclose (fa); */
#endif


  g_ptr_array_free (A, TRUE);
  g_ptr_array_free (B, TRUE);
  g_array_free (wes, TRUE);
  //g_assert_not_reached ();

  FILE * fam_check = fopen ("added_mass.tmp", "w");
  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) {
      fprintf (fam_check, "%e ", sim->hull->A[i][j]);
    }
    fprintf (fam_check, "\n");
  }
  fclose (fam_check);

  fprintf (stdout, "Done\n");
  //g_assert_not_reached ();
}

void calculate_pdstrip_radiation_matrix (Simulation * sim, FILE * fam)
{
  int i, j, k, l;
  double aa, bb;
  float we;

  g_assert ( fam != NULL );

  double dt = /* 5* */sim->time.dt;

  GArray * wes = g_array_new (FALSE, FALSE, sizeof(float));
  GPtrArray * A = g_ptr_array_new ();
  GPtrArray * B = g_ptr_array_new ();

  double AA0[6][6];
  double BB0[6][6];

  // Read from PDSTrip complex added mass outputs
  FILE * fadd = fopen("potential_damping.tmp","w");
  while (fscanf (fam, "%f\n",&we) != EOF ) {
    g_array_append_val (wes, we);
    fprintf (stdout, "%f \n", we);
    gsl_matrix * atmp = gsl_matrix_alloc (6,6);
    gsl_matrix * btmp = gsl_matrix_alloc (6,6);
    fprintf (fadd, "%f ", we);
    for ( i  = 0; i < 6; i++ ) {
      for ( j  = 0; j < 6; j++ ) {
	fscanf (fam, "%lf %lf\n",&aa,&bb);
	/* gsl_matrix_set (atmp, i, j, aa/(we*we)); */
	/* gsl_matrix_set (btmp, i, j, -bb/we); */
	AA0[i][j] = aa/(we*we);
	BB0[i][j] = -bb/we;
	if ( i == j )
	  fprintf (fadd, "%f ", BB0[i][j]);
      }
    }
    
    fprintf (fadd, "\n");

    // Enforce symmetry
    for ( i = 0; i < 6; i++ ) {
      for ( j  = 0; j < 6; j++ ) {
	gsl_matrix_set (atmp, i, j, 0.5*(AA0[i][j]+AA0[j][i]));
	gsl_matrix_set (btmp, i, j, 0.5*(BB0[i][j]+BB0[j][i]));
      }
      //fprintf (stdout, "\n");
    }
    
    g_ptr_array_add (A, atmp);
    g_ptr_array_add (B, btmp);
  }
  fclose (fadd);

  /********** Bij(t) = 2/pi int_{0}^{om} bij(w) cos(wt) dt *************/

  float dw[wes->len-1];
  double db[i][j][wes->len-1];
  double B0[6][6], gamma[6][6];
  
  // Calculate B0, gamma, dw, db
  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ )
      B0[i][j] = gamma[i][j] = 0.;

  for ( k = 0; k < wes->len-1; k++ ) {
    gsl_matrix * btmp0 = g_ptr_array_index (B, k);
    gsl_matrix * btmp1 = g_ptr_array_index (B, k+1);
    float w0 = g_array_index (wes, float, k);
    float w1 = g_array_index (wes, float, k+1);

    dw[k] = w1-w0;
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	db[i][j][k] = (gsl_matrix_get (btmp1, i, j) - gsl_matrix_get (btmp0, i, j))/dw[k];

	B0[i][j] += (gsl_matrix_get (btmp1, i, j) + gsl_matrix_get (btmp0, i, j))*dw[k];
	gamma[i][j] += fabs(db[i][j][k]);
      }
    }

  }

  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ )
      B0[i][j] /= M_PI; // 2 and 0.5 from previous block of code cancel out
  

  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ ) {
      if ( B0[i][j] != 0. )
	gamma[i][j] = 2*sqrt(gamma[i][j]/(M_PI/* *dw[0] */*0.01*B0[i][j]));
      else
	gamma[i][j] = 0.;
    }

  // Take the largest of the gammas as the time integration limit for the retardation functions
  double gmax = 0;
  for ( i = 0; i < 6; i++ )
    for ( j = 0; j < 6; j++ ) {
      fprintf (stdout, "%i %i %f %f \n", i, j, gamma[i][j], B0[i][j]);
      if ( gmax < gamma[i][j] )
	gmax = gamma[i][j];
    }

  int nt = gmax/dt + 1; // Number of timesteps the retardation function are + 1
  sim->hull->nt = nt;
  fprintf (stderr, "NT: %i %f %f\n", nt, gmax, dt);
  sim->hull->RET = g_malloc0(36*nt*sizeof(double));

  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) {
      *(sim->hull->RET + i + j*6 + 0) = B0[i][j];
    }
  }

#if 0
  // Simple trapeze formula
  for ( l = 1; l < nt; l++) {
    gdouble tau = l*dt;

    for ( k = 0; k < wes->len-1; k++ ) {
      gsl_matrix * btmp0 = g_ptr_array_index (B, k);
      gsl_matrix * btmp1 = g_ptr_array_index (B, k+1);
      gdouble c1 = cos(g_array_index(wes, float, k+1)*tau);
      gdouble c0 = cos(g_array_index(wes, float, k)*tau);

      for ( i = 0; i < 6; i++ ) {
   	for ( j = 0; j < 6; j++ ) {
	  *(sim->hull->RET + i + j*6 + l*36) += c1*gsl_matrix_get (btmp1,i,j) + c0*gsl_matrix_get (btmp0, i, j);
	}
      }
    }

    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	*(sim->hull->RET + i + j*6 + l*36) *= dw[0]/M_PI;
      }
    }
  }

#else
  // From (Journee, 1993)
  for ( l = 1; l < nt; l++) {
    double tau = l*dt;
    for ( k = 0; k < wes->len-1; k++ ) {
      gdouble cc = ( cos(g_array_index(wes, float, k+1)*tau)
  		     - cos(g_array_index(wes, float, k)*tau) );
      for ( i = 0; i < 6; i++ ) {
  	for ( j = 0; j < 6; j++ ) {
  	  *(sim->hull->RET + i + j*6 + l*36) += db[i][j][k]*cc ;
  	}
      }
    }
  }

  gsl_matrix * btmp = g_ptr_array_index (B, B->len-1);
  for ( l = 1; l < nt; l++) {
    double tau = l*dt;
    gdouble c1 = 2/(M_PI*tau*tau);
    gdouble c2 = 2/(M_PI*tau)*sin(g_array_index (wes, float, wes->len-1)*tau);
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
  	*(sim->hull->RET + i + j*6 + l*36) *= c1;
  	*(sim->hull->RET + i + j*6 + l*36) += c2*gsl_matrix_get(btmp,i,j);
      }
    }
  }
#endif


  FILE * fout = fopen ("fcheck.tmp", "w");
  FILE * fout2 = fopen ("fcheck2.tmp", "w");
  
  for ( l = 0; l < nt; l++) {
    fprintf (fout, "%f %f %f %f %f %f %f\n", l*dt, *(sim->hull->RET + 0 + 0*6 + l*6*6), *(sim->hull->RET + 1 + 1*6 + l*6*6), *(sim->hull->RET + 2 + 2*6 + l*6*6), *(sim->hull->RET + 3 + 3*6 + l*6*6) , *(sim->hull->RET + 4 + 4*6 + l*6*6) , *(sim->hull->RET + 5 + 5*6 + l*6*6));
    fprintf (fout2, "%f %f %f %f %f %f %f %f %f\n", l*dt, *(sim->hull->RET + 1 + 3*6 + l*6*6), *(sim->hull->RET + 1 + 5*6 + l*6*6), *(sim->hull->RET + 2 + 4*6 + l*6*6), *(sim->hull->RET + 3 + 5*6 + l*6*6) , *(sim->hull->RET + 3 + 1*6 + l*6*6) , *(sim->hull->RET + 5 + 1*6 + l*6*6),*(sim->hull->RET + 4 + 2*6 + l*6*6) , *(sim->hull->RET + 5 + 3*6 + l*6*6));
  }
  fclose (fout);
  fclose (fout2);
  

#if 0
  // Simple trapeze formula
  FILE * fa = fopen ("acheck.tmp","w");
  for ( k = 0; k < wes->len; k+= 1 ) {

    gsl_matrix * atmp = g_ptr_array_index (A, k);
    float w0 = g_array_index (wes, float, k);

    /* gsl_matrix * atmp = g_ptr_array_index (A, 120); */
    /* float w0 = g_array_index (wes, float, 120); */
    
    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++ )
    	sim->hull->A[i][j] = 0;
    
    // Time integral part
    for ( l = 0; l < nt-1; l++) {
      gdouble s1 = sin(w0*(l+1)*dt);
      gdouble s0 = sin(w0*l*dt);
      for ( i = 0; i < 6; i++ ) {
    	for ( j = 0; j < 6; j++ ) {
    	  sim->hull->A[i][j] += *(sim->hull->RET + i + j*6 + (l+1)*36)*s1
    	    + *(sim->hull->RET + i + j*6 + l*36)*s0;
    	}
      }
    }

    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
    	sim->hull->A[i][j] *= 0.5*dt/w0;
    	sim->hull->A[i][j] += gsl_matrix_get (atmp, i, j);
      }
    }

    fprintf (fa, "%f %f %f %f %f %f %f\n", w0, sim->hull->A[3][1], sim->hull->A[1][1], sim->hull->A[2][2],
  	     sim->hull->A[3][3], sim->hull->A[4][4], sim->hull->A[5][5]);
  }
  fclose (fa);

#else
   // Journee's formula (p13)
  
  /* FILE * fa = fopen ("acheck.tmp","w"); */
  /* for ( k = 0; k < wes->len; k+= 1 ) { */
  /*   gsl_matrix * atmp = g_ptr_array_index (A, k); */
  /*   float w0 = g_array_index (wes, float, k); */

  gsl_matrix * atmp = g_ptr_array_index (A, 100); // was 200
  float w0 = g_array_index (wes, float, 100); // was 200

    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++ )
  	sim->hull->A[i][j] = 0;

    for  ( l = 0; l < nt-1; l++) {
      gdouble c1 = sin(w0*(l+1)*dt) - sin(w0*l*dt);

      for ( i = 0; i < 6; i++ ) {
  	for ( j = 0; j < 6; j++ ) {
  	  sim->hull->A[i][j] += c1*( *(sim->hull->RET + i + j*6 + (l+1)*36) - *(sim->hull->RET + i + j*6 + l*36) );
  	}
      }

    }

  
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
  	sim->hull->A[i][j] /= (w0*w0*dt);
  	sim->hull->A[i][j] += ( *(sim->hull->RET + i + j*6 ) - *(sim->hull->RET + i + j*6 + (nt-1)*36)*cos(w0*(nt-1)*dt) ) / w0;
      }
    }

    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
  	sim->hull->A[i][j] /= w0;
  	sim->hull->A[i][j] += gsl_matrix_get (atmp, i, j);
      }
    }

    /* fprintf (fa, "%f %f %f %f %f %f %f\n", w0, sim->hull->A[3][1], sim->hull->A[1][1], sim->hull->A[2][2], */
    /* 	     sim->hull->A[3][3], sim->hull->A[4][4], sim->hull->A[5][5]); */
    /* fprintf (fa, "%f %f %f %f %f %f %f\n", w0, sim->hull->A[0][4], sim->hull->A[1][3], sim->hull->A[1][5], */
    /* 	     sim->hull->A[2][4], sim->hull->A[3][5], sim->hull->A[5][5]); */
  /* } */
  /* fclose (fa); */
#endif


  g_ptr_array_free (A, TRUE);
  g_ptr_array_free (B, TRUE);
  g_array_free (wes, TRUE);
  //g_assert_not_reached ();

  FILE * fam_check = fopen ("added_mass.tmp", "w");
  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) {
      fprintf (fam_check, "%e ", sim->hull->A[i][j]);
    }
    fprintf (fam_check, "\n");
  }
  fclose (fam_check);

  fprintf (stdout, "Done\n");
  //g_assert_not_reached ();
}

static void get_radiation_matrix_monochromatic (Simulation * sim)
{
  int i, j, k;
  double aa, bb;
  float we;
  FILE * fam = fopen("1704B/addedmass","r");

  // Read from PDSTrip complex added mass outputs
  for ( k = 0; k < 70; k++) {
    fscanf (fam, "%f\n",&we);
    for ( i  = 0; i < 6; i++ ) {
      for ( j  = 0; j < 6; j++ ) {
	fscanf (fam, "%lf %lf\n",&aa,&bb);
	sim->hull->A[i][j] = aa/(we*we);
	sim->hull->D[i][j] = -bb/we;
      }
    }
  }

  fclose (fam);
}

static void get_diffraction_coeffs (Simulation * sim)
{
  int i, j;
  double aa, bb;
  float we;
  FILE * fdiff = fopen("1704B/diffraction","r");

  for ( j = 0; j < 70; j ++) {
    fscanf (fdiff, "%f\n",&we);
    sim->hull->we = we;
    for ( i  = 0; i < 6; i++ ) {
      fscanf (fdiff, "%lf %lf\n",&aa,&bb);
      /* sim->hull->diff[i][0] = sqrt(aa*aa+bb*bb*we*we); */
      /* sim->hull->diff[i][1] = atan(-bb*we/aa); */

      sim->hull->diff[i][0] = aa;
      sim->hull->diff[i][1] = bb;
    }
  }

  fclose (fdiff);
}

static void add_pdstrip_excitation_forces_1 (Simulation * sim,
						Forces * f,
						gdouble t,
						Motion m,
						gboolean prediction)
{
  gint i;
  
  // Wave forcing (FK + diffraction)
  for ( i = 0; i < 6; i++) {
    f->forces_ext1[i] += sim->hull->diff[i][0]*cos(sim->hull->we*t) + sim->hull->diff[i][1]*sin(sim->hull->we*t);
  }
}

Spectrum * spectrum_new (int nwe, int ndir)
{
  Spectrum * spec = g_malloc (sizeof(Spectrum));

  spec->nwe = (int) nwe;
  spec->ndir = (int) ndir;
  spec->we = g_malloc (nwe*sizeof(double));
  spec->dir = g_malloc (ndir*sizeof(double));

  spec->rotated = FALSE;

  spec->amp = g_malloc (nwe*ndir*sizeof(double));
  spec->phase = g_malloc (nwe*ndir*sizeof(double));

  return spec;
}

Spectrum * spectrum_diwasp_from_file (char * file_name, gdouble scaling)
{
  FILE * fin = fopen (file_name, "r");

  float xd; //Compass direction of x axis
  float nwe, ndir, dummy;
  float we, dir, amp;

  g_assert ( EOF != fscanf (fin, "%f\n", &xd) );
  g_assert ( EOF != fscanf (fin, "%f\n", &nwe) );
  g_assert ( EOF != fscanf (fin, "%f\n", &ndir) );

  Spectrum * spec = spectrum_new (nwe, ndir);

  spec->xdir = xd;

  fprintf (stdout, "Reading DIWASP spectrum file %s\n", file_name);
  fprintf (stdout, "Direction of x axis: %2.1f\n", xd);
  fprintf (stdout, "Number of frequencies: %i\n", spec->nwe);
  fprintf (stdout, "Number of directions: %i\n", spec->ndir);

  int i, j;
  for ( i = 0; i < spec->nwe; i++ ) {
    g_assert ( EOF != fscanf (fin, "%e\n", &we) );
    *(spec->we+i) = (double) we;
  }

  for ( i = 0; i < spec->ndir; i++ ) {
    g_assert ( EOF != fscanf (fin, "%e\n", &dir) );
    *(spec->dir+i) = (double) dir;
  }

  g_assert ( EOF != fscanf (fin, "%e\n", &dummy) );
  g_assert ( dummy == 999 );

  // Size of bins
  double dwe = *(spec->we+1) - *(spec->we);
  double ddir = *(spec->dir+1) - *(spec->dir);

  for ( i = 0; i < spec->nwe; i++ ) {
    for ( j = 0; j < spec->ndir; j++ ) {
      g_assert ( EOF != fscanf (fin, "%e\n", &amp) );
      *(spec->amp+i*spec->ndir+j) = (double) amp;
      // Integral over bins
      *(spec->amp+i*spec->ndir+j) = sqrt(2*(*(spec->amp+i*spec->ndir+j))*dwe*ddir)*scaling;
      *(spec->phase+i*spec->ndir+j) = (double)rand()/(double)RAND_MAX*2*M_PI;
    }
  }

  // Convert frequencies into orbital frequencies
  for ( i = 0; i < spec->nwe; i++ )
    *(spec->we+i) *= 2*M_PI;

  g_warning ("DIWASP: do we need to convert directions into radian\n");

  fclose (fin);

  fprintf (stderr, "DIWASP spectrum file read done\n\n");

  return spec;
}

double modulus(double a, double b)
{
  int result = (int) ( a / b );
  return a - (double) ( result ) * b;
}

void spectrum_rotate_to_ship_heading (Spectrum * spec, double heading)
{
  double angle = 180 + heading - spec->xdir;
  int i;

  for ( i = 0; i < spec->ndir; i++ ) {
    *(spec->dir + i) = modulus (*(spec->dir + i) + angle, 360) ; 
  }

  spec->rotated = TRUE;
}

void spectrum_destroy (Spectrum * spec)
{
  g_free (spec->we);
  g_free (spec->dir);
  g_free (spec->amp);
  g_free (spec->phase);
  g_free (spec);
}

void spectrum_array_print (Spectrum * spec, char * out_file_name)
{
  FILE * fout = fopen (out_file_name,"w");
  int i, j;

  for ( i = 0; i < spec->ndir; i++ ) {
    for ( j = 0; j < spec->nwe; j++ ) {
      fprintf (fout, "%f %f %f\n", *(spec->dir+i), *(spec->we+j), *(spec->amp+j*spec->ndir+i));
    }
    fprintf (fout, "\n");
  }

  fclose (fout);
}

void spectrum_diwasp_generate_time_series (Spectrum * spec)
{
  gdouble t;
  gint i, j;
  FILE * fout = fopen ("time_series_from_diwasp_spec.tmp","w");

  for ( t = 0; t < 3600; t++) {
    gdouble eta = 0;

    for ( i = 0; i < spec->nwe; i++ ) {
      for ( j = 0; j < spec->ndir; j++ ) {
	eta += *(spec->amp+i*spec->ndir+j)*cos(t*(*(spec->we+i)) + *(spec->phase+i*spec->ndir+j));
      }
    }
    fprintf (fout, "%f %f\n", t, eta);
  }

  fclose (fout);
}


DiffractionCoeffs * diffraction_coeffs_new (int nwe, int ndir)
{
  DiffractionCoeffs * dc = g_malloc (sizeof(DiffractionCoeffs));
  int i;

  dc->nwe = nwe;
  dc->ndir = ndir;

  dc->we = g_malloc (nwe*sizeof(double));
  dc->dir = g_malloc (ndir*sizeof(double));

  for ( i = 0; i < 6; i++ ) {
    dc->re[i] = g_malloc0 (nwe*ndir*sizeof(double));
    dc->im[i] = g_malloc0 (nwe*ndir*sizeof(double));
  }

  return dc;
}

void diffraction_coeffs_interp2d_set (DiffractionCoeffs * dc)
{
  int i;

  for ( i = 0; i < 6; i++ ) {
    dc->interp_re[i] = interp2d_spline_alloc(interp2d_bilinear, dc->nwe, dc->ndir);
    dc->interp_im[i] = interp2d_spline_alloc(interp2d_bilinear, dc->nwe, dc->ndir);
  }

  dc->xa = gsl_interp_accel_alloc();
  dc->ya = gsl_interp_accel_alloc();
}

int diffraction_coeffs_we_index (DiffractionCoeffs * dc, float we)
{
  int i;
  for ( i = 0; i < dc->nwe; i++)
    if ( *(dc->we + i) == we )
      return i;
}

int diffraction_coeffs_dir_index (DiffractionCoeffs * dc, float dir)
{
  int i;
  for ( i = 0; i < dc->ndir; i++)
    if ( *(dc->dir + i) == dir )
      return i;
}

void diffraction_coeffs_destroy (DiffractionCoeffs * dc)
{
  int i;
  g_free (dc->we);
  g_free (dc->dir);
  for ( i = 0; i < 6; i++ ) {
    g_free (dc->re[i]);
    g_free (dc->im[i]);
  }

  if (dc->xa) {
    gsl_interp_accel_free (dc->xa);
    gsl_interp_accel_free (dc->ya);
    for ( i = 0; i < 6; i++ ) {
      interp2d_spline_free(dc->interp_re[i]);
    interp2d_spline_free(dc->interp_im[i]);
    }
  }

  g_free (dc);
}

void diffraction_interp_init (DiffractionCoeffs * dc)
{
  int i;

  for ( i = 0; i < 6; i++ ) {
    interp2d_spline_init (dc->interp_re[i], dc->we, dc->dir, dc->re[i], dc->nwe, dc->ndir);
    interp2d_spline_init (dc->interp_im[i], dc->we, dc->dir, dc->im[i], dc->nwe, dc->ndir);
  }
}

double diffraction_interp_re (DiffractionCoeffs * dc, double we_i, double dir_i, int i)
{
  return interp2d_spline_eval (dc->interp_re[i], we_i, dir_i, dc->xa, dc->ya);
}

double diffraction_interp_im (DiffractionCoeffs * dc, double we_i, double dir_i, int i)
{
  return interp2d_spline_eval (dc->interp_im[i], we_i, dir_i, dc->xa, dc->ya);
}

gint increasing (gconstpointer a, gconstpointer b)
{
  if ( *((float *) a) < *((float *) b) )
    return -1;
  if ( *((float *) a) == *((float *) b) )
    return 0;
  return 1;
}

DiffractionCoeffs * diffraction_coeffs_from_pdstrip_file (gchar * file_name)
{
   int i, j, k, l;
   double aa, bb;
   float we, dir;

   fprintf (stdout, "Reading diffraction file %s\n", file_name);

   GArray * wes = g_array_new (FALSE, FALSE, sizeof(float));
   GArray * dirs = g_array_new (FALSE, FALSE, sizeof(float));

   FILE * fin = fopen (file_name, "r");
   // Read we and dirs
   while ( fscanf (fin, "%f\n",&dir) != EOF ) {

     dir = ((float) ( ((int) (100*dir))/(int) 1))/100;
     g_array_append_val (dirs, dir);

     g_assert ( fscanf (fin, "%f\n",&we) != EOF );
     g_array_append_val (wes, we);

     for ( i  = 0; i < 6; i++ ) {
       g_assert ( fscanf (fin, "%lf %lf\n",&aa,&bb) != EOF );
     }
   }
   fclose (fin);

   // Sort in increasing order
   g_array_sort (wes, increasing);
   g_array_sort (dirs, increasing);

   // Remove multiple occurence
   i = 0;
   while ( i < wes->len-1 ) {
     while ( i < wes->len-1 && g_array_index (wes, float, i) == g_array_index (wes, float, i+1) ) {
       wes = g_array_remove_index (wes , i+1);
     }
     i++;
   }

   i = 0;
   while ( i < dirs->len-1 ) {
     while ( i < dirs->len-1 && g_array_index (dirs, float, i) == g_array_index (dirs, float, i+1) ) {
       dirs = g_array_remove_index (dirs , i+1);
     }
     i++;
   }
   
   DiffractionCoeffs * dc = diffraction_coeffs_new (wes->len, 2*dirs->len-1);
   diffraction_coeffs_interp2d_set (dc);

   fprintf (stderr, "Number of frequencies: %i\n", wes->len);
   fprintf (stderr, "Number of directions: %i\n", dirs->len);

   for ( i = 0; i < wes->len; i++ )
     *(dc->we + i) = (double) g_array_index (wes, float, i);

   for ( i = 0; i < dirs->len; i++ )
     *(dc->dir + i) = (double) g_array_index (dirs, float, i);




   // Read diffraction
   fin = fopen (file_name, "r");
   while ( fscanf (fin, "%f\n",&dir) != EOF ) {
     dir = ((float) ( ((int) (100*dir))/(int) 1))/100;
     int id = diffraction_coeffs_dir_index (dc, dir);

     g_assert ( fscanf (fin, "%f\n",&we) != EOF );
     int iw = diffraction_coeffs_we_index (dc, we);

     for ( i  = 0; i < 6; i++ ) {
       g_assert ( fscanf (fin, "%lf %lf\n",&aa,&bb) != EOF );
       *(dc->re[i] + id*dc->nwe + iw) = aa;
       *(dc->im[i] + id*dc->nwe + iw) = bb;
     }
   }
   fclose (fin);

   // Add symmetrical
   for ( i = dirs->len; i < 2*dirs->len-1; i++) {
     *(dc->dir + i) = *(dc->dir + i - dirs->len +1) + 180;
     for ( j = 0; j < wes->len; j++ ) {
       for ( k = 0; k < 6; k++ ) {
	 *(dc->re[k] + i*dc->nwe + j) = *(dc->re[k] + (2*dirs->len-2-i)*dc->nwe + j);
	 *(dc->im[k] + i*dc->nwe + j) = *(dc->im[k] + (2*dirs->len-2-i)*dc->nwe + j);
       }
     }
   }

   g_array_free (dirs, TRUE);
   g_array_free (wes, TRUE);

   // Extend to we = 0 and we = 100
   DiffractionCoeffs * dc_new = diffraction_coeffs_new (dc->nwe+2, dc->ndir);
   diffraction_coeffs_interp2d_set (dc_new);
   *(dc_new->we) = 0.;
   *(dc_new->we+dc_new->nwe-1) = 100.;
   for ( i = 0; i < dc->nwe; i++ )
     *(dc_new->we+i+1) = *(dc->we+i);
   for ( i = 0; i < dc->ndir; i++ )
     *(dc_new->dir+i) = *(dc->dir+i);

   for ( i = 0; i < dc->nwe; i++ ) {
     for ( j = 0; j < dc->ndir; j++ ) {
       for ( k = 0; k < 6; k++ ) {
   	 *(dc_new->re[k] + j*dc_new->nwe + i+1) = *(dc->re[k] +j*dc->nwe + i);
   	 *(dc_new->im[k] + j*dc_new->nwe + i+1) = *(dc->im[k] +j*dc->nwe + i);
       }
     }
   }
   
   diffraction_coeffs_destroy (dc);

   // Init interpolators
   diffraction_interp_init (dc_new);

   fprintf (stderr, "Reading diffraction file done\n\n");

   return dc_new;
}

DiffractionCoeffs * diffraction_coeffs_from_nemoh_file (gchar * file_name)
{
   int i, j, k, l;
   double aa, bb;
   float we, dir;

   fprintf (stdout, "Reading diffraction file %s\n", file_name);

   GArray * wes = g_array_new (FALSE, FALSE, sizeof(float));
   GArray * dirs = g_array_new (FALSE, FALSE, sizeof(float));

   FILE * fin = fopen (file_name, "r");
   char buffer[1000];
   fgets(buffer, 1000, fin);
   fgets(buffer, 1000, fin);
   int nf;
   fscanf (fin, "%f %i\n",&dir, &nf);



   /* fprintf (stdout, "%f %i\n", dir, nf); */

   for ( i = 0; i < nf; i++ ) {
     fscanf (fin, "%f",&we);
     g_array_append_val (wes, we);

     for ( j = 0; j < 12; j++ ) {
       fscanf (fin, "%f",&we);
     }
     
   }
   
   fclose (fin);

   fin = fopen (file_name, "r");
   fgets(buffer, 1000, fin);
   fgets(buffer, 1000, fin);
   while ( EOF != fscanf (fin, "%f %i\n",&dir, &nf) ) {

     g_array_append_val (dirs, dir);

     for ( i = 0; i < nf; i++ ) {
       fscanf (fin, "%f",&we);

       for ( j = 0; j < 12; j++ )
	 fscanf (fin, "%f",&we);
     }

   }

   fclose (fin);

   fprintf (stderr, "Number of frequencies: %i\n", wes->len);
   fprintf (stderr, "Number of directions: %i\n", dirs->len);

   DiffractionCoeffs * dc = diffraction_coeffs_new (wes->len, dirs->len+1);
   diffraction_coeffs_interp2d_set (dc);

   

   for ( i = 0; i < wes->len; i++ )
     *(dc->we + i) = (double) g_array_index (wes, float, i);

   for ( i = 0; i < dirs->len; i++ )
     *(dc->dir + i) = (double) g_array_index (dirs, float, i);
   *(dc->dir + dirs->len) = 360.;


   fin = fopen (file_name, "r");
   fgets(buffer, 1000, fin);
   fgets(buffer, 1000, fin);
   while ( EOF != fscanf (fin, "%f %i\n",&dir, &nf) ) {
     int id = diffraction_coeffs_dir_index (dc, dir);


     for ( j = 0; j < nf; j++ ) {

       float amp[6];
       float phase[6];

       g_assert ( fscanf (fin, "%f",&we) != EOF );
       int iw = diffraction_coeffs_we_index (dc, we);
     
       for ( i  = 0; i < 6; i++ )
	 g_assert ( EOF != fscanf(fin, "%f", &amp[i]) );

       for ( i  = 0; i < 6; i++ )
	 g_assert ( EOF != fscanf(fin, "%f", &phase[i]) );

       for ( i  = 0; i < 6; i++ ) {
	 *(dc->re[i] + id*dc->nwe + iw) = amp[i]*cos(phase[i]*M_PI/180.);
	 *(dc->im[i] + id*dc->nwe + iw) = -amp[i]*sin(phase[i]*M_PI/180.);
       }

     }
   }

   fclose (fin);

   // Add 360
   for ( i = 0; i < dc->nwe; i++ ) {
     for ( j = 0; j < 6; j++) {
       *(dc->re[j] + (dc->ndir-1)*dc->nwe + i) = *(dc->re[j] + i);
       *(dc->im[j] + (dc->ndir-1)*dc->nwe + i) = *(dc->im[j] + i);
     }
   }

   g_array_free (dirs, TRUE);
   g_array_free (wes, TRUE);

   // Init interpolators
   diffraction_interp_init (dc);

   fprintf (stderr, "Reading diffraction file done\n\n");

   return dc;
}

void diffraction_coeffs_print (DiffractionCoeffs * dc, gchar * out_file_name, int k)
{
  int i, j;

  FILE * fout = fopen (out_file_name,"w");


  
  for ( j = 0; j < dc->ndir; j++ ) {
    for ( i = 0; i < dc->nwe; i++ ) {
      fprintf (fout, "%f %f %f %f\n", *(dc->dir + j), *(dc->we + i), *(dc->re[k] + j*dc->nwe + i), *(dc->im[k] + j*dc->nwe + i));
    }
    fprintf (fout, "\n");
  }

  fclose (fout);
}

DiffractionCoeffs * diffraction_coeffs_interpolated (DiffractionCoeffs * dc, double * we,
						     double * dir, int nwe, int ndir)
{
  DiffractionCoeffs * idc = diffraction_coeffs_new (nwe, ndir);
  int i, j, k;

  idc->nwe = nwe;
  idc->ndir = ndir;

  for ( i = 0; i < nwe; i++)
    *(idc->we + i) = *(we + i);

  for ( i = 0; i < ndir; i++)
    *(idc->dir + i) = *(dir + i);

  for ( i = 0; i < nwe; i++ ) {
    for ( j = 0; j < ndir; j++ ) {
      for ( k = 0; k < 6; k++ ) {
	*(idc->re[k] + i + j*nwe) = diffraction_interp_re (dc, *(we+i), *(dir+j), k);
	*(idc->im[k] + i + j*nwe) = diffraction_interp_im (dc, *(we+i), *(dir+j), k);
      }
    }
  }

  return idc;
}

double diffraction_coeffs_force_from_spectrum (DiffractionCoeffs * dc, Spectrum * spec, double t, int mode)
{
  double val = 0;
  int i, j;

  g_assert (spec->rotated);

  for ( i = 0; i < spec->nwe; i++ ) {
    for ( j = 0; j < spec->ndir; j++ ) {
      double alpha = *(spec->we+i)*t + *(spec->phase+i*spec->ndir+j);
      val+= *(spec->amp+i*spec->ndir+j)*
	( *(dc->re[mode] +j*dc->nwe + i)*cos(alpha) + 
	  *(dc->im[mode] +j*dc->nwe + i)*sin(alpha) );

    }
  }

  return val;
}

void add_diffraction_forces_from_spectra_1 (Simulation * sim,
					    Forces * f,
					    gdouble t,
					    Motion m,
					    gboolean prediction)
{
  int i, j, k;
  Spectrum * spec;
  DiffractionCoeffs * idc;

  for ( k = 0; k < 6; k++ )
    f->forces_fk1[k] += diffraction_coeffs_force_from_spectrum (sim->idc, sim->spec, t, k);
}

void add_pdstrip_initial_damping_1 (Simulation * sim,
				    Forces * f,
				    gdouble t,
				    Motion m,
				    gboolean prediction)
{
  gdouble period = 2*M_PI/sim->hull->we;
  gdouble t1= 20.*period;
  gdouble strength = /* 20 */5;

  gdouble strength_f = 10./period;
  gdouble strength_m = /* 2. *//* 3. *//* 1.0 */0.3/period;

  
  // Initial damping
  if (t < t1/2.) {
    f->forces_v1[0] = -strength_f*sim->hull->M1[0][0]*m.u1[0];
    f->forces_v1[1] = -strength_f*sim->hull->M1[1][1]*m.u1[1]-strength_f*sim->hull->M1[1][1]*m.x1[1];
    f->forces_v1[2] = -strength_f*sim->hull->M1[2][2]*m.u1[2];
    f->forces_v1[3] = -strength_m*sim->hull->M1[3][3]*m.u1[3];
    f->forces_v1[4] = -strength_m*sim->hull->M1[4][4]*m.u1[4];
    //f->forces_v1[5] = -strength_m*sim->hull->M1[5][5]*m.u1[5]*fabs(m.u1[5])-/* 0.25* */strength_m*sim->hull->M1[5][5]*m.x1[5];
  }
  else {
    gdouble tt = -pow(((t-0.5*t1)/t1),2);
    f->forces_v1[0] = -strength_f*sim->hull->M1[0][0]*m.u1[0]*exp(-((t-0.25*t1)/t1)*((t-0.25*t1)/t1));
    f->forces_v1[1] =  -(strength_f*sim->hull->M1[1][1]*m.u1[1]+strength_f*sim->hull->M1[1][1]*m.x1[1])*exp(tt)/* -strength_f*sim->hull->M1[1][1]*m.x1[1] */;
    f->forces_v1[2] = -strength_f*sim->hull->M1[2][2]*m.u1[2]*exp(tt);
    f->forces_v1[3] = -strength_m*sim->hull->M1[3][3]*m.u1[3]*exp(tt);
    f->forces_v1[4] =  -strength_m*sim->hull->M1[4][4]*m.u1[4]*exp(tt);
    //  f->forces_v1[5] =  -(strength_m*sim->hull->M1[5][5]*m.u1[5]*fabs(m.u1[5])+/* 0.25* */strength_m*sim->hull->M1[5][5]*m.x1[5])*exp(tt);
  }
  f->forces_v1[5] = -strength_m*sim->hull->M1[5][5]*m.u1[5]*fabs(m.u1[5])- strength_m*sim->hull->M1[5][5]*m.x1[5];

  //  g_assert_not_reached ();
}

static void add_inertial_forces_1 (Simulation * sim,
				   Forces * f,
				   gdouble t,
				   Motion m,
				   gboolean prediction)
{
  // Inertial forces as in p 14-15 of Journee 1993
  f->forces_ext1[0] += sim->hull->M[0][0]*(m.u1[1]*m.u1[5] - m.u1[2]*m.u1[4]);
  f->forces_ext1[1] += sim->hull->M[1][1]*(m.u1[2]*m.u1[3] - m.u1[0]*m.u1[5]);
  f->forces_ext1[2] += sim->hull->M[2][2]*(m.u1[0]*m.u1[4] - m.u1[1]*m.u1[3]);
  f->forces_ext1[3] += (sim->hull->M[4][4]-sim->hull->M[5][5])*m.u1[4]*m.u1[5];
  f->forces_ext1[4] += (sim->hull->M[5][5]-sim->hull->M[3][3])*m.u1[3]*m.u1[5];
  f->forces_ext1[5] += (sim->hull->M[3][3]-sim->hull->M[4][4])*m.u1[3]*m.u1[4];
}

static void add_pdstrip_damping_monochromatic_1 (Simulation * sim,
						 Forces * f,
						 gdouble t,
						 Motion m,
						 gboolean prediction)
{
  gint i, j;

  for ( i = 0; i < 6; i++) {
    for ( j = 0; j < 6; j++) {
      f->forces_1[i] -= sim->hull->D[i][j]*m.u1[j];
    }
  }
}

void add_freqdomain_damping_general_1 (Simulation * sim,
				       Forces * f,
				       gdouble t,
				       Motion m,
				       gboolean prediction)
{
  gint i, j, k;


  // Damping forces from retardation functions
  gdouble * un = g_malloc0(6*sizeof(double));
  for ( i = 0; i < 6; i++ )
    un[i] = m.u1[i];
  sim->hull->u_history = g_list_append (sim->hull->u_history, un);

  GList * uh = sim->hull->u_history;
  double ff[6];
  for ( i = 0; i < 6; i++)
    ff[i] = 0.;

  // First
  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) 
      ff[i] = *(sim->hull->RET + i + j*6)*  *((double *) uh->data + j);
  }

  // Last
  uh = g_list_last (sim->hull->u_history);
  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) 
      ff[i] +=  *(sim->hull->RET + i + j*6 + (sim->hull->nt-1)*36)* *((double *) uh->data + j);
  }

  for ( i = 0; i < 6; i++ )
    ff[i] *= 0.5;
  
  // Rest is from history
  GList * uh_tmp = uh->prev;

  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ )  {
      if ( *(sim->hull->RET + i + j*6) != 0.0) {
	uh = uh_tmp;
	k = 1;
	while ( uh->prev ) {
	  ff[i] += *(sim->hull->RET + i + j*6 + k*36)* *((double *) uh->data + j);
	  uh = uh->prev; k++;
	  /* int count = 1; */
	  /* while ( uh->prev && count < 5) { */
	  /*   uh = uh->prev; count++; */
	  /* } */
	}
      }
    }
  }

  sim->hull->u_history = g_list_remove (sim->hull->u_history, un);

  for ( i = 0; i < 6; i++) {
    f->forces_1[i] -= ff[i]*sim->time.dt;
  }

  //f->forces_fk1[1] += 134656*cos(2.*M_PI/60*t);


  /* f->forces_fk1[0] += 134656*cos(2.*M_PI/60*t+M_PI/2); */
  /* f->forces_fk1[1] += 3e5*cos(2.*M_PI/60*t+M_PI/2); */
  /* f->forces_fk1[5] += 2e6*cos(2.*M_PI/60*t+M_PI); */
}

#define MONOCHROMATIC FALSE

static void test_pdstrip_1 (Simulation * sim)
{
  int  i, j;
  double aa, bb;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  /* 150*2*M_PI/sim->hull->we */2000;
  sim->time.iend = 1e10;
  sim->time.dt = 0.1/* /5. */;
  
  
  FILE * fmass = fopen("1704B/mass","r");
  FILE * ffh = fopen("1704B/hydrostatics","r");
  // Read mass and hydrostatic matrices
  for ( i  = 0; i < 6; i++ ) {
    for ( j  = 0; j < 6; j++ ) {
      // Mass matrix
      fscanf (fmass, "%lf %lf\n",&aa,&bb);
      sim->hull->M[i][j] = aa;
      g_assert ( bb == 0.); // Check there is no complex component

      // Hydrostatic matrix
      fscanf (ffh, "%lf %lf\n",&aa,&bb);
      sim->hull->R[i][j] = aa;
      g_assert ( bb == 0.); // Check there is no complex component
    }
  }
  fclose (fmass);
  fclose (ffh);

#if MONOCHROMATIC
  get_radiation_matrix_monochromatic (sim);
#else
  // Read complex added mass matrix
  // Process into infinite frequency added mass matrix and retardation functions
  FILE * fam = fopen("1704B/addedmass","r");
  calculate_pdstrip_radiation_matrix (sim, fam);
  fclose (fam);
#endif

  // Read forcing (complex excitation forces)
  get_diffraction_coeffs (sim);

  // Set hull mass
  sim->hull->mg = sim->hull->M[0][0];  

  
  hull_initialise_motion (sim->hull);

#if !MONOCHROMATIC
  // Init velocity history
  sim->hull->u_history = NULL;
  for ( i = 0; i < /* 5* */sim->hull->nt-1; i++) {
    gdouble * u_tmp = g_malloc0 (6*sizeof(double));
    sim->hull->u_history = g_list_append (sim->hull->u_history, u_tmp);
  }
#endif

  // Combine mass and added mass matrix
  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) {
	sim->hull->M1[i][j] = sim->hull->M[i][j] + sim->hull->A[i][j];
    }
  }

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fspeed = fopen ("speed.tmp","w");
  FILE * fh = fopen ("fh.tmp","w");
  FILE * fd = fopen ("fd.tmp","w");
  FILE * fe = fopen ("fe.tmp","w");
  FILE * fv = fopen ("fv.tmp","w");
  FILE * fi = fopen ("fi.tmp","w");

  // Set forces
  GSList * forces = NULL;
  forces = g_slist_append (forces, add_hydrostatic_restoring_force_1);
  forces = g_slist_append (forces, add_pdstrip_excitation_forces_1);
  forces = g_slist_append (forces,  add_pdstrip_initial_damping_1);
#if MONOCHROMATIC
  forces = g_slist_append (forces, add_pdstrip_damping_monochromatic_1);
#else
  forces = g_slist_append (forces, add_freqdomain_damping_general_1);
#endif


  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    if ( sim->time.itime%20 == 0 )
      fprintf (stderr, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    solve_equation_of_motion_1 (sim->hull, &sim->time, sim, forces);
    
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

#if !MONOCHROMATIC
    // Add velocity to history
    gdouble * u_tmp = sim->hull->u_history->data;
    sim->hull->u_history = g_list_remove (sim->hull->u_history, u_tmp);
    for ( i = 0; i < 6; i++ )
      *(u_tmp+i) = *(sim->hull->m.u1+i);
    sim->hull->u_history = g_list_append (sim->hull->u_history, u_tmp);
#endif

    // Print motion
    fprintf (fmotion, "%f %f %f %f %f %f %f\n",
    	     sim->time.t+sim->time.dt,
    	     sim->hull->m.x1[0],
    	     sim->hull->m.x1[1],
    	     sim->hull->m.x1[2],
    	     sim->hull->m.x1[3],
    	     sim->hull->m.x1[4],
    	     sim->hull->m.x1[5]);

    // Print velocity
    fprintf (fspeed, "%f %f %f %f %f %f %f\n",
	     sim->time.t+sim->time.dt,
	     sim->hull->m.u1[0],
	     sim->hull->m.u1[1],
	     sim->hull->m.u1[2],
	     sim->hull->m.u1[3],
	     sim->hull->m.u1[4],
	     sim->hull->m.u1[5]);

    fprintf (fh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_h1[0], f->forces_h1[1], f->forces_h1[2],
	     f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
    fflush (fh);
    fprintf (fe, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_fk1[0], f->forces_fk1[1], f->forces_fk1[2],
	     f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
    fflush (fe);
    fprintf (fi, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_ext2[0], f->forces_ext2[1], f->forces_ext2[2],
	     f->forces_ext2[3], f->forces_ext2[4], f->forces_ext2[5]);
    fflush (fi);
    fprintf (fd, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_1[0], f->forces_1[1], f->forces_1[2],
	     f->forces_1[3], f->forces_1[4], f->forces_1[5]);
    fflush (fd);
    fprintf (fv, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_v1[0], f->forces_v1[1], f->forces_v1[2],
	     f->forces_v1[3], f->forces_v1[4], f->forces_v1[5]);
    fflush (fv);

    // Update time
    sim->time.itime++;
    sim->time.t += sim->time.dt;
  }

  fclose (fmotion);
  fclose (fspeed);
  fclose (fh);
  fclose (fe);
  fclose (fd);
  fclose (fv);
  fclose (fi);
}

static void test_nemoh_1 (Simulation * sim)
{
  int  i, j;
  double aa, bb;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  /* 150*2*M_PI/sim->hull->we */2000;
  sim->time.iend = 1e10;
  sim->time.dt = 0.1/* /5. */;
  
  
  FILE * fmass = fopen("1704B_172_32.2_12.2_0/mass","r");
  FILE * ffh = fopen("1704B_172_32.2_12.2_0/hydrostatics","r");
  // Read mass and hydrostatic matrices
  for ( i  = 0; i < 6; i++ ) {
    for ( j  = 0; j < 6; j++ ) {
      // Mass matrix
      fscanf (fmass, "%lf %lf\n",&aa,&bb);
      sim->hull->M[i][j] = aa;
      g_assert ( bb == 0.); // Check there is no complex component

      // Hydrostatic matrix
      fscanf (ffh, "%lf %lf\n",&aa,&bb);
      sim->hull->R[i][j] = aa;
      g_assert ( bb == 0.); // Check there is no complex component
    }
  }
  fclose (fmass);
  fclose (ffh);

#if MONOCHROMATIC
  get_radiation_matrix_monochromatic (sim);
#else
  // Read complex added mass matrix
  // Process into infinite frequency added mass matrix and retardation functions
  /* FILE * fam = fopen("1704B/addedmass","r"); */
  calculate_nemoh_radiation_matrix (sim, "joined_a.dat", "joined_b.dat");
  /* fclose (fam); */
#endif

  // Read forcing (complex excitation forces)
  get_diffraction_coeffs (sim);

  // Set hull mass
  sim->hull->mg = sim->hull->M[0][0];  

  
  hull_initialise_motion (sim->hull);

#if !MONOCHROMATIC
  // Init velocity history
  sim->hull->u_history = NULL;
  for ( i = 0; i < /* 5* */sim->hull->nt-1; i++) {
    gdouble * u_tmp = g_malloc0 (6*sizeof(double));
    sim->hull->u_history = g_list_append (sim->hull->u_history, u_tmp);
  }
#endif

  // Combine mass and added mass matrix
  for ( i = 0; i < 6; i++ ) {
    for ( j = 0; j < 6; j++ ) {
	sim->hull->M1[i][j] = sim->hull->M[i][j] + sim->hull->A[i][j];
    }
  }

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fspeed = fopen ("speed.tmp","w");
  FILE * fh = fopen ("fh.tmp","w");
  FILE * fd = fopen ("fd.tmp","w");
  FILE * fe = fopen ("fe.tmp","w");
  FILE * fv = fopen ("fv.tmp","w");
  FILE * fi = fopen ("fi.tmp","w");

  // Set forces
  GSList * forces = NULL;
  forces = g_slist_append (forces, add_hydrostatic_restoring_force_1);
  forces = g_slist_append (forces, add_pdstrip_excitation_forces_1);
  forces = g_slist_append (forces,  add_pdstrip_initial_damping_1);
#if MONOCHROMATIC
  forces = g_slist_append (forces, add_pdstrip_damping_monochromatic_1);
#else
  forces = g_slist_append (forces, add_freqdomain_damping_general_1);
#endif


  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    if ( sim->time.itime%20 == 0 )
      fprintf (stderr, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    solve_equation_of_motion_1 (sim->hull, &sim->time, sim, forces);
    
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

#if !MONOCHROMATIC
    // Add velocity to history
    gdouble * u_tmp = sim->hull->u_history->data;
    sim->hull->u_history = g_list_remove (sim->hull->u_history, u_tmp);
    for ( i = 0; i < 6; i++ )
      *(u_tmp+i) = *(sim->hull->m.u1+i);
    sim->hull->u_history = g_list_append (sim->hull->u_history, u_tmp);
#endif

    // Print motion
    fprintf (fmotion, "%f %f %f %f %f %f %f\n",
    	     sim->time.t+sim->time.dt,
    	     sim->hull->m.x1[0],
    	     sim->hull->m.x1[1],
    	     sim->hull->m.x1[2],
    	     sim->hull->m.x1[3],
    	     sim->hull->m.x1[4],
    	     sim->hull->m.x1[5]);

    // Print velocity
    fprintf (fspeed, "%f %f %f %f %f %f %f\n",
	     sim->time.t+sim->time.dt,
	     sim->hull->m.u1[0],
	     sim->hull->m.u1[1],
	     sim->hull->m.u1[2],
	     sim->hull->m.u1[3],
	     sim->hull->m.u1[4],
	     sim->hull->m.u1[5]);

    fprintf (fh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_h1[0], f->forces_h1[1], f->forces_h1[2],
	     f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
    fflush (fh);
    fprintf (fe, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_fk1[0], f->forces_fk1[1], f->forces_fk1[2],
	     f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
    fflush (fe);
    fprintf (fi, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_ext2[0], f->forces_ext2[1], f->forces_ext2[2],
	     f->forces_ext2[3], f->forces_ext2[4], f->forces_ext2[5]);
    fflush (fi);
    fprintf (fd, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_1[0], f->forces_1[1], f->forces_1[2],
	     f->forces_1[3], f->forces_1[4], f->forces_1[5]);
    fflush (fd);
    fprintf (fv, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_v1[0], f->forces_v1[1], f->forces_v1[2],
	     f->forces_v1[3], f->forces_v1[4], f->forces_v1[5]);
    fflush (fv);

    // Update time
    sim->time.itime++;
    sim->time.t += sim->time.dt;
  }

  fclose (fmotion);
  fclose (fspeed);
  fclose (fh);
  fclose (fe);
  fclose (fd);
  fclose (fv);
  fclose (fi);
}

static Pressure local_linear_nospeed_gauss_1 (SPPanel * spp,
					      gint m, gint n,
					      Simulation * sim,
					      HeightCurve hz,
					      gdouble t,
					      gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m+n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.P1 = pressure.Pfk1 = pressure.Ph1 = pressure.phi1 = 0.;

  // Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  //Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  /* gdouble c1 = g_array_index (gp->c1, gdouble, gindex); */
  /* gdouble c2 = g_array_index (gp->c2, gdouble, gindex); */
  /* gdouble c3 = g_array_index (gp->c3, gdouble, gindex); */
  /* gdouble c4 = g_array_index (gp->c4, gdouble, gindex); */
  /* gdouble c5 = g_array_index (gp->c5, gdouble, gindex); */
  /* gdouble c6 = g_array_index (gp->c6, gdouble, gindex); */

  /* Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t); */
  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p, t);

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble /* Phi1n = 0., */ Phi1 = 0./* , dPhi1du = 0., dPhi1dv = 0. */;
  /* Vector gradPhi1; */

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc = g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

      /* dPhi1du += v7*cv*cdu; */
      /* dPhi1dv += v7*cu*cdv; */
      /* Phi1n += sc->v[8]*cuv; */
      Phi1 += v7*cuv;
      //zeta += sc->v[9]*cuv;
    }
  }

  /* /\* Vector gradPhi2; *\/ */
  /* gradPhi1.x = Phi1n*N.x + c1*dPhi1du + c2*dPhi1dv; */
  /* gradPhi1.y = Phi1n*N.y + c3*dPhi1du + c4*dPhi1dv; */
  /* gradPhi1.z = Phi1n*N.z + c5*dPhi1du + c6*dPhi1dv; */

  /* Hydrostatic pressure */

  // Takes FS deformation into account for hydrostatic forces
  //  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  // Does not take FS deformation into account for hydrostatic forces
  pressure.Ph1 = -sim->rho*sim->g *( p.z /* - hz(p.x, p_inertial.y, t, hz_data) */);
  // Which one should be used ??

  /* Froude-Krylov forces */
  pressure.Pfk1 = -sim->rho*(dtphi0 /* + vector_scalar_product (&gradphi0, &gradphi0) */);

  /* Phi2 */
  pressure.phi1 = -sim->rho*Phi1;


  return pressure;
}

static void sppanel_linear_nospeed_forces_integral_gauss_1 (SPPanel * spp,
							  Simulation * sim,
							  gpointer data,
							  gint m, gint n,
							  HeightCurve hz,
							  gdouble t,
							  gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_nospeed_gauss_1 (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph1;
  gdouble wfk = wij*lp.Pfk1;
  gdouble wphi1 = wij*lp.phi1;

  f->forces_h1[0] += wh*N.x;
  f->forces_h1[1] += wh*N.y;
  f->forces_h1[2] += wh*N.z;
  
  f->forces_fk1[0] += wfk*N.x;
  f->forces_fk1[1] += wfk*N.y;
  f->forces_fk1[2] += wfk*N.z;

  f->phi1[0] += wphi1*N.x;
  f->phi1[1] += wphi1*N.y;
  f->phi1[2] += wphi1*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h1[3] += wh*x.x;
  f->forces_h1[4] += wh*x.y;
  f->forces_h1[5] += wh*x.z;

  f->forces_fk1[3] += wfk*x.x;
  f->forces_fk1[4] += wfk*x.y;
  f->forces_fk1[5] += wfk*x.z;

  f->phi1[3] += wphi1*x.x;
  f->phi1[4] += wphi1*x.y;
  f->phi1[5] += wphi1*x.z;
}

static void add_radiation_forces_1 (Simulation * sim,
				    Forces * f,
				    gdouble t,
				    Motion m,
				    gboolean prediction)
{
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss_1,
			  /* sim->wp.wave_elevation */flat_sea, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = m.u1[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi1[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_1[j]  += 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]) + f->forces_fk1[j];
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
    	//f->forces_1[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  for ( i = 0; i < 6; i++ )
    f->forces_h1[i] = 0.;
}

static void integrate_radiation_forces_1 (Simulation * sim,
					  Forces * f,
					  gdouble t,
					  Motion m,
					  gboolean prediction)
{
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss_1,
			  /* sim->wp.wave_elevation */flat_sea, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = m.u1[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi1[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_1[j]  += 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]) + f->forces_fk[j];
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }


  /* // For stability reasons the time-derivative part of the time-local forces is tweeked */
  /*   for ( i = 0; i < 6; i++ ) { */
  /*     for ( j = 0; j < 6; j++ ) { */
  /*   	f->forces_1[i] += sim->hull->A[i][j]*a[j]; */
  /*     } */
  /*   } */
  }

  for ( i = 0; i < 6; i++ )
    f->forces_h1[i] = 0.;
}

static void set_ship_motion_1 (Simulation * sim,
			       Forces * f,
			       gdouble t,
			       Motion m,
			       gboolean prediction)
{
  gint i;
  
  for ( i = 0; i < 6; i++ ) {
    sim->hull->m.x1[i] = sim->hull->m.x[i] = m.x1[i] = m.x[i] = 0.;
    sim->hull->m.u1[i] = sim->hull->m.u[i] = m.u1[i] = m.u[i] = 0.;
  }

  gint d = sim->d;
  sim->hull->m.x1[d] = sim->hull->m.x[d] = m.x1[d] = m.x[d] = sim->wp.A*cos(sim->wp.w*t);
  sim->hull->m.u1[d] = sim->hull->m.u[d] = m.u1[d] = m.u[d] = -sim->wp.A*sim->wp.w*sin(sim->wp.w*t);
}

gdouble test_heaving_sphere2 (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation

  gdouble radius = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  25.*sqrt(radius/9.81);
  sim->time.iend = 1e6;
  sim->time.dt = 0.005;

  sim->wp.g = 9.81;

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  //sim->fs_elevation_update = leapfrog_no_speed_elevation_update;
  //sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  //sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update;
  sim->fs_elevation_rhs_store = NULL;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;
  //sim->fs_elevation_rhs_store = abm4_free_surface_elevation_disturbance_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_no_speed_potential_update;
  //sim->fs_potential_update = explicit_no_speed_potential_update;
  //sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->fs_potential_update = abm4_no_speed_potential_update;
  //sim->fs_potential_update = abm4_free_surface_disturbance_potential_update;

  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson
  sim->fs_potential_rhs_store = NULL;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;
  //sim->fs_potential_rhs_store = abm4_free_surface_disturbance_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = TRUE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;

  // Radius of domain
  // NB: 500 for a ship-size half spheroid
  sim->wp.r1 = 45.;
  sim->wp.r2 = 45.;

  sim->wp.r1_inner = 5.;
  sim->wp.r2_inner = 5.;

  sim->N = 50;
  sim->M = 50;

  // Create hull patch
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (10, 30,
										      half_sphere_x3,
										      half_sphere_y3,
										      half_sphere_z3,
										      &radius, 3, 4, 2));

  hull_print (sim->hull, NULL);

  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 2);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  sim->lu_destroy (sim->neumann_lu);
  
  //simulation_calculate_gradients_linear (sim);
  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);


  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_1 (sim);
  //solve_boundary_problem_for_disturbance_flow_kim (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of half-sphere
  sim->hull->mg = 0.5*4./3.*M_PI*radius*radius*radius*density;
  calculate_mass_from_position_at_rest (sim->hull, sim);

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  hull_initialise_motion (sim->hull);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  // Change to the initial position if required
  sim->hull->m.x1[2] = 1.;
  //sim->hull->m.u1[2] = sqrt(9.81*radius);

  motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);
  
  // Force terms
  sim->forces = g_slist_append (sim->forces, add_radiation_forces_1);
  sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force_1);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    solve_equation_of_motion_1 (sim->hull, &sim->time, sim, sim->forces);

    // Update time
    sim->time.itime++;
    // Filters the free-surface elevation every 20 iterations
    if ( sim->time.itime%20 == 0 )
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	       (sim->time.t+sim->time.dt)*sqrt(9.81/radius),
	       sim->hull->m.x1[0],
	       sim->hull->m.x1[1],
	       sim->hull->m.x1[2],
	       sim->hull->m.x1[3],
	       sim->hull->m.x1[4],
	       sim->hull->m.x1[5]);
      fflush (fmotion);

      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
    }

    if ( sim->time.itime%10 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  fclose (fmotion);
  fclose (fu);
  fclose (flog);
}

static void add_initial_damping_save (Simulation * sim,
				 Forces * f,
				 gdouble t,
				 Motion m,
				 gboolean prediction)
{
  gdouble period = 2*M_PI/sim->wp.w;
  gdouble t1= 18.*period;
  gint i;
  gdouble strength = /* 20 */5;

  gdouble strength_f = 10.;
  gdouble strength_m = /* 2. *//* 3. *//* 1.0 */0.3;

  f->forces_ext1[0] = t < t1/2. ? -strength_f*sim->hull->M1[0][0]/period*m.u1[0] : -strength_f*sim->hull->M1[0][0]/period*m.u1[0]*exp(-((t-0.25*t1)/t1)*((t-0.25*t1)/t1));
  f->forces_ext1[1] = t < t1/2. ? -strength_f*sim->hull->M1[1][1]/period*m.u1[1] : -strength_f*sim->hull->M1[1][1]/period*m.u1[1]*exp(-((t-0.5*t1)/t1)*((t-0.5*t1)/t1));
  f->forces_ext1[2] = t < t1/2. ? -strength_f*sim->hull->M1[2][2]/period*m.u1[2] : -strength_f*sim->hull->M1[2][2]/period*m.u1[2]*exp(-((t-0.5*t1)/t1)*((t-0.5*t1)/t1));
  f->forces_ext1[3] = t < t1/2. ? -strength_m*sim->hull->M1[3][3]/period*m.u1[3] : -strength_m*sim->hull->M1[3][3]/period*m.u1[3]*exp(-((t-0.5*t1)/t1)*((t-0.5*t1)/t1));
  f->forces_ext1[4] = t < t1/2. ? -strength_m*sim->hull->M1[4][4]/period*m.u1[4] : -strength_m*sim->hull->M1[4][4]/period*m.u1[4]*exp(-((t-0.5*t1)/t1)*((t-0.5*t1)/t1));
  f->forces_ext1[5] = t < t1/2. ? -strength_m*sim->hull->M1[5][5]/period*m.u1[5] : -strength_m*sim->hull->M1[5][5]/period*m.u1[5]*exp(-((t-0.5*t1)/t1)*((t-0.5*t1)/t1));

  // 18 p 1 s
  f->forces_ext1[5] = t < t1 ? -strength_m*sim->hull->M1[5][5]/period*m.u1[5]*(t1-t)/t1:0;

 

  /* for ( i = 0; i < 6; i++) */
  /*   f->forces_ext1[i] = 1000.; */
}

/* static void add_initial_damping (Simulation * sim, */
/* 				 Forces * f, */
/* 				 gdouble t, */
/* 				 Motion m, */
/* 				 gboolean prediction) */
/* { */
/*   gdouble period = 2*M_PI/sim->wp.w; */
/*   gdouble t1= 7.*period; */
/*   gint i; */
/*   gdouble strength = /\* 20 *\/5; */

/*   gdouble strength_f = 10.; */
/*   gdouble strength_m = /\* 2. *\//\* 3. *\//\* 0.3 *\/2.0; */

/*   f->forces_ext1[0] = t < t1 ? -strength_f*sim->hull->M1[0][0]/period*m.u1[0] : 0; */
/*   f->forces_ext1[1] = t < t1 ? -strength_f*sim->hull->M1[1][1]/period*m.u1[1] : 0.; */
/*   f->forces_ext1[2] = t < t1 ? -strength_f*sim->hull->M1[2][2]/period*m.u1[2] : 0.; */
/*   //  f->forces_ext1[3] = t < t1 ? -strength_m*sim->hull->M1[3][3]/period*m.u1[3] : 0.; */
/*   // f->forces_ext1[4] = t < t1 ? -strength_m*sim->hull->M1[4][4]/period*m.u1[4] : 0.; */
/*   // f->forces_ext1[5] = t < t1 ? -strength_m*sim->hull->M1[5][5]/period*m.u1[5] : 0.; */

/*   // 18 p 1 s */
/*   //f->forces_ext1[4] = t < t1 ? -strength_m*sim->hull->M1[5][5]/period*m.u1[5]*(t1-t)/t1:0; */

/*   // f->forces_ext1[4] = t < t1/2. ? -0.5*2.*t/t1*sim->hull->M1[4][4]/period*m.u1[4] : -0.5*sim->hull->M1[4][4]/period*m.u1[4]*exp(-((t-0.5*t1)/t1)/\* *((t-0.5*t1)/t1) *\/); */

/*   //  f->forces_ext1[4] = -0.5*sim->hull->M1[4][4]/period*m.u1[4]*exp(-t/t1/\* *((t-0.5*t1)/t1) *\/); */

/*   t1 = 18.*period; */
/*   strength_m = 0.2; */
/*   f->forces_ext1[3] = t < 50 ? -strength_m*sim->hull->M1[3][3]/period*m.u1[3]*fabs(m.u1[3]) : -strength_m*sim->hull->M1[3][3]/period*m.u1[3]*fabs(m.u1[3])*exp(-pow((t-50)/t1,1.5)); */
/*   f->forces_ext1[4] = t < 50 ? -strength_m*sim->hull->M1[4][4]/period*m.u1[4]*fabs(m.u1[4]) : -strength_m*sim->hull->M1[4][4]/period*m.u1[4]*fabs(m.u1[4])*exp(-pow((t-50)/t1,1.5)); */
/*   f->forces_ext1[5] = t < 50 ? -strength_m*sim->hull->M1[5][5]/period*m.u1[5]*fabs(m.u1[5]) : -strength_m*sim->hull->M1[5][5]/period*m.u1[5]*fabs(m.u1[5])*exp(-pow((t-50)/t1,1.5)); */

/*   /\* for ( i = 0; i < 6; i++) *\/ */
/*   /\*   f->forces_ext1[i] = 1000.; *\/ */
/* } */

static void add_initial_damping_new (Simulation * sim,
				     Forces * f,
				     gdouble t,
				     Motion m,
				     gboolean prediction)
{
  gdouble period = 2*M_PI/sim->wp.w;
  gdouble t1= 12.*period; // 7
  gint i;
  gdouble strength = /* 20 */5;

  gdouble strength_f = 20.;
  gdouble strength_m = 20;

  /* f->forces_ext1[0] = t < t1 ? -strength_f*sim->hull->M1[0][0]/period*m.u1[0] : 0; */
  /* f->forces_ext1[1] = t < t1 ? -strength_f*sim->hull->M1[1][1]/period*m.u1[1] : 0.; */
  /* f->forces_ext1[2] = t < t1 ? -strength_f*sim->hull->M1[2][2]/period*m.u1[2] : 0.; */
  /* f->forces_ext1[3] = t < t1 ? -strength_m*sim->hull->M1[3][3]/period*m.u1[3] : 0.; */
  /* //f->forces_ext1[4] = t < t1 ? -strength_m*sim->hull->M1[4][4]/period*m.u1[4] : 0.; */
  /* f->forces_ext1[5] = t < t1 ? -strength_m*sim->hull->M1[5][5]/period*m.u1[5] : 0.; */

  /* // 18 p 1 s */
  /* //f->forces_ext1[4] = t < t1 ? -(t1-t)/t1*strength_m*sim->hull->M1[5][5]/period*m.u1[4]*(t1-t)/t1:0; */

  
  /* f->forces_ext1[4] = t < t1/2. ? -strength_m*sim->hull->M1[4][4]/period*m.u1[4] : -strength_m*sim->hull->M1[4][4]/period*m.u1[4]*exp(-((t-0.5*t1)/t1)*((t-0.5*t1)/t1)); */

  /* f->forces_ext1[4] = -strength_m*sim->hull->M1[4][4]/period*m.u1[4]*exp(-/\* ((t-0.5*t1)/t1)* *\/((t-0.5*t1)/t1)); */

  /* strength_m = 2.; */
  /* t1= 18.*period; */
  /* f->forces_ext1[0] = -strength_f*sim->hull->M1[0][0]/period*m.u1[0]*exp(-/\* ((t-0.5*t1)/t1)* *\/((t)/t1)); */
  /* f->forces_ext1[1] = -strength_f*sim->hull->M1[1][1]/period*m.u1[1]*exp(-/\* ((t-0.5*t1)/t1)* *\/((t)/t1)); */
  /* f->forces_ext1[2] = -strength_f*sim->hull->M1[2][2]/period*m.u1[2]*exp(-/\* ((t-0.5*t1)/t1)* *\/((t)/t1)); */

  t1= 5.*period;
  strength_f = 100;
  gdouble strength_drift = 500/* 0 */;
  /* f->forces_ext1[0] = t < 50 ? -strength_drift*sim->hull->M1[0][0]/period*(m.u1[0]*fabs(m.u1[0])) :  -strength_drift*sim->hull->M1[0][0]/period*(m.u1[0]*fabs(m.u1[0]))*exp(-pow((t-50)/t1,1.5)); */
  /* f->forces_ext1[1] = t < 50 ? -strength_f*sim->hull->M1[1][1]/period*(m.u1[1]*fabs(m.u1[1])) :  -strength_f*sim->hull->M1[1][1]/period*(m.u1[1]*fabs(m.u1[1]))*exp(-pow((t-50)/t1,1.5)); */
  /* f->forces_ext1[2] = t < 50 ? -strength_f*sim->hull->M1[2][2]/period*(m.u1[2]*fabs(m.u1[2])) :  -strength_f*sim->hull->M1[2][2]/period*(m.u1[2]*fabs(m.u1[2]))*exp(-pow((t-50)/t1,1.5)); */

  f->forces_ext1[0] = t < 50 ? -strength_drift*sim->hull->M1[0][0]/(period*period)*(m.u1[0]*fabs(m.u1[0])) :  -strength_drift*sim->hull->M1[0][0]/(period*period)*(m.u1[0]*fabs(m.u1[0]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[1] = t < 50 ? -strength_f*sim->hull->M1[1][1]/(period*period)*(m.u1[1]*fabs(m.u1[1])) :  -strength_f*sim->hull->M1[1][1]/(period*period)*(m.u1[1]*fabs(m.u1[1]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[2] = t < 50 ? -strength_f*sim->hull->M1[2][2]/(period*period)*(m.u1[2]*fabs(m.u1[2])) :  -strength_f*sim->hull->M1[2][2]/(period*period)*(m.u1[2]*fabs(m.u1[2]))*exp(-pow((t-50)/t1,1.5));

  t1= 5.*period;
  strength_m = /* 0.2 */1.;
  f->forces_ext1[3] = t < 50 ? -strength_m*sim->hull->M1[3][3]/(period*period)*(m.u1[3]*fabs(m.u1[3])) :  -strength_m*sim->hull->M1[3][3]/(period*period)*(m.u1[3]*fabs(m.u1[3]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[4] = t < 50 ? -strength_m*sim->hull->M1[4][4]/(period*period)*(m.u1[4]*fabs(m.u1[4])) :  -strength_m*sim->hull->M1[4][4]/(period*period)*(m.u1[4]*fabs(m.u1[4]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[5] = t < 50 ? -strength_m*sim->hull->M1[5][5]/(period*period)*(m.u1[5]*fabs(m.u1[5])) :  -strength_m*sim->hull->M1[5][5]/(period*period)*(m.u1[5]*fabs(m.u1[5]))*exp(-pow((t-50)/t1,1.5));
}



gdouble test_floating_cylinder (Simulation * sim)
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = /* 20. */1.;

  gint M = /* 60 *//* 65 *//* 45 *//* 60 */50/* 55 */; // radial resolution
  gint N = /* 40 *//* 40 *//* 10 *//* 35 */30/* 40 */; // azimuthal resolution
  gint MM = /* 15 *//* 15 */10; // vertical resolution of cylinder

  sim->g = 9.80665;
  sim->rho = 1025.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  400.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.0025 *//* 0.025 */0.02;

  // Deep water dispersion relation !!!

  sim->wp.g = 9.80665;
  sim->wp.A = 1.0;
  
  sim->wp.h = 20.0;
  gdouble period = /* 20. *//* 16. *//* 25 */2.;
  sim->wp.w = 2.*M_PI/period;
  sim->wp.k = /* solve_dispersion_relation (&sim->wp) */sim->wp.w*sim->wp.w/sim->wp.g;

  /* sim->wp.k = /\* M_PI *\/2.0; */
  /* sim->wp.w = sqrt(sim->wp.k*sim->wp.g*tanh(sim->wp.k*sim->wp.h)); */
  /* printf("Wave period: %f \n", 2.*M_PI/sim->wp.w); */
  //sim->wp.w = sqrt(sim->wp.k*sim->wp.g );
  sim->wp.cosb = cos( M_PI/4.);
  sim->wp.sinb = sin( M_PI/4.);

  //sim->time.dt = 1./200*2.*M_PI/sim->wp.w;
  //sim->time.end = 10.*2.*M_PI/sim->wp.w;

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  /* sim->wp.wave_potential = finite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = finite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = finite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative; */

  sim->wp.wave_potential = infinite_depth_wave_potential;
  sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = infinite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;  

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = /* 20. */200.;
  sim->wp.r2 = /* 20. */200.;

  sim->wp.r1_inner = 100.;
  sim->wp.r2_inner = 100.;

  sim->wp.r1 = /* 3.*2.*M_PI/sim->wp.k */2.*20;
  sim->wp.r2 = /* 3.*2.*M_PI/sim->wp.k */2.*20;
  
  sim->wp.r1_inner = /* 1 */2/* 0. */;
  sim->wp.r2_inner = 2/* 0. */;

  sim->N = /* 50 *//* 80/2 *//* 40 */ M;
  sim->M = /* 50 *//* 80/2 *//* 90 *//* 65 */ N;

#if 0
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, N,
										      box_x1,
										      box_y1,
										      box_z1,
										      &radius, 3, 4, 3));

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, 2*N,
  										      box_x2,
  										      box_y2,
  										      box_z2,
  										      &radius, 3, 4, 3));

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, N,
										      box_x3,
										      box_y3,
										      box_z3,
										      &radius, 3, 4, 3));

  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, 2*N,
  										      box_x4,
  										      box_y4,
  										      box_z4,
  										      &radius, 3, 4, 3));
#else
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, N,
  										      half_cylinder_x3,
  										      half_cylinder_y3,
  										      half_cylinder_z3,
  										      &radius, 3, 4, 3));
#endif

  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

#if 0
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, 2*N,
  										      box_x5,
  										      box_y5,
  										      box_z5,
  										      &radius, 3, 4, 3));
#else
  sim->hull->patches = g_slist_append (sim->hull->patches, spline2d_parametric_patch (MM, N,
  										      half_cylinder_bottom_x3,
  										      half_cylinder_bottom_y3,
  										      half_cylinder_bottom_z3,
  										      &radius, 3, 4, 3));
#endif

  hull_print (sim->hull, NULL);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);


  /* sim->hull->wet_patches = sim->hull->patches; */
  /* build_free_surface (sim, 3, 4, 3); */

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  /* g_assert_not_reached (); */
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  // Bathy
  /* bathy->s->patches = g_slist_append (bathy->s->patches, spline2d_parametric_patch (MM, N, */
  /* 										    malenica_bathy_x, */
  /* 										    malenica_bathy_y, */
  /* 										    malenica_bathy_z, */
  /* 										    &sim->wp.r1, 3, 4, 3)); */

  /* fp = fopen ("norm3.tmp","w"); */
  /* spline2d_print_normals (bathy->s->patches->data, fp); */
  /* fclose(fp); */

  /* fp = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fp); */
  /* fclose (fp); */
  //g_assert_not_reached ();
  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  hull_print_gnuplot (sim->hull, NULL, 3, sim->time.t);
  // g_assert_not_reached ();


  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 
  //initialise_motion (sim);
  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow_kim (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  // For solid cylinder the matrix of inertia is:
  // 1/12m (3r^2+h^2)
  fprintf (flog, "MASSSSS: %e \n", sim->hull->mg);
  //sim->hull->mg = 10.;
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1] = sim->hull->mg/* 1./12.*sim->hull->mg*(3.*20.*20.+400.*400.) *//* 3 */;
  // m r^2/2
  sim->hull->Ig[2][2] = /* 0.5* */sim->hull->mg/* *20.*20. *//* 5. */; // ??
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  hull_initialise_motion (sim->hull);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  fprintf (flog, " Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->M[i][0],
	     sim->hull->M[i][1],
	     sim->hull->M[i][2],
	     sim->hull->M[i][3],
	     sim->hull->M[i][4],
	     sim->hull->M[i][5]);
  }
  fflush (flog);

  fprintf (flog, " Restoring coeff matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->R[i][0],
	     sim->hull->R[i][1],
	     sim->hull->R[i][2],
	     sim->hull->R[i][3],
	     sim->hull->R[i][4],
	     sim->hull->R[i][5]);
  }
  fflush (flog);
  //g_assert_not_reached ();

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[2] = sqrt(9.81*5);

  /* sim->hull->m.u[5] = 0.; // Initial spin */
  /* sim->hull->m.x[5] = 0./\* M_PI/4. *\/; */

  //sim->hull->m.x1[4] = 1.;

   motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);
  
  //sim->forces = g_slist_append (sim->forces, add_gravity_force);
   sim->forces = g_slist_append (sim->forces, add_radiation_forces_1);
   // sim->forces = g_slist_append (sim->forces, add_fake_fk);
   sim->forces = g_slist_append (sim->forces, add_initial_damping_new);
   sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force_1);
  

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    /* Forces * f = g_malloc (sizeof(Forces)); */
    /* forces_set_to_zero (f); */

    /* f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces); */

    solve_equation_of_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%10 == 0 )
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);

    

    

    if ( sim->time.itime%1 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x1[0], sim->hull->m.x1[1], sim->hull->m.x1[2],
	       sim->hull->m.x1[3], sim->hull->m.x1[4], sim->hull->m.x1[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk1[1], f->forces_fk1[2], f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext1[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

static Pressure local_linear_gauss_1 (SPPanel * spp,
				      gint m, gint n,
				      Simulation * sim,
				      HeightCurve hz,
				      gdouble t,
				      gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m+n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.P1 = pressure.Pfk1 = pressure.Ph1 = pressure.phi1 = 0.;

  Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p = g_array_index (gp->Pi, Point, gindex);
  FSData fsd = g_array_index (gp->fsdata, FSData, gindex);

  //Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);

  /* Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p, t); */
  gdouble dtphi0 = sim->wp.wave_potential_dt (&sim->wp, p, t);

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble Phi1n = 0., Phi1 = 0., dPhi1du = 0., dPhi1dv = 0.;
  Vector gradPhi1;

  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc = g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

      dPhi1du += v7*cv*cdu;
      dPhi1dv += v7*cu*cdv;
      Phi1n += sc->v[8]*cuv;
      Phi1 += v7*cuv;
      //zeta += sc->v[9]*cuv;
    }
  }

  Vector W;

  /* Vector gradPhi2; */
  gradPhi1.x = Phi1n*N.x + c1*dPhi1du + c2*dPhi1dv;
  gradPhi1.y = Phi1n*N.y + c3*dPhi1du + c4*dPhi1dv;
  gradPhi1.z = Phi1n*N.z + c5*dPhi1du + c6*dPhi1dv;

  W.x = sim->U.x - gradPhi1.x;
  W.y = sim->U.y - gradPhi1.y;
  W.z = sim->U.z - gradPhi1.z;

  /* Hydrostatic pressure */

  // Takes FS deformation into account for hydrostatic forces
  //  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  // Does not take FS deformation into account for hydrostatic forces
  pressure.Ph1 = -sim->rho*sim->g *( p.z /* - hz(p.x, p_inertial.y, t, hz_data) */);
  // Which one should be used ??

  /* Froude-Krylov forces */
  pressure.Pfk1 = -sim->rho*(dtphi0 /* + vector_scalar_product (&gradphi0, &gradphi0) */);

  /* Phi2 */
  pressure.phi1 = -sim->rho*Phi1;


  pressure.P1 = vector_scalar_product (&W, &fsd.gradPhi) + 0.5*vector_scalar_product (&fsd.gradPhi, &fsd.gradPhi);

  return pressure;
}

static void sppanel_linear_forces_integral_gauss_1 (SPPanel * spp,
						    Simulation * sim,
						    gpointer data,
						    gint m, gint n,
						    HeightCurve hz,
						    gdouble t,
						    gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_gauss_1 (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph1;
  gdouble wfk = wij*lp.Pfk1;
  gdouble wphi1 = wij*lp.phi1;
  gdouble wp1 = wij*lp.P1;

  f->forces_h1[0] += wh*N.x;
  f->forces_h1[1] += wh*N.y;
  f->forces_h1[2] += wh*N.z;
  
  f->forces_fk1[0] += wfk*N.x;
  f->forces_fk1[1] += wfk*N.y;
  f->forces_fk1[2] += wfk*N.z;

  f->forces_1[0] += wp1*N.x;
  f->forces_1[1] += wp1*N.y;
  f->forces_1[2] += wp1*N.z;

  f->phi1[0] += wphi1*N.x;
  f->phi1[1] += wphi1*N.y;
  f->phi1[2] += wphi1*N.z;

  /** Moments at position (0,0,0) **/
  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h1[3] += wh*x.x;
  f->forces_h1[4] += wh*x.y;
  f->forces_h1[5] += wh*x.z;

  f->forces_fk1[3] += wfk*x.x;
  f->forces_fk1[4] += wfk*x.y;
  f->forces_fk1[5] += wfk*x.z;

  f->forces_1[3] += wp1*x.x;
  f->forces_1[4] += wp1*x.y;
  f->forces_1[5] += wp1*x.z;

  f->phi1[3] += wphi1*x.x;
  f->phi1[4] += wphi1*x.y;
  f->phi1[5] += wphi1*x.z;
}

static void add_disturbance_forces_1 (Simulation * sim,
				      Forces * f,
				      gdouble t,
				      Motion m,
				      gboolean prediction)
{
  //simulation_calculate_gradients (sim);
  g_test_timer_start ();
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_time_local_flow (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);
  
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_forces_integral_gauss_1,
			  flat_sea, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = m.u1[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi1[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_1[j] += 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }



  fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}

Motion no_motion_RK4_time_integration_1  (Hull * hull,
					  Time * time,
					  Simulation * sim,
					  GSList * forces)
{
  Motion m0 = hull->m, m1 = m0;

  gdouble k1du1[6], k2du1[6], k3du1[6], k4du1[6];
  gdouble k1dx1[6], k2dx1[6], k3dx1[6], k4dx1[6];

  /* gdouble k1du2[6], k2du2[6], k3du2[6], k4du2[6]; */
  /* gdouble k1dx2[6], k2dx2[6], k3dx2[6], k4dx2[6]; */
  
  Forces f1;
  gdouble t = time->t;
  gdouble dt = time->dt;
  gint i, j;

  gsl_vector * du = gsl_vector_alloc (6);

  Forces * f0 = g_slist_last (hull->fh->f)->data;

  if (hull->mass_lu1 == NULL) {
    gsl_matrix * M = gsl_matrix_alloc (6,6);
    for ( i = 0; i < 6; i++ )
      for ( j = 0; j < 6; j++)
	gsl_matrix_set (M, i, j, /* hull->M1[j][i] */hull->M1[i][j]);
    hull->mass_lu1 = sim->lu_factorise (M);
  }

  /* if (hull->mass_lu2 == NULL) { */
  /*   gsl_matrix * M = gsl_matrix_alloc (6,6); */
  /*   for ( i = 0; i < 6; i++ ) */
  /*     for ( j = 0; j < 6; j++) */
  /* 	gsl_matrix_set (M, i, j, hull->M2[j][i]); */
  /*   hull->mass_lu2 = sim->lu_factorise (M); */
  /* } */

  if (sim->time.itime < 1)
    *f0 = forces_evaluation (hull, t, time, m0, sim, forces, FALSE);

  /* gdouble k1du5[6]; */
  /* // k1 = dt*f(t0, y0) */
  /* for ( i = 0; i < 6; i++) { */
  /*   k1du1[i] = dt*(f0->forces_1[i] + f0->forces_ext1[i] */
  /* 		   + f0->forces_h1[i] + f0->forces_fk1[i]); */
  /*   k1dx1[i] = dt*m0.u1[i]; */
  /* } */
  
  /* // k2 = dt*f(t0+dt/2, y0+k1/2.) */
  /* for ( i = 0; i < 6; i++) */
  /*   gsl_vector_set (du, i, 0.5*k1du1[i]); */

  /* sim->lu_factorised_solve (hull->mass_lu1, du); */

  /* for ( i = 0; i < 6; i++) { */
  /*   m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i); */
  /*   m1.x1[i] = m0.x1[i] + 0.5*k1dx1[i]; */
  /* } */

  f1 = forces_evaluation (hull, t+0.5*time->dt, time, m1, sim, forces, TRUE);

  /* for ( i = 0; i < 6; i++) { */
  /*   k2du1[i] = dt*(f1.forces_1[i] +f1.forces_ext1[i] */
  /* 		  + f1.forces_h1[i] + f1.forces_fk1[i]); */
  /*   k2dx1[i] = dt*m1.u1[i]; */
  /* } */
  
  /* // k3 = dt*f(t0+dt/2, y0+k2/2) */
  /* for ( i = 0; i < 6; i++ ) */
  /*   gsl_vector_set (du, i, 0.5*k2du1[i]); */

  /* sim->lu_factorised_solve (hull->mass_lu1, du); */

  /* for ( i = 0; i < 6; i++) { */
  /*   m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i); */
  /*   m1.x1[i] = m0.x1[i] + 0.5*k2dx1[i]; */
  /* } */

  f1 = forces_evaluation (hull, t+0.5*dt, time, m1, sim, forces, FALSE);

  /* for ( i = 0; i < 6; i++) { */
  /*   k3du1[i] = dt*(f1.forces_1[i] +f1.forces_ext1[i] */
  /* 		   + f1.forces_h1[i] + f1.forces_fk1[i]); */
  /*   k3dx1[i] = dt*m1.u1[i]; */
  /* } */


  /* // k4 = dt*f(t0+dt, y0+k3) */
  /* for ( i = 0; i < 6; i++ ) */
  /*   gsl_vector_set (du, i, k3du1[i]); */

  /* sim->lu_factorised_solve (hull->mass_lu1, du); */

  /* for ( i = 0; i < 6; i++) { */
  /*   m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i); */
  /*   m1.x1[i] = m0.x1[i] + k3dx1[i]; */
  /* } */

  f1 = forces_evaluation (hull, t+time->dt, time,
			    m1, sim, forces, FALSE);

  /* for ( i = 0; i < 6; i++) { */
  /*   k4du1[i] = dt*(f1.forces_1[i] + f1.forces_ext1[i] */
  /* 		   + f1.forces_h1[i] + f1.forces_fk1[i]); */
  /*   k4dx1[i] = dt*m1.u1[i]; */
  /* } */

  /* // y1 = y0 + k1/6 + k2/3 + k3/3 +k4/6 */
  /* for ( i = 0; i < 6; i++ ) */
  /*   gsl_vector_set (du, i, (k1du1[i] + 2.*k2du1[i] + 2.*k3du1[i] + k4du1[i])/6.); */

  /* sim->lu_factorised_solve (hull->mass_lu1, du); */

  /* for ( i = 0; i < 6; i++) { */
  /*   m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i); */
  /*   m1.x1[i] = m0.x1[i] + (k1dx1[i] + 2.*k2dx1[i] + 2.*k3dx1[i] + k4dx1[i])/6.; */
  /* } */

  /* gsl_vector_free (du); */

  /* motion_update_rotation_matrix_1 (&hull->m, m1.x1); */
  /* //motion_update_rotation_matrix_2 (&hull->m, m.x1, m.x2); */

  // Forces that are stored
  f1 = forces_evaluation (hull, t+time->dt, time,
			   m1, sim, forces, FALSE);

  for ( i = 0; i < 6; i++ ) {
    f1.x1[i] = m1.x1[i];
    f1.u1[i] = m1.u1[i];
  }
  
  add_force_to_history (hull->fh, f1);

  return m1;
}

Motion no_motion_ABM4_time_integration_1 (Hull * hull,
					  Time * time,
					  Simulation * sim,
					  GSList * forces)
{
  gint i = 0, j;
  gdouble t = time->t;
  gdouble dt = time->dt;
  Forces f[4];

  Motion m0 = hull->m;

  gdouble k1du1[6], k2du1[6], k3du1[6], k4du1[6];
  gdouble k1dx1[6], k2dx1[6], k3dx1[6], k4dx1[6];

  /* gdouble k1du2[6], k2du2[6], k3du2[6], k4du2[6]; */
  /* gdouble k1dx2[6], k2dx2[6], k3dx2[6], k4dx2[6]; */

  // Store relevant force history
  GSList * fl = hull->fh->f;
  while (fl) {
    f[i] = *(Forces *) fl->data;
    fl = fl->next;
    i++;
  }

  Motion m1 = m0;
  /* gsl_vector * du = gsl_vector_alloc (6); */

  /* Prediction */
  /* for ( i = 0; i < 6; i++) { */
  /*   gsl_vector_set (du, i, */
  /* 		    dt/24.*( -9.*(f[0].forces_1[i] + f[0].forces_ext1[i] */
  /* 				  + f[0].forces_h1[i] + f[0].forces_fk1[i]) */
  /* 			     + 37.*(f[1].forces_1[i] + f[1].forces_ext1[i] */
  /* 				    +  f[1].forces_h1[i] + f[1].forces_fk1[i]) */
  /* 			     - 59.*(f[2].forces_1[i] + f[2].forces_ext1[i] */
  /* 				    + f[2].forces_h1[i] + f[2].forces_fk1[i]) */
  /* 			     + 55.*(f[3].forces_1[i] + f[3].forces_ext1[i] */
  /* 				    + f[3].forces_h1[i] + f[3].forces_fk1[i]))); */
  /* } */

  /* sim->lu_factorised_solve (hull->mass_lu1, du); */

  /* for ( i = 0; i < 6; i++) { */
  /*   m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i); */
  /*   m1.x1[i] = m0.x1[i] + dt/24.*( -9.*f[0].u1[i] + 37.*f[1].u1[i] */
  /* 		       - 59.*f[2].u1[i] + 55.*f[3].u1[i] ); */
  /* } */

  /* Correction */
  Forces f4 = forces_evaluation (hull, t+time->dt, time,
				 m1, sim, forces, TRUE);

  /* for ( i = 0; i < 6; i++) { */
  /*   gsl_vector_set (du, i, */
  /* 		    dt/24.*( (f[1].forces_1[i] + f[1].forces_ext1[i] */
  /* 			      + f[1].forces_h1[i] + f[1].forces_fk1[i]) */
  /* 			     - 5.*(f[2].forces_1[i] + f[2].forces_ext1[i] */
  /* 				   + f[2].forces_h1[i] + f[2].forces_fk1[i]) */
  /* 			     + 19.*(f[3].forces_1[i] + f[3].forces_ext1[i] */
  /* 				    + f[3].forces_h1[i] + f[3].forces_fk1[i]) */
  /* 			     + 9.*(f4.forces_1[i] + f4.forces_ext1[i] */
  /* 				   + f4.forces_h1[i] + f4.forces_fk1[i]))); */
  /* } */

  /* sim->lu_factorised_solve (hull->mass_lu1, du); */

  /* for ( i = 0; i < 6; i++) { */
  /*   m1.u1[i] = m0.u1[i] + gsl_vector_get (du, i); */
  /*   m1.x1[i] = m0.x1[i] + dt/24.*( f[1].u1[i] - 5.*f[2].u1[i] */
  /* 		       + 19.*f[3].u1[i] + 9.*m1.u1[i]); */
  /* } */

  /* gsl_vector_free (du); */

  /* motion_update_rotation_matrix_1 (&hull->m, m1.x1); */
  //motion_update_rotation_matrix_2 (&hull->m, m.x1, m.x2);

  // Forces that are stored
  f4 = forces_evaluation (hull, t+time->dt, time,
			   m1, sim, forces, FALSE);

  for ( i = 0; i < 6; i++ ) {
    f4.x1[i] = m1.x1[i];
    f4.u1[i] = m1.u1[i];
  }
  
  add_force_to_history (hull->fh, f4);

  return m1;
}

void solve_no_motion_1 (Hull * hull,
			Time * time,
			Simulation * sim,
			GSList * forces)
{
  // Initialise with 3 steps of RK4
  g_assert (hull->fh);

  if (time->itime < 5)
    hull->m = no_motion_RK4_time_integration_1 (hull, time,
					     sim, forces);
  else
    hull->m = no_motion_ABM4_time_integration_1 (hull, time, sim, forces);
}

gdouble test_wigley_flow_2 (Simulation * sim)
{
  
  // Initialising of simulation
  gdouble Froude = /* 0.3 *//* 0.289 */0.3;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  20.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.001 */ 0.0001 /* 0.005/sqrt(sim->g*L) *//* 0.003 ?? */;

  sim->wp.g = 9.81;
  sim->wp.A = 0.005;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = /* 70. *//* 40 */5.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update;
  sim->fs_elevation_rhs_store = NULL;
  sim->fs_elevation_rhs_store = abm4_free_surface_elevation_disturbance_store;
  //sim->fs_elevation_update = explicit_free_surface_elevation_disturbance_update;
  
  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson
  sim->fs_potential_update = abm4_free_surface_disturbance_potential_update;
  sim->fs_potential_rhs_store = NULL;
  sim->fs_potential_rhs_store = abm4_free_surface_disturbance_potential_store;

  //  sim->fs_potential_update = explicit_free_surface_disturbance_potential_update;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = /* TRUE */FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (10 /*10*/, /* 45 */ /* 32 */25,
  								  wigley_x2,
  								  wigley_y2,
  								  wigley_z2,
  								  NULL, 3, 4, 3));
  
  
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (10, /* 45 */ /* 32 */25,
  								  wigley_x1,
  								  wigley_y1,
  								  wigley_z1,
  								  NULL, 3, 4, 3));
  

  hull_print (sim->hull, NULL);

  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Radius of domain
  sim->wp.r1 =  /* 5 */3./* 4 */;
  sim->wp.r2 =  /* 2 */1.5/* 1.5 */;
  
  sim->wp.r1_inner =  0.75;
  sim->wp.r2_inner = 0.2;

  sim->N = /* 45  *//* 10 */ /* 60 *//* 40 *//* 35 */20;
  sim->M = /* 45 */ /* 40 */ /* 85 *//* 50 *//* 40 */40;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");
 
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 3);

  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;

  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  

  
  
  solve_boundary_problem_for_basis_flow (sim);

  simulation_calculate_gradients_linear (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);

  //solve_boundary_problem_for_m_terms (sim);
  
  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tecplot  (sim->fs->s->patches, &sim->wp, sim->time.t);
  hull_print_gnuplot (sim->hull, NULL, 15, 0);

  //g_assert_not_reached ();
  // Store old value of phi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of dzPhi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
  // Store old value of dzphi
  spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
  //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow (sim);
  

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  //initialise_motion (sim);
  hull_initialise_motion (sim->hull);

  sim->forces = g_slist_append (sim->forces, add_disturbance_forces_1);  

  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffl = fopen ("fl.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffi = fopen ("fi.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    

    // Store old value of phi
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of dzPhi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
    // Store old value of dzphi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
    //spline2d_list_copy_var (simulation_all_patches_list (sim), 6, 30);

    /** Equation of motion for the hull **/
    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    // Update time
    sim->time.itime++;

     if ( sim->time.itime%1/* 5 */ == 0 ) {
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h1[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffi, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->phi1[0],
      	       f->phi1[1], f->phi1[2], f->phi1[3], f->phi1[4], f->phi1[5]);
      fflush (ffi);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext1[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    sim->time.t += sim->time.dt;

    if ( sim->time.itime%13 == 0 ) {
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      //periodic_fs_filter_variable_2 (sim->fs->s->patches->data, 9, sim->time.dt, 0.02);
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 8);
    }

    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100  == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //print_waterline (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      if ( sim->time.itime%1000  == 0 ) {
	print_free_surface_hr (sim->fs->s->patches, &sim->wp, sim->time.t);
	print_free_surface_tecplot_hr (sim->fs->s->patches, &sim->wp, sim->time.t);
      }
      //g_assert_not_reached ();
    }
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (ffk);
  fclose (ffh);
  fclose (ffl);
  fclose (ffm);
  fclose (ffext);
}

static void add_disturbance_flow_1 (Simulation * sim,
				    Forces * f,
				    gdouble t,
				    Motion m,
				    gboolean prediction)
{
  //g_test_timer_start ();
  //  simulation_calculate_gradients (sim);
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  forces_set_to_zero (f);

  whole_hull_integration (sim->hull, sim, f,
  			  sppanel_linear_forces_integral_gauss_1,
  			  flat_sea, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = m.u1[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi1[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_1[j] += 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }

}

void spline2d_print_panels_gnuplot_tmp2 (Spline2D * sp, FILE * fp, gint var)
{
  g_assert (fp != NULL);

  gdouble u, v;
  gdouble du = 0.00999999999;

  for ( u = 0; u+du < 1.; u+=du) {
    for ( v = 0; v+du < 1.; v+=du) {
      Point p = spline2d_eval_point (sp, u, v);
      Vector grad = potential_gradient_on_surface (sp, u, v, var);
      Vector N = spline2d_normal (sp, u, v);
      fprintf(fp, "%f %f %f %f %f %f %f %f %f %f\n", p.x, p.y, p.z,
	      spline2d_eval (sp, u, v, var), grad.x, grad.y, grad.z,
	      N.x, N.y, N.z);
      p = spline2d_eval_point (sp, u+du, v);
      grad = potential_gradient_on_surface (sp, u+du, v, var);
      N = spline2d_normal (sp, u+du, v);
      fprintf(fp, "%f %f %f %f %f %f %f %f %f %f \n\n", p.x, p.y, p.z,
	      spline2d_eval (sp, u+du, v, var), grad.x, grad.y, grad.z,
	      N.x, N.y, N.z);
      
      p = spline2d_eval_point (sp, u, v+du);
      grad = potential_gradient_on_surface (sp, u, v+du, var);
      N = spline2d_normal (sp, u, v+du);
      fprintf(fp, "%f %f %f %f %f %f %f %f %f %f\n", p.x, p.y, p.z,
	      spline2d_eval (sp, u, v+du, var), grad.x, grad.y, grad.z,
	      N.x, N.y, N.z);
      p = spline2d_eval_point (sp, u+du, v+du);
      grad = potential_gradient_on_surface (sp, u+du, v+du, var);
      N = spline2d_normal (sp, u+du, v+du);
      fprintf(fp, "%f %f %f %f %f %f %f %f %f %f\n\n\n", p.x, p.y, p.z,
	      spline2d_eval (sp, u+du, v+du, var), grad.x, grad.y, grad.z,
	      N.x, N.y, N.z);
    }
  }

}

void hull_print_gnuplot_tmp (Hull * h, FILE * fout, gint var, gdouble t)
{
  FILE * fp = fopen (g_strdup_printf ("hull-color_%5.4f.out", t),"w");

  g_assert ( h != NULL);

  GSList * patches = h->patches;
  while (patches) {
    fprintf(fp, "#New PAtch \n");
    Spline2D * sp = patches->data;
    while (sp) {
      g_assert (sp != NULL);
      spline2d_print_panels_gnuplot_tmp2 (sp, fp, var);
      sp = sp->next;
    }
    patches = patches->next;
  }

  fclose (fp);
}

/**
 * To reproduce the quantitative wakes of Figure 6.3 of (Scullen,1998),
 * the Froude number needs adjusting here and in spheroid.sh. And
 * spheroid.GDF should be re-generated.
 **/
static void test_spheroid_2 (Simulation * sim)
{
  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = 1.;
  sim->U.y = sim->U.z = 0.;

  sim->wp.g = sim->g = 1./L*pow(sim->U.x/Froude,2.);

  sim->wp.g = sim->g = 1.;
  L = 1./(pow (Froude, 2.));

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end = 40.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005/* 0.004/sqrt(sim->g*L) */;

  //sim->wp.g = 9.81;
  sim->wp.A = 1.;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // No forcing
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;

  // Radius of domain
  sim->wp.r1 = sim->wp.r2 = 10./* 2.5 */;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin; // Galerkin
  //sim->build_boundary_subproblem = build_boundary_subproblem_collocation;
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_rectangle_spheroid;
  sim->wp.Cs = 3/* 0 */; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = 0./* sim->wp.r/2. */; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = explicit_free_surface_elevation_disturbance_update;
  sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update;
  sim->fs_elevation_rhs_store = NULL;
  sim->fs_elevation_rhs_store = abm4_free_surface_elevation_disturbance_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  sim->fs_potential_update = explicit_free_surface_disturbance_potential_update;
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson
  sim->fs_potential_update = abm4_free_surface_disturbance_potential_update;
  sim->fs_potential_rhs_store = NULL;
  sim->fs_potential_rhs_store = abm4_free_surface_disturbance_potential_store;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp = fopen("spheroid.GDF","r");
  GSList * patches = NULL;
  

  hull_read (sim->hull, fp, 10, 10, FALSE, FALSE, FALSE, FALSE);
  fclose (fp);

  /* gdouble ratio = 0.2; */

  /* sim->hull->patches = g_slist_append (sim->hull->patches, periodic_spheroid ( 20, 20, 3, 4, 3, 1., ratio, ratio)); */

  //sim->hull->patches = g_slist_append (sim->hull->patches, spheroid_surface (20, 20));

  /* freesurface_init (fs, &sim->wp); */

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  sim->hull->wet_patches = sim->hull->patches;

  /* fs->s->b->dcb = hull_intersect_with_free_surface (sim->hull, fs->s->hz, sim->time.t, &sim->wp, sim->N); */

  /* bathymetry_init (bathy, fs->s->b->dcb, &sim->wp); */
    
  /* boundaries_init (fs->s->b, sim->time.t, &sim->wp, sim->N, sim->M); */
    
  /* boundaries_init (bathy->s->b, sim->time.t, &sim->wp, sim->N, sim->M); */
    
  /* FILE * fout = fopen ("boundaries.tmp","w"); */
  /* boundaries_print (fs->s->b, fout); */
  /* fclose (fout); */
    
  /* fout = fopen ("boundaries2.tmp","w"); */
  /* boundaries_print (bathy->s->b, fout); */
  /* fclose (fout); */
 
#if 1
  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (40, 70, spheroid_fs_x, spheroid_fs_y, NULL)); 

  Spline2D * fs_patch = fs->s->patches->data;
  fs_patch->build_fit_matrix = spline2d_build_galerkin_fit_matrix;
  fs_patch->build_fit_rhs = build_galerkin_rhs_gauss;

  FILE * fout;
  fout = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fout);
  fclose (fout);


  FILE * ff = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);
#endif
  /* Spline2D * tmpsp = fs->s->patches->data; */
  /* tmpsp->fit = tmpsp->build_fit_matrix (tmpsp); */


  /* bathy->s->patches = g_slist_append (bathy->s->patches, parametric_grid (/\* 25 *\/20, /\* 25 *\/20, spheroid_fs_x, spheroid_fs_y, NULL)); */
  /* coeff_set_var_to_constant (bathy->s->patches->data, 2, -0.5); */
  
  /* ff = fopen ("norm3.tmp","w"); */
  /* ppp = bathy->s->patches->data; */
  /* spline2d_print_normals (ppp, ff); */
  /* fclose(ff); */

  /* fout = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fout); */
  /* fclose (fout); */

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  solve_boundary_problem_for_basis_flow (sim);

#if 0
  Spline2D * tmp = sim->hull->patches->data;
  gdouble u;

  hull_print_gnuplot_tmp (sim->hull, NULL, 3, 0.);

  FILE * ftmp = fopen ("profile.tmp","w");
  for ( u = 0.; u <= 1.; u+= 0.01 ) {
    Point p = spline2d_eval_point (tmp, u, 0.);
    Vector n = spline2d_normal (tmp, u , 0);
    Vector grad = potential_gradient_on_surface (tmp, u, 0., 3); 
    fprintf (ftmp, "%f %f %f %f %f %f %f %f %f %f\n", p.x, p.y, p.z, spline2d_eval (tmp, u, 0, 3), grad.x, grad.y, grad.z, n.x, n.y, n.z);
  }
  fclose (ftmp);
  g_assert_not_reached ();
  //   spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection, sim, 7);
#endif
  simulation_calculate_gradients_linear (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  // g_assert_not_reached ();
  // Dummy matrix of inertia
  sim->hull->mg = 1.;
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 1.;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  //initialise_motion (sim);
  hull_initialise_motion (sim->hull);

  sim->forces = g_slist_append (sim->forces, add_disturbance_flow_1);

  FILE * fp_forces = fopen ("forces_spheroid.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffphi = fopen ("fphi.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull / free-surface **/
    /* Forces * f = g_malloc (sizeof(Forces)); */

    /* f = solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces); */

    /** Equation of motion for the hull **/
    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->forces_1[0], f->forces_1[1], f->forces_1[2],
	     f->forces_1[3], f->forces_1[4], f->forces_1[5]);
    fflush (ffm);

    fprintf (ffphi, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt,
	     f->phi1[0], f->phi1[1], f->phi1[2],
	     f->phi1[3], f->phi1[4], f->phi1[5]);
    fflush (ffphi);

    // Update time

    sim->time.itime++;

    /* if (sim->time.t > 1 ) { */
    /*   print_free_surface (sim->fs->s->patches, &sim->wp, 10); */
    /*   spline2d_filter_variable (sim->fs->s->patches->data, 9); */
    /*   print_free_surface (sim->fs->s->patches, &sim->wp, 11); */
    /*   g_assert_not_reached (); */
    /* } */

    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%20 == 0 ) {
      //spline2d_filter_variable (sim->fs->s->patches->data, 9);
      //spline2d_filter_variable (sim->fs->s->patches->data, 7);
      /* spline2d_filter_variable (sim->fs->s->patches->data, 18); */
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_crossection (sim->fs->s->patches->data);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    }

    //print_hull_potential (sim->hull->patches, &sim->wp, sim->time.t);
    //hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (ffm);
  fclose (ffphi);
}

void add_roll_damping_force_1  (Simulation * sim,
				Forces * f,
				gdouble t,
				Motion m,
				gboolean prediction)
{
  /*  gint d = 2; */
  /* sim->hull->m.x1[d] = 0.15*sin (sim->wp.w*t); */
  /* sim->hull->m.u1[d] = 0.15*sim->wp.w*cos (sim->wp.w*t); */
  /* m.x1[d] = 0.15*sin (sim->wp.w*t); */
  /* m.u1[d] = 0.15*sim->wp.w*cos (sim->wp.w*t); */

  f->forces_v1[3] += -0.052*sqrt(sim->hull->R[3][3]*sim->hull->M[3][3])*sim->hull->m.u1[3];
}

gdouble hull_netcdf_motion_time_local_bc_linear_nospeed_kim_1 (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Hull * hull = sim->hull;
  Motion m1 = hull->m;

  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Vector Ni = g_array_index (gp->Ni, Vector, m + n*ng);
  Point P = g_array_index (gp->Pi, Point, m + n*ng);
  Vector gradphi0;

  gradphi0.x = spline2d_eval_gauss_point (sp, gp, m, n, 32);
  gradphi0.y = spline2d_eval_gauss_point (sp, gp, m, n, 33);
  gradphi0.z = 0.;

  Vector x;
  Point xg = sim->hull->xg;
  x.x = P.x-xg.x; x.y = P.y-xg.y; x.z = P.z-xg.z;
  //x = vector_vector_product (&x, &Ni);

  gdouble N[6];
  N[0] = Ni.x;
  N[1] = Ni.y;
  N[2] = Ni.z;
  N[3] = x.y*Ni.z - x.z*Ni.y;
  N[4] = x.z*Ni.x - x.x*Ni.z;
  N[5] = x.x*Ni.y - x.y*Ni.x;

  gint i;

  // bc = sum xi_t * n + xi * m
  gdouble val = 0.;
  for ( i = 0; i < 6; i++)
    val += m1.u1[i]*N[i]; // Might be u ??

  return val /*-vector_scalar_product (&gradphi0, &Ni)*/ ;
}

void solve_netcdf_boundary_problem_for_disturbance_flow_kim_1 (Simulation * sim)
{
  // Start timer
  g_test_timer_start ();

  // Apply phin = d delta/dt.N on the hull (stored in variable 8)
  GSList * patches = /* sim->hull->patches */sim->hull->wet_patches;
  while (patches) {
    //apply_dirichlet_conditions (patches->data, minus_normal_phi0_derivative, sim, 8);
    // apply_dirichlet_conditions (patches->data, hull_motion_time_local_bc_linear_kim, sim, 8);
    apply_dirichlet_conditions (patches->data, hull_netcdf_motion_time_local_bc_linear_nospeed_kim_1, sim, 8);
    patches = patches->next;
  }

  // No need to apply the dirichlet conditions on the free surface as this
  // was done when applying the free-surface conditions and is already stored in
  // variable 7

  // Apply phin = 0 on the bathymetry (stored in variable 8)
  patches = sim->bathy->s->patches;
  while (patches) {
    coeff_set_var_to_zero (patches->data, 8);
    patches = patches->next;
  }
  
  // Get all patches of the simulation
  patches = simulation_all_patches_list (sim);
  
  // Build the rhs corresponding to the mixed problem for each subproblem
  // using the Dirichlet condition stored in variable 7 or
  // the Neumann condition stored in variable 8
  simulation_build_mixed_sub_problems_rhs (sim, 7, 8);

  // Assemble the total mixed boundary problem rhs
  boundary_problem_assemble_mixed_rhs (sim->mixed_problem, sim->sub_problems, sim);

  if (sim->continuity)
    add_mixed_continuity_conditions_rhs (sim, sim->mixed_problem, 7, 8);

  // Solve the Neumann problem using the LU method 
  sim->lu_factorised_solve (sim->mixed_lu, sim->mixed_problem->rhs);

  // Copies the solution back to the patches (stored in variable 3)
  cuda_mixed_boundary_problem_copy_solution_to_patches (patches, sim->mixed_problem,
							sim, 7, 8);

  // Stops the timer
  fprintf (stderr, "   Disturbance flow : %f \n", g_test_timer_elapsed());
}

static Pressure local_linear_netcdf_nospeed_gauss_1 (SPPanel * spp,
						     gint m, gint n,
						     Simulation * sim,
						     HeightCurve hz,
						     gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m + n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.P1 = pressure.Pfk1 = pressure.Ph1 = pressure.phi1 = 0.;

  Point p = g_array_index (gp->Pi, Point, gindex);
#if 1
  Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
#endif

  // Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  Vector gradphi0;
  gradphi0.x = gradphi0.y = gradphi0.z = 0.;

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj, iix, jjx;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble Phi1n = 0., Phi1 = 0., dPhi1du = 0., dPhi1dv = 0., eta = 0.;
  Vector gradPhi1;
 
  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    gdouble cdu = gsl_matrix_get (Bu, i, 1);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cv = gsl_matrix_get (Bv, j, 0);
      gdouble cdv = gsl_matrix_get (Bv, j, 1);
      gdouble cuv = cu*cv;
      jj = (vstart+j);

      SplineCoeffs * sc =
	g_ptr_array_index (sp->coeffs, ii + jj*NU);
      gdouble v7 = sc->v[7];

#if 1
      dPhi1du += v7*cv*cdu;
      dPhi1dv += v7*cu*cdv;
      Phi1n += sc->v[8]*cuv;
#endif

      Phi1 += v7*cuv;
      eta += sc->v[31]*cuv;
      gradphi0.x += sc->v[32]*cuv;
      gradphi0.y += sc->v[33]*cuv;
    }
  }
   
  gdouble dtphi0 = -sim->g*eta;

#if 1
  gradPhi1.x = Phi1n*N.x + c1*dPhi1du + c2*dPhi1dv;
  gradPhi1.y = Phi1n*N.y + c3*dPhi1du + c4*dPhi1dv;
  gradPhi1.z = Phi1n*N.z + c5*dPhi1du + c6*dPhi1dv;

  

  /* Hydrostatic pressure */

  // Takes FS deformation into account for hydrostatic forces
  //  pressure.Ph = -sim->rho*sim->g *( p_inertial.z -(zeta + hz(p_inertial.x, p_inertial.y, t, hz_data)));
  // Does not take FS deformation into account for hydrostatic forces
  /* pressure.Ph = -sim->rho*sim->g *( p_inertial.z - hz(p_inertial.x, p_inertial.y, t, hz_data)); */
  //pressure.Ph1 = -sim->rho*sim->g *( p_inertial.z - eta);
  // Which one should be used ??

    /* Time local /radiation forces */
  pressure.Pl = -sim->rho*vector_scalar_product (&gradphi0, &gradPhi1);
#endif

  /* Froude-Krylov forces */
  pressure.Pfk1 = -sim->rho*(dtphi0 + vector_scalar_product (&gradphi0, &gradphi0));
  //pressure.Pfk1 = -sim->rho*dtphi0;



  /* Phi2 */
  pressure.phi1 = -sim->rho*Phi1;

  return pressure;
}

static void sppanel_linear_netcdf_nospeed_forces_integral_gauss_1 (SPPanel * spp,
								   Simulation * sim,
								   gpointer data,
								   gint m, gint n,
								   HeightCurve hz,
								   gdouble t,
								   gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_netcdf_nospeed_gauss_1 (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wh = wij*lp.Ph1;
  gdouble wfk = wij*lp.Pfk1;
  gdouble wphi1 = wij*lp.phi1;
  gdouble wpl1 = wij*lp.Pl;

  f->forces_h1[0] += wh*N.x;
  f->forces_h1[1] += wh*N.y;
  f->forces_h1[2] += wh*N.z;
  
  f->forces_fk1[0] += wfk*N.x;
  f->forces_fk1[1] += wfk*N.y;
  f->forces_fk1[2] += wfk*N.z;

  f->forces_1[0] += wpl1*N.x;
  f->forces_1[1] += wpl1*N.y;
  f->forces_1[2] += wpl1*N.z;

  f->phi1[0] += wphi1*N.x;
  f->phi1[1] += wphi1*N.y;
  f->phi1[2] += wphi1*N.z;

  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);

  gdouble Cd = 1.;

  // Cross-flow forces and moments
  gdouble vcross = -sim->hull->m.u1[1] - (Pi.x-xg.x)*sim->hull->m.u1[5];
  f->forces_v1[1] += 0.25*sim->rho*vcross*fabs(vcross)*Cd*fabs(N.y)*wij;

  /** Moments at position (0,0,0) **/
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_h1[3] += wh*x.x;
  f->forces_h1[4] += wh*x.y;
  f->forces_h1[5] += wh*x.z;

  f->forces_fk1[3] += wfk*x.x;
  f->forces_fk1[4] += wfk*x.y;
  f->forces_fk1[5] += wfk*x.z;

  f->forces_1[3] += wpl1*x.x;
  f->forces_1[4] += wpl1*x.y;
  f->forces_1[5] += wpl1*x.z;

  f->phi1[3] += wphi1*x.x;
  f->phi1[4] += wphi1*x.y;
  f->phi1[5] += wphi1*x.z;

  f->forces_v1[3] += 0.25*sim->rho*vcross*fabs(vcross)*Cd*(Pi.z-xg.z)*fabs(N.y)*wij;
  f->forces_v1[5] += 0.25*sim->rho*vcross*fabs(vcross)*Cd*(Pi.x-xg.x)*fabs(N.y)*wij;
}

static Pressure local_linear_netcdf_pdstrip_gauss_1 (SPPanel * spp,
						     gint m, gint n,
						     Simulation * sim,
						     HeightCurve hz,
						     gdouble t, gpointer hz_data)
{
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;
  gint gindex = m + n*ng;
  Spline2D * sp = spp->sp;
  Pressure pressure;
  pressure.P1 = pressure.Pfk1 = pressure.Ph1 = pressure.phi1 = 0.;

  Point p = g_array_index (gp->Pi, Point, gindex);
#if 0
  Vector N = g_array_index (gp->Ni, Vector, gindex);
  Point p_inertial = spline2d_hull_eval_point_gauss_point (sp, gp, sim->hull, m, n);
  gdouble c1 = g_array_index (gp->c1, gdouble, gindex);
  gdouble c2 = g_array_index (gp->c2, gdouble, gindex);
  gdouble c3 = g_array_index (gp->c3, gdouble, gindex);
  gdouble c4 = g_array_index (gp->c4, gdouble, gindex);
  gdouble c5 = g_array_index (gp->c5, gdouble, gindex);
  gdouble c6 = g_array_index (gp->c6, gdouble, gindex);
#endif

  // Vector gradphi0  = sim->wp.wave_potential_gradient (&sim->wp, p_inertial, t);
  Vector gradphi0;
  gradphi0.x = gradphi0.y = gradphi0.z = 0.;

  /** This can still probably be improved **/
  gint  i, j, k = sp->k, ii, jj;
  gint NU = sp->periodic ? sp->NU+k-1 : sp->NU;
  gsl_matrix * Bu = g_ptr_array_index (gp->Bu, m);
  gsl_matrix * Bv = g_ptr_array_index (gp->Bv, n);
  gint ustart = sp->periodic ? gp->istart - k + 1: gp->istart;
  gint vstart = gp->jstart;

  gdouble eta = 0.;
 
  for ( i = 0; i < k; i++) {
    gdouble cu = gsl_matrix_get (Bu, i, 0);
    ii = (ustart+i);
    for ( j = 0; j < k; j++) {
      gdouble cuv = cu*gsl_matrix_get (Bv, j, 0);
      jj = (vstart+j);

      SplineCoeffs * sc =
	g_ptr_array_index (sp->coeffs, ii + jj*NU);

      eta += sc->v[31]*cuv;
      gradphi0.x += sc->v[32]*cuv;
      gradphi0.y += sc->v[33]*cuv;
    }
  }
   
  gdouble dtphi0 = -sim->g*eta;



  /* Froude-Krylov forces */
  pressure.Pfk1 = -sim->rho*(dtphi0 + vector_scalar_product (&gradphi0, &gradphi0));
  //pressure.Pfk1 = -sim->rho*dtphi0;

  return pressure;
}

static void sppanel_linear_netcdf_pdstrip_forces_integral_gauss_1 (SPPanel * spp,
								   Simulation * sim,
								   gpointer data,
								   gint m, gint n,
								   HeightCurve hz,
								   gdouble t,
								   gpointer hz_data)
{
  Forces * f = (Forces *) data;
  GaussPoints * gp = spp->outer;
  gint ng = spp->sp->nouter;

  Point xg = sim->hull->xg;

  /** Gauss Action **/
  Pressure lp = local_linear_netcdf_pdstrip_gauss_1 (spp, m, n, sim, hz, t, hz_data);
  gdouble wij = g_array_index (gp->wJij, gdouble, m + n*ng);
  Vector N = g_array_index (gp->Ni, Vector, m + n*ng);

  gdouble wfk = wij*lp.Pfk1;
  
  f->forces_fk1[0] += wfk*N.x;
  f->forces_fk1[1] += wfk*N.y;
  f->forces_fk1[2] += wfk*N.z;


  Point Pi = g_array_index (gp->Pi, Point, m + n*ng);

  gdouble Cd = 1.;

  // Cross-flow forces and moments
  gdouble vcross = -sim->hull->m.u1[1] - (Pi.x-xg.x)*sim->hull->m.u1[5];
  f->forces_v1[1] += 0.25*sim->rho*vcross*fabs(vcross)*Cd*fabs(N.y)*wij;

  /** Moments at position (0,0,0) **/
  Vector x;
  x.x = Pi.x-xg.x; x.y = Pi.y-xg.y; x.z = Pi.z-xg.z;
  x = vector_vector_product (&x, &N);

  f->forces_fk1[3] += wfk*x.x;
  f->forces_fk1[4] += wfk*x.y;
  f->forces_fk1[5] += wfk*x.z;

  f->forces_v1[3] += 0.25*sim->rho*vcross*fabs(vcross)*Cd*(Pi.z-xg.z)*fabs(N.y)*wij;
  f->forces_v1[5] += 0.25*sim->rho*vcross*fabs(vcross)*Cd*(Pi.x-xg.x)*fabs(N.y)*wij;
}

void add_full_netcdf_fk_fh_forces_1 (Simulation * sim,
				     Forces * f,
				     gdouble t,
				     Motion m,
				     gboolean prediction)
{
  Hull * hull = sim->hull;
  NetCDFForcing * ncdf = sim->ncdf;
  Point xg = sim->hull->xg;
  gdouble rho = sim->rho;
  
  g_assert (ncdf != NULL);
  
  ncdf->time = t;
    
  // Find time position
  gint it = MAX(1, ncdf->it-1);
  gdouble t1 = 0.;
  // Get time ?
  while ( it < ncdf->nt && *(ncdf->t+it-1) < t )
    it++;
    
  if ( *(ncdf->t+it-1) >= t && it > 1)
    it--;

  t1 = *(ncdf->t + it -1);


  // READ DATA IF REQUIRED
  if (ncdf->phi_1 == NULL) { // No data has ever been loaded
    ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);      
    ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
    ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);      
    ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);

    ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);      
    ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
  }
  else if (ncdf->phi_1->it != it) {
    if (ncdf->phi_2->it == it) { // Can keep half of the data and move them
      NetCDFData * tmp = ncdf->phi_1;
      tmp = ncdf->elevation_1;
      ncdf->elevation_1 = ncdf->elevation_2;
      ncdf->elevation_2 = tmp;
      tmp = ncdf->u_1;
      ncdf->u_1 = ncdf->u_2;
      ncdf->u_2 = tmp;
      tmp = ncdf->v_1;
      ncdf->v_1 = ncdf->v_2;
      ncdf->v_2 = tmp;
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
    else { // Need to read two slices
      //ncdf->phi_1 = netcdf_load_array (ncdf, ncdf->phi_1, "phi", it);
      ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);
      ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);
      ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);

      //ncdf->phi_2 = netcdf_load_array (ncdf, ncdf->phi_2, "phi", it+1);
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
  }
  g_assert (ncdf->elevation_2->it == it+1);
  g_assert (ncdf->elevation_2 != NULL);

  // Put the interpolated dt phi and elevation on the hull
  GSList * patches = /* hull->patches */hull->wet_patches;
  while ( patches ) {
    Spline2D * sp = patches->data;

    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sp, ncdf, sim->hull, sim->force_coeff);

    if (sp->fit == NULL)
      sp->fit = sp->build_fit_matrix (sp);
    
    ccs_problem_lu_solve (sp->fit, rhs->rhs_elevation);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_u);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_v);

    sp->copy_fit_solution (sp, rhs->rhs_elevation, 31);
    sp->copy_fit_solution (sp, rhs->rhs_u, 32);
    sp->copy_fit_solution (sp, rhs->rhs_v, 33);

    gsl_vector_free (rhs->rhs_elevation);
    gsl_vector_free (rhs->rhs_u);
    gsl_vector_free (rhs->rhs_v);
    g_free (rhs);

    patches = patches->next;
  }

#if 0
  if (t > 5) {
  //*** Check print ***//
  if (sim->time.itime%1000 == 0) {
    FILE * fp = fopen (g_strdup_printf ("nc_%5.4f.tmp", sim->time.t),"w");

    patches = /* hull->patches */hull->wet_patches;
    while (patches) {
      Spline2D * sptmp = patches->data;
      spline2d_print_panels_gnuplot_tmp (sptmp, fp, 31, 32, 33);
      patches = patches->next;
    }

    fclose (fp);
  }

  if (1/* sim->time.itime%1000 == 0 */) {
    /* Spline2D * grid = parametric_grid (60, 60, ggrid_x, ggrid_y, NULL); */
    sim->tmp =  parametric_grid (60, 60, grid_x, grid_y, NULL);

    /* if (grid->fit == NULL) */
    /*   grid->fit = grid->build_fit_matrix (grid); */

    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sim->tmp, ncdf, sim->hull, sim->force_coeff);

    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_elevation);
    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_u);
    ccs_problem_lu_solve (sim->tmp->fit, rhs->rhs_v);
  
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_elevation, 31);
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_u, 32);
    sim->tmp->copy_fit_solution (sim->tmp, rhs->rhs_v, 33);
  
    gsl_vector_free (rhs->rhs_elevation);
    gsl_vector_free (rhs->rhs_u);
    gsl_vector_free (rhs->rhs_v);

    g_free (rhs);

    FILE * fp = fopen (g_strdup_printf ("ncgrid_%5.4f.tmp", sim->time.t),"w");
    spline2d_print_panels_gnuplot_tmp (sim->tmp, fp, 31, 32, 33);
    fclose (fp);

    fp = fopen (g_strdup_printf ("nchull_%5.4f.tmp", sim->time.t),"w");
    spline2d_print_panels_gnuplot_tmp (hull->wet_patches->data, fp, 31, 32, 33);
    spline2d_print_panels_gnuplot_tmp (hull->wet_patches->next->data, fp, 31, 32, 33);
    fclose (fp);
    
    //spline2d_destroy (grid);
    g_assert_not_reached ();
  }
  }
#endif

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_netcdf_boundary_problem_for_disturbance_flow_kim_1 (sim);


  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_netcdf_nospeed_forces_integral_gauss_1,
			  flat_sea, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = m.u1[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi1[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_1[j]  += 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]);
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }

    // fprintf (stdout, "phi2 %f %f %f %f %f %f\n", t, f->phi2[5], phi2[3][5], phi2[2][5], phi2[1][5], phi2[0][5]);

  // For stability reasons the time-derivative part of the time-local forces is tweeked
    for ( i = 0; i < 6; i++ ) {
      for ( j = 0; j < 6; j++ ) {
	f->forces_1[i] += sim->hull->A[i][j]*a[j];
      }
    }
  }

  for ( i = 0; i < 6; i++ )
    f->forces_fk1[i] *= sim->forcing_scaling_factor;

  /* for ( i = 0; i < 2; i++ ) */
  /*   f->forces_1[i] = f->forces_h1[i] = f->forces_fk1[i] = f->forces_ext1[i] = f->forces_v1[i] = 0.; */

  /* for ( i = 3; i < 6; i++ ) */
  /*   f->forces_1[i] = f->forces_h1[i] = f->forces_fk1[i] = f->forces_ext1[i] = f->forces_v1[i] = 0.; */
  
  //f->forces_fk1[2] = 0.;

  // f->forces_h[0] = f->forces_fk[0] = f->forces_e [0] = 0.;
}

void add_pdstrip_netcdf_fk_fh_forces_1 (Simulation * sim,
					Forces * f,
					gdouble t,
					Motion m,
					gboolean prediction)
{
  int i;
  Hull * hull = sim->hull;
  NetCDFForcing * ncdf = sim->ncdf;
  Point xg = sim->hull->xg;
  gdouble rho = sim->rho;
  
  g_assert (ncdf != NULL);

  ncdf->time = fmod(t,ncdf->tmax);
    
  // Find time position
  gint it = MAX(1, (ncdf->it-1)%ncdf->nt);
  gdouble t1 = 0.;
  // Get time ?
  while ( /* it < ncdf->nt && */ *(ncdf->t+it-1) < fmod(t,ncdf->tmax) )
    it++;
    
  if ( *(ncdf->t+it-1) >= fmod(t,ncdf->tmax) && it > 1)
    it--;

  t1 = *(ncdf->t + it -1);


  // READ DATA IF REQUIRED
  if (ncdf->phi_1 == NULL) { // No data has ever been loaded
    ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);      
    ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
    ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);      
    ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);

    ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);      
    ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
  }
  else if (ncdf->phi_1->it != it) {
    if (ncdf->phi_2->it == it) { // Can keep half of the data and move them
      NetCDFData * tmp = ncdf->phi_1;
      tmp = ncdf->elevation_1;
      ncdf->elevation_1 = ncdf->elevation_2;
      ncdf->elevation_2 = tmp;
      tmp = ncdf->u_1;
      ncdf->u_1 = ncdf->u_2;
      ncdf->u_2 = tmp;
      tmp = ncdf->v_1;
      ncdf->v_1 = ncdf->v_2;
      ncdf->v_2 = tmp;
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
    else { // Need to read two slices
      //ncdf->phi_1 = netcdf_load_array (ncdf, ncdf->phi_1, "phi", it);
      ncdf->elevation_1 = netcdf_load_array (ncdf, ncdf->elevation_1, "eta", it);
      ncdf->u_1 = netcdf_load_array (ncdf, ncdf->u_1, "u", it);
      ncdf->v_1 = netcdf_load_array (ncdf, ncdf->v_1, "v", it);

      //ncdf->phi_2 = netcdf_load_array (ncdf, ncdf->phi_2, "phi", it+1);
      ncdf->elevation_2 = netcdf_load_array (ncdf, ncdf->elevation_2, "eta", it+1);
      ncdf->u_2 = netcdf_load_array (ncdf, ncdf->u_2, "u", it+1);
      ncdf->v_2 = netcdf_load_array (ncdf, ncdf->v_2, "v", it+1);
    }
  }
  g_assert (ncdf->elevation_2->it == it+1);
  g_assert (ncdf->elevation_2 != NULL);

  // Put the interpolated dt phi and elevation on the hull
  GSList * patches = /* hull->patches */hull->wet_patches;
  while ( patches ) {
    Spline2D * sp = patches->data;

    DoubleRhs * rhs = netcdf_build_linear_double_galerkin_rhs (sp, ncdf, sim->hull, sim->force_coeff);

    if (sp->fit == NULL)
      sp->fit = sp->build_fit_matrix (sp);
    
    ccs_problem_lu_solve (sp->fit, rhs->rhs_elevation);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_u);
    ccs_problem_lu_solve (sp->fit, rhs->rhs_v);

    sp->copy_fit_solution (sp, rhs->rhs_elevation, 31);
    sp->copy_fit_solution (sp, rhs->rhs_u, 32);
    sp->copy_fit_solution (sp, rhs->rhs_v, 33);

    gsl_vector_free (rhs->rhs_elevation);
    gsl_vector_free (rhs->rhs_u);
    gsl_vector_free (rhs->rhs_v);
    g_free (rhs);

    patches = patches->next;
  }


  /* if (/\* sim->time.t > 100 &&  *\/prediction == FALSE) { */
  /*   /\* FILE * fp = fopen (g_strdup_printf ("nc_%5.4f.tmp", sim->time.t),"w"); *\/ */

  /*   /\* patches = /\\* hull->patches *\\/hull->wet_patches; *\/ */
  /*   /\* while (patches) { *\/ */
  /*   /\*   Spline2D * sptmp = patches->data; *\/ */
  /*   /\*   spline2d_print_panels_gnuplot_tmp (sptmp, fp, 31, 32, 33); *\/ */
  /*   /\*   patches = patches->next; *\/ */
  /*   /\* } *\/ */

  /*   /\* fclose (fp); *\/ */

  /*   double u, v; */
  /*   double max=-12, min = 12; */
  /*   patches = /\* hull->patches *\/hull->wet_patches; */
  /*   while (patches) { */
  /*     Spline2D * sptmp = patches->data; */

  /*     for ( u = 0; u <= 1.0; u += 0.1 ) { */
  /* 	for ( v = 0; v <= 1.0; v += 0.1 ) { */
  /* 	  double val = spline2d_eval (sptmp, u, v, 31); */

  /* 	  if ( max < val ) { */
  /* 	    max =  val; */
  /* 	  } */

  /* 	  if ( val < min ) { */
  /* 	    min = val; */
  /* 	  } */
  /* 	} */
  /*     } */

  /*     patches = patches->next; */
  /*   } */

  /*   fprintf (stdout, "TT: %f %f %f \n",  sim->time.t, min, max); */
  /* } */

  /* if (sim->time.t > 500 ) { */
  /*   g_assert_not_reached (); */
  /* } */
    

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_netcdf_pdstrip_forces_integral_gauss_1,
			  flat_sea, t, &sim->wp);

  

  for ( i = 0; i < 6; i++ )
    f->forces_fk1[i] *= sim->forcing_scaling_factor;
}















gdouble test_gdf2nemoh (Simulation * sim)
{
  /* FILE * ffp = fopen("hulls/1704deck-flat-mesh-12.2.GDF","r"); */
  /* hull_read (sim->hull, ffp, 20, 10, TRUE, FALSE, TRUE, FALSE); */

  /* return 0.; */

  Hull * hull = sim->hull;
  
  //FILE * fp = fopen("hulls/1704deck-flat-mesh-12.2.GDF","r");
  //FILE * fp = fopen("1704-flat-submerged3.GDF","r");
  FILE * fp = fopen("1704B_remesh_dim.GDF","r");

  Panel p;
  char buffer[100];
  GArray * all_panels = g_array_new (FALSE, FALSE, sizeof(Panel));
  gint i, j, k;

  g_assert (fp);

  /* Skip 4 first lines */
  fgets(buffer, 100, fp);
  fgets(buffer, 100, fp);
  fgets(buffer, 100, fp);
  fgets(buffer, 100, fp);
  
  while (panel_read (&p, fp)) {
    g_array_append_val (all_panels, p);
  }

  /* Sorts the panels into patches */
  GPtrArray * patches = sort_panels (all_panels);

  fprintf (stdout, "Found %i patches\n", patches->len);
  
  int nnodes = 0, npanels = 0;
  for ( i = 0; i < patches->len; i++) {
    Patch * patch = g_ptr_array_index (patches, i);
    GArray * first_row = g_ptr_array_index (patch->rows, 0);
    
    nnodes += patch->rows->len*first_row->len;
    fprintf (stderr, "len: %i %i\n", patch->rows->len, first_row->len);
    npanels += (patch->rows->len-1)*(first_row->len-1);
  }

  fprintf (stdout, "for a total of %i panels and %i nodes \n", npanels, nnodes);
  
  FILE * fout = fopen ("nemoh.dat","w");
  FILE * fout2 = fopen ("nemoh_mesh.dat","w");

  gboolean flip_u = FALSE;
  gboolean flip_v = FALSE;
  gboolean centripetal_reparam = TRUE;
  gboolean swap = FALSE;

  
  int ii;
  for ( ii = 0; ii < patches->len ; ii++ ) {
    Patch * patch = g_ptr_array_index (patches, ii);

    GArray * row = g_ptr_array_index (patch->rows, 0);
    gint NX = swap ? patch->rows->len+1 : row->len+1;
    gint NY = swap ? row->len+1 : patch->rows->len+1;

    fprintf (stderr, "NX: %i %i\n", NX, NY);

    //Point p[NX][NY];
    Point ptmp[NX][NY];
    gint i, j, k, l;

    /* Copy data to p */
    for ( j = 0; j <  patch->rows->len; j++) {
      row = g_ptr_array_index (patch->rows, j);
      for ( i = 0; i < row->len ; i++) {
	Panel panel = g_array_index (row, Panel, i);
	if (swap)
	  ptmp[j][i] = panel.p[2];
	else
	  ptmp[i][j] = panel.p[2];
      }
    }

    for ( j = 0; j < patch->rows->len; j++) {
      row = g_ptr_array_index (patch->rows, j);
      i = row->len-1;
      Panel panel = g_array_index (row, Panel, i);
      if (swap)
	ptmp[j][row->len] = panel.p[1];
      else
	ptmp[row->len][j] = panel.p[1];
    }

    j = patch->rows->len-1;
    row = g_ptr_array_index (patch->rows, j);
    for ( i = 0; i < row->len; i++) {
      Panel panel = g_array_index (row, Panel, i);
      if (swap)
	ptmp[patch->rows->len][i] = panel.p[3];
      else
	ptmp[i][patch->rows->len] = panel.p[3];
    }

    i = row->len-1;
    Panel panel = g_array_index (row, Panel, i);
    if (swap)
      ptmp[patch->rows->len][row->len] = panel.p[0];
    else
      ptmp[row->len][patch->rows->len] = panel.p[0];

    for (  j = 0; j < NY; j++) {
    
      gboolean water = FALSE;
      for ( i = 0; i < NX; i++) {
    	if (ptmp[i][j].z < 0)
    	  water = TRUE;
      }

      if ( water == FALSE ) {
    	int a, b;
    	for ( b = j+1; b < NY; b++ ) {
    	  for ( a = 0; a < NX; a++ ) {
    	    ptmp[a][b-1]=ptmp[a][b];
    	  }
    	}
    	NY--; j--;
      }
    }


    /***********************************************************************/
    fprintf (stderr, "NX: %i %i\n", NX, NY);

    FILE * fp = fopen ("points2fit.dat","w");
    for ( i = 0; i < NX; i++) {
      for ( j = 0; j < NY; j++) {
	if ( j == 0 )
	  ptmp[i][j].y = 0.;

	if ( j == NY-1 )
	  ptmp[i][j].y = 0.;

    	fprintf (fp, "%f %f %f %i %i\n", ptmp[i][j].x, ptmp[i][j].y, ptmp[i][j].z, i, j);
      }
    }
    fclose (fp);

    //g_assert_not_reached ();

    gint NTMP = NX;
    NX = NY; NY = NTMP;
  
    Point p[NX][NY], p2[NX][NY];
    gdouble u[NX][NY], v[NX][NY];

    for ( i = 0; i < NX; i++) {
      for ( j = 0; j < NY; j++) {
	p[i][j] = ptmp[NY-1-j][i];
      }
    }

    for ( i = 0; i < NX; i++) {
      gint ii = flip_u ? NX-1-i : i;
      for ( j = 0; j < NY; j++) {
	gint jj = flip_v ? NY-1-j : j;
	p2[i][j] = p[ii][jj];
      }
    }
    // g_assert_not_reached ();

    for ( i = 0; i < NX; i++) {
      for ( j = 0; j < NY; j++) {
	p[i][j] = p2[i][j];
      
      }
    }
    
    int count;
#if 1
    fprintf (stderr, "Nodes: %i %i\n", NX*NY, (NX-1)*(NY-1));
    fprintf (stderr, "NX: %i %i\n", NX, NY);

    fprintf (fout, "                    2          1\n");

    fprintf (fout2, "%i\n%i\n", NX*NY, (NX-1)*(NY-1));

    count = 1;
    for ( i = 0; i < NX; i++ ) {
      for ( j = 0; j < NY; j++ ) {
	fprintf (fout, "\t%i\t%f\t%f\t%f\n",count++, p[i][j].x, p[i][j].y, p[i][j].z);
	fprintf (fout2, "\t%f\t%f\t%f\n",p[i][j].x, p[i][j].y, p[i][j].z);
	//fprintf (fout, "\t%i\t%g\t%g\t%g\n",count++, p[i][j].x, p[i][j].y, p[i][j].z);
      }
    }

    fprintf (fout, "             0          0.00          0.00          0.00\n");
    
    for ( i = 0; i < NX-1; i++ ) {
      for ( j = 0; j < NY-1; j++ ) {
	//fprintf (fout, "\t%i\t%i\t%i\t%i\n", j+i*(NY-1)+1, j+(i+1)*(NY-1)+1, (j+1)+(i+1)*(NY-1)+1, (j+1)+i*(NY-1)+1);
	fprintf (fout, "\t%i\t%i\t%i\t%i\n", j+i*(NY)+1, j+(i+1)*(NY)+1, (j+1)+(i+1)*NY+1, (j+1)+i*NY+1);
	fprintf (fout2, "\t%i\t%i\t%i\t%i\n", j+i*(NY)+1, j+(i+1)*(NY)+1, (j+1)+(i+1)*(NY)+1, (j+1)+i*(NY)+1);
      }
    }

    fprintf (fout, "          0          0          0          0\n");
#else

    int NX_NEW, NY_NEW;
    count = 0;
    i = 0;
    while ( i < NX ) {
      count++;
      if ( i < 5 || NX - i < 6 )
	i++;
      else
	i+=2;
    }
    NX_NEW = count;

    count = j = 0;
    while ( j < NY ) {
      count++;
      if ( NY - j == 2 )
	j++;
      else
	j+=2;
    }
    NY_NEW = count;

    Point ppp[NX_NEW][NY_NEW];
    int ix = 0, iy = 0;

    

    count = 1;
    i = ix = 0;
    while ( i < NX ) {
      j = iy = 0;
      while ( j < NY ) {
      
	//fprintf (stdout, "\t%i\t%f\t%f\t%f\n",count++, p[i][j].x, p[i][j].y, p[i][j].z);
	ppp[ix][iy] = p[i][j];

	if ( NY - j == 2 )
	  j++;
	else
	  j+=2;

	iy++;
      }


      //if ( NX - i == 2 )
      if ( i < 5 || NX - i < 6 )
	i++;
      else
	i+=2;
      ix++;
    }


    fprintf (stderr, "Nodes: %i %i\n", NX_NEW*NY_NEW, (NX_NEW-1)*(NY_NEW-1));
    fprintf (stderr, "NX: %i %i\n", NX_NEW, NY_NEW);

    fprintf (fout2, "%i\n%i\n", NX_NEW*NY_NEW, (NX_NEW-1)*(NY_NEW-1));

    fprintf (fout, "                    2          1\n");

    count = 1;
    for ( i = 0; i < NX_NEW; i++ ) {
      for ( j = 0; j < NY_NEW; j++ ) {
	fprintf (fout, "\t%i\t%f\t%f\t%f\n",count++, ppp[i][j].x, ppp[i][j].y, ppp[i][j].z);
	fprintf (fout2, "\t%f\t%f\t%f\n", ppp[i][j].x, ppp[i][j].y, ppp[i][j].z);
	//fprintf (fout, "\t%i\t%g\t%g\t%g\n",count++, p[i][j].x, p[i][j].y, p[i][j].z);
      }
    }

    fprintf (fout, "             0          0.00          0.00          0.00\n");
    
    for ( i = 0; i < NX_NEW-1; i++ ) {
      for ( j = 0; j < NY_NEW-1; j++ ) {
	fprintf (fout, "\t%i\t%i\t%i\t%i\n", j+i*(NY_NEW)+1, j+(i+1)*(NY_NEW)+1, (j+1)+(i+1)*(NY_NEW)+1, (j+1)+i*(NY_NEW)+1);
	fprintf (fout2, "\t%i\t%i\t%i\t%i\n", j+i*(NY_NEW)+1, j+(i+1)*(NY_NEW)+1, (j+1)+(i+1)*(NY_NEW)+1, (j+1)+i*(NY_NEW)+1);
	//fprintf (fout, "\t%i\t%i\t%i\t%i\n", j+i*(NY_NEW/* -1 */)+1, (j+1)+i*(NY_NEW/* -1 */)+1, (j+1)+(i+1)*NY_NEW+1, j+(i+1)*NY_NEW+1);
	//fprintf (fout2, "\t%i\t%i\t%i\t%i\n", j+i*(NY_NEW/* -1 */)+1, (j+1)+i*(NY_NEW/* -1 */)+1, (j+1)+(i+1)*NY_NEW+1, j+(i+1)*NY_NEW+1);
      }
    }

    fprintf (fout, "          0          0          0          0\n");
#endif

  }

  

  fclose (fout);
  fclose (fout2);

  /* Replace the read patches by their spline represnetation */
  for ( i = 0; i < patches->len; i++) {
    Patch * patch = g_ptr_array_index (patches, i);
    patch_destroy (patch);
    g_ptr_array_free (patches, TRUE);
  }

  fclose (fp);
}

gdouble test_floating_hull (Simulation * sim, char * argv[])
{
  FILE * flog = fopen ("floating_hull.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = /* 20. */1.;

  gint M = /* 60 *//* 65 *//* 45 *//* 60 */50/* 55 */; // radial resolution
  gint N = /* 40 *//* 40 *//* 10 *//* 35 */30/* 40 */; // azimuthal resolution
  gint MM = /* 15 *//* 15 */10; // vertical resolution of cylinder

  sim->g = 9.80665;
  sim->rho = 1025.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  1500.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.0025 *//* 0.025 */0.025;

  // Deep water dispersion relation !!!

  sim->wp.g = 9.80665;
  sim->wp.A = 1.0;
  
  sim->wp.h = 20.0;
  gdouble period = /* 20. *//* 16. *//* 25 */12.;
  period = sqrt(310/sim->wp.g)*atof(argv[1]);
  sim->wp.w = 2.*M_PI/period;
  //sim->wp.w = sqrt(sim->wp.g/310)*atof(argv[1]);
  sim->wp.k = /* solve_dispersion_relation (&sim->wp) */sim->wp.w*sim->wp.w/sim->wp.g;

  /* sim->wp.k = /\* M_PI *\/2.0; */
  /* sim->wp.w = sqrt(sim->wp.k*sim->wp.g*tanh(sim->wp.k*sim->wp.h)); */
  /* printf("Wave period: %f \n", 2.*M_PI/sim->wp.w); */
  //sim->wp.w = sqrt(sim->wp.k*sim->wp.g );
  sim->wp.cosb = cos(0./* M_PI/4 */);
  sim->wp.sinb = sin(0./* M_PI/4 */);

  //sim->time.dt = 1./200*2.*M_PI/sim->wp.w;
  //sim->time.end = 10.*2.*M_PI/sim->wp.w;

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  /* sim->wp.wave_potential = finite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = finite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = finite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative; */

  sim->wp.wave_potential = infinite_depth_wave_potential;
  sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = infinite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;  

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = /* 20. */600.;
  sim->wp.r2 = /* 20. */600.;

  sim->wp.r1_inner = 200.;
  sim->wp.r2_inner = 50.;

  sim->N = /* 50 *//* 80/2 *//* 40 */ M;
  sim->M = /* 50 *//* 80/2 *//* 90 *//* 65 */ N;


  fp = fopen("dwttanker4.GDF","r");
  hull_read (sim->hull, fp, 22 , 15, TRUE, TRUE, TRUE, FALSE);
  fclose (fp);

  /* hull_print (sim->hull, NULL); */
  /* g_assert_not_reached (); */

  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  
  // Regridding of hull to get desired number of panels
  GSList * patches_tmp = sim->hull->patches;
  sim->hull->patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, 12 /* 20 */, /* 45 */25);
    sim->hull->patches = g_slist_append (sim->hull->patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Regridding of wet hull to get desired number of panels
  patches_tmp = sim->hull->wet_patches;
  sim->hull->wet_patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old,  12 /* 20 */, /* 45 */25);
    sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Add other symmetrical hull
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));

  

  sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches,
					   spline2d_symmetrical_y (sim->hull->wet_patches->data, 0));

  // Translate hulls
  // -86 <=> Midship
  // -16. <=> Half breadth, -2. = initial distance between pier and hull
  spline2d_translate  (sim->hull->patches->data, -150., 0., 0.);
  spline2d_translate  (sim->hull->patches->next->data , -150., 0., 0.);

  spline2d_translate  (sim->hull->wet_patches->data, -150., 0., 0.);
  spline2d_translate  (sim->hull->wet_patches->next->data , -150., 0., 0.);
  
  /* spline2d_translate  (sim->hull->wet_patches->data, -86., -16.-2., 0.); */
  /* spline2d_translate  (sim->hull->wet_patches->next->data , -86., -16.-2., 0.); */

  hull_print (sim->hull, NULL);

  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  sim->hull->xg.x = /* 80.4 *//* 90.1 */8.1; // 4.55m forward of midship
  sim->hull->xg.y = /* -18. *//* -18. */0.;
  sim->hull->xg.z = -18.9+13.32; // 11.7 meters above the keel -15.15 + 11.7 =




  hull_print (sim->hull, NULL);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);


  /* sim->hull->wet_patches = sim->hull->patches; */
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  /* g_assert_not_reached (); */
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  // Bathy
  /* bathy->s->patches = g_slist_append (bathy->s->patches, spline2d_parametric_patch (MM, N, */
  /* 										    malenica_bathy_x, */
  /* 										    malenica_bathy_y, */
  /* 										    malenica_bathy_z, */
  /* 										    &sim->wp.r1, 3, 4, 3)); */

  /* fp = fopen ("norm3.tmp","w"); */
  /* spline2d_print_normals (bathy->s->patches->data, fp); */
  /* fclose(fp); */

  /* fp = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fp); */
  /* fclose (fp); */
  //g_assert_not_reached ();
  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  hull_print_gnuplot (sim->hull, NULL, 3, sim->time.t);
  // g_assert_not_reached ();


  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 
  //initialise_motion (sim);
  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow_kim (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t); */
  /* sim->U.x = 0.; */
  /* g_assert_not_reached (); */

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  /* sim->hull->xg.x = 0.; */
  /* sim->hull->xg.y = 0.; */
  /* sim->hull->xg.z = 0.; */
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  // For solid cylinder the matrix of inertia is:
  // 1/12m (3r^2+h^2)
  fprintf (flog, "MASSSSS: %e \n", sim->hull->mg);
  //sim->hull->mg = 10.;
  sim->hull->Ig[0][0] = 17*17*sim->hull->mg;
  sim->hull->Ig[1][1] = 77.5*77.5*sim->hull->mg;
  sim->hull->Ig[2][2] = 77.5*77.5*sim->hull->mg;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  hull_initialise_motion (sim->hull);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  fprintf (flog, " Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->M[i][0],
	     sim->hull->M[i][1],
	     sim->hull->M[i][2],
	     sim->hull->M[i][3],
	     sim->hull->M[i][4],
	     sim->hull->M[i][5]);
  }
  fflush (flog);

  fprintf (flog, " Restoring coeff matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->R[i][0],
	     sim->hull->R[i][1],
	     sim->hull->R[i][2],
	     sim->hull->R[i][3],
	     sim->hull->R[i][4],
	     sim->hull->R[i][5]);
  }
  fflush (flog);
  //g_assert_not_reached ();

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[2] = sqrt(9.81*5);

  /* sim->hull->m.u[5] = 0.; // Initial spin */
  /* sim->hull->m.x[5] = 0./\* M_PI/4. *\/; */

  //sim->hull->m.x1[4] = 1.;

   motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);
  
   //   sim->forces = g_slist_append (sim->forces, add_radiation_forces_1);
   sim->forces = g_slist_append (sim->forces, integrate_radiation_forces_1);
   
   //   sim->forces = g_slist_append (sim->forces, add_initial_damping_new);

   sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force_1);
  

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    /* Forces * f = g_malloc (sizeof(Forces)); */
    /* forces_set_to_zero (f); */

    /* f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces); */

    // solve_equation_of_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%10 == 0 )
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);

    

    

    if ( sim->time.itime%1 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x1[0], sim->hull->m.x1[1], sim->hull->m.x1[2],
	       sim->hull->m.x1[3], sim->hull->m.x1[4], sim->hull->m.x1[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk1[1], f->forces_fk1[2], f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext1[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

static void add_radiative_forces_wigley_1 (Simulation * sim, Forces * f,
					   gdouble t, Motion m,
					   gboolean prediction)
{
  gint aa;
  for ( aa = 0; aa < 6; aa++ ) {
    sim->hull->m.x1[aa] /* = sim->hull->m.v[aa] */ = sim->hull->m.u1[aa] = 0.;
  }

  gint d = 4;
  sim->hull->m.x1[d] = sin (sim->wp.w*t);
  /* sim->hull->m.v[d] = */ sim->hull->m.u1[d] = sim->wp.w*cos (sim->wp.w*t);

  /* update_rotation_matrix (&sim->hull->m, sim->hull->m.u, */
  /* 			  sim->hull->m.x); */
  motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);

#if 1
  //  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim_1 (sim);

  //solve_boundary_problem_for_disturbance_flow;

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss_1,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = sim->hull->m.u1[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi1[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_1[j]  = 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]) + f->forces_fk1[j];
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }
#endif
}

gdouble test_japan1704B_rao_1 (Simulation * sim,
			       char * argv[])
{
  
  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 1.;
  sim->rho = 1.;
  sim->U.x = 0./* Froude*sqrt(sim->g*L) */;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.001 */ 0.005 /* 0.005/sqrt(sim->g*L) *//* 0.003 ?? */;

  sim->wp.g = 1.;
  sim->wp.A = 1.;
  
  sim->wp.h = 5.;
  sim->wp.k = atof(argv[1]);
  sim->wp.w = sqrt(sim->wp.k*sim->wp.g);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  /* sim->wp.wave_potential = infinite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = infinite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative; */

  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;
  
  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE; // SEB was FALSE

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (15 /*15*/, /* 25 */ 25,
  								  wigley_x2,
  								  wigley_y2,
  								  wigley_z2,
  								  NULL, 3, 4, 3));
  
  
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (15 /*15*/, /* 25 */ 25,
  								  wigley_x1,
  								  wigley_y1,
  								  wigley_z1,
  								  NULL, 3, 4, 3));
  
  /* gdouble ratio = 1./6.; */
  /* sim->hull->patches = g_slist_append (sim->hull->patches, */
  /* 				       spline2d_parametric_patch (12 /\*10*\/, /\* 45 *\/ 20, */
  /* 								  half_spheroid_x2, */
  /* 								  half_spheroid_y2, */
  /* 								  half_spheroid_z2, */
  /* 								  &ratio, 3, 4, 3)); */

  /* sim->hull->patches = g_slist_append (sim->hull->patches, */
  /* 				       spline2d_parametric_patch (12 /\*10*\/, /\* 45 *\/ 20, */
  /* 								  half_spheroid_x1, */
  /* 								  half_spheroid_y1, */
  /* 								  half_spheroid_z1, */
  /* 								  &ratio, 3, 4, 3)); */

  hull_print (sim->hull, NULL);

  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Radius of domain
  sim->wp.r1 =  /*6.*/ /* 20. */ MIN(18.,MAX(4.*2.*M_PI/sim->wp.k,3.));
  sim->wp.r2 =  /* 20. */ MIN(18.,MAX(4.*2.*M_PI/sim->wp.k,3.));
  
  fprintf (stdout, "r1 %f r2 %f \n", sim->wp.r1, sim->wp.r2);
  //g_assert_not_reached ();

  sim->wp.r1_inner =  1.;
  sim->wp.r2_inner = 0.3;

  sim->N = /* 45  *//* 60 */60;
  sim->M = /* 45 */ /* 85 */85;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 3, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");
 
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 3);


  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t); */
  /* hull_print_gnuplot (sim->hull, NULL, 3, 0.); */
  /* g_assert_not_reached (); */

  /* calculate_added_mass_matrix (sim, sim->hull->xg); */

  /* gint a; */
  /* for ( a = 0; a < 6; a++) { */
  /*     fprintf (stdout, "A: %e %e %e %e %e %e\n", */
  /* 	       sim->hull->A[a][0], sim->hull->A[a][1], sim->hull->A[a][2], */
  /* 	       sim->hull->A[a][3], sim->hull->A[a][4], sim->hull->A[a][5]); */
  /* } */

  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t); */
  /* hull_print_gnuplot (sim->hull, NULL, 3, 0.); */
  /* g_assert_not_reached (); */

  //g_assert_not_reached ();

  simulation_calculate_gradients_linear (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);


  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tecplot  (sim->fs->s->patches, &sim->wp, sim->time.t);

  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  

  //initialise_motion (sim);
  hull_initialise_motion (sim->hull);
 
  sim->forces = g_slist_append (sim->forces, add_radiative_forces_wigley_1);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    if ( sim->time.itime%10 == 0 ) {
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 18);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
      /* spline2d_filter_variable (sim->hull->patches->data, 18); */
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
    }

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

    /** Equation of motion for the hull **/
    /* Forces * f = g_malloc (sizeof(Forces)); */
    /* forces_set_to_zero (f); */

    /* f = solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces); */

    //solve_equation_of_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    // Update time
    sim->time.itime++;

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x1[0], sim->hull->m.x1[1], sim->hull->m.x1[2],
	       sim->hull->m.x1[3], sim->hull->m.x1[4], sim->hull->m.x1[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk1[0],
      	       f->forces_fk1[1], f->forces_fk1[2], f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    sim->time.t += sim->time.dt;

    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100  == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
      //g_assert_not_reached ();
    }
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffm);
  fclose (ffext);
}

static void add_diffraction_forces_wigley_1 (Simulation * sim, Forces * f,
					     gdouble t, Motion m,
					     gboolean prediction)
{
  /* gint aa; */
  /* for ( aa = 0; aa < 6; aa++ ) { */
  /*   sim->hull->m.x1[aa] /\* = sim->hull->m.v[aa] *\/ = sim->hull->m.u1[aa] = 0.; */
  /* } */

  /* gint d = 4; */
  /* sim->hull->m.x1[d] = sin (sim->wp.w*t); */
  /* /\* sim->hull->m.v[d] = *\/ sim->hull->m.u1[d] = sim->wp.w*cos (sim->wp.w*t); */

  /* update_rotation_matrix (&sim->hull->m, sim->hull->m.u, */
  /* 			  sim->hull->m.x); */
  //motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);

#if 1
  //  update_rotation_matrix (&sim->hull->m, x, u);

  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  /** Time integration of free-surface condition
      for disturbance potential **/
  sim->fs_potential_update (sim, t, prediction);

  /** Solve boundary problem for disturbance potential **/
  solve_boundary_problem_for_disturbance_flow_kim_1 (sim);

  //solve_boundary_problem_for_disturbance_flow;

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);

  if (sim->fs_potential_rhs_store)
    sim->fs_potential_rhs_store (sim, t, prediction);

  // Now we have the potential at time n+1, the forces can be calculated
  whole_hull_integration (sim->hull, sim, f,
			  sppanel_linear_nospeed_forces_integral_gauss_1,
			  sim->wp.wave_elevation, t, &sim->wp);

  // Store u in order to be able to evaluate the acceleration
  gint i;
  for ( i = 0; i < 6; i++)
    f->a[i] = /* sim->hull-> */m.u1[i];

  // The dt terms of the forces are calculated using a
  // fourth order finite difference formula

  // Copy values of - rho int phi2 ds from force history
  gdouble phi1[4][6], uu[4][6], a[6];
  gdouble dt = sim->time.dt;
  gint j;
  i = 0;
  //g_assert_not_reached ();
  GSList * fl = sim->hull->fh->f;
  while (fl) {
    Forces * forces = fl->data;
    for (  j = 0; j < 6; j++ ) {
      phi1[i][j] = forces->phi1[j];
      uu[i][j] = forces->a[j];
    }
    fl = fl->next;
    i++;
  }

  // Fourth order backward estimate of the time derivative
  // (at the previous time-step for the acceleration)
  if (sim->time.itime > 4) {
    for ( j = 0; j < 6; j++ ) {
      f->forces_1[j]  = 1./(12.*dt)*(25.*f->phi1[j] - 48.*phi1[3][j] + 36.*phi1[2][j] - 16.*phi1[1][j] + 3.*phi1[0][j]) + f->forces_fk1[j];
      a[j] = 1./(12.*dt)*(25.*f->a[j] - 48.*uu[3][j] + 36.*uu[2][j] - 16.*uu[1][j] + 3.*uu[0][j]);
    }
  }
#endif
}

/**
 * Test case for the study of the waves radiated of a wigley hull.
 * Results can be compared to "Second-order steady forces on floating
 * bodies with forward speed" M. D. Ferreira, 1997, p.94 and ownwards.
 **/
gdouble test_wigley_diffraction_1 (Simulation * sim,
				   char * argv[])
{
  
  // Initialising of simulation
  gdouble Froude = 0.;
  gdouble L = 1.;

  sim->g = 1.;
  sim->rho = 1.;
  sim->U.x = 0./* Froude*sqrt(sim->g*L) */;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  50.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.001 */ 0.005 /* 0.005/sqrt(sim->g*L) *//* 0.003 ?? */;

  sim->wp.g = 1.;
  sim->wp.A = 1.;
  
  sim->wp.h = 5.;
  sim->wp.k = atof(argv[1]);
  sim->wp.w = sqrt(sim->wp.k*sim->wp.g);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
  sim->wp.wave_potential = infinite_depth_wave_potential;
  sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = infinite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative;

  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;
  
  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE; // SEB was FALSE

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;


  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (10 /*15*/, /* 45 */ 20,
  								  wigley_x2,
  								  wigley_y2,
  								  wigley_z2,
  								  NULL, 4, 4, 3));
  
  
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_parametric_patch (10, /* 45 */ 20,
  								  wigley_x1,
  								  wigley_y1,
  								  wigley_z1,
  								  NULL, 4, 4, 3));

  hull_print (sim->hull, NULL);

  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  // Radius of domain
  sim->wp.r1 =  /*6.*/ /* 20. */ MIN(18.,MAX(4.*2.*M_PI/sim->wp.k,3.));
  sim->wp.r2 =  /* 20. */ MIN(18.,MAX(4.*2.*M_PI/sim->wp.k,3.));
  
  fprintf (stdout, "r1 %f r2 %f \n", sim->wp.r1, sim->wp.r2);
  //g_assert_not_reached ();

  sim->wp.r1_inner =  1.;
  sim->wp.r2_inner = 0.3;

  sim->N = /* 45  *//* 10 */40;
  sim->M = /* 45 */ /* 40 */60;
  sim->hull->wet_patches = sim->hull->patches;
  build_free_surface (sim, 4, 4, 3);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");
 
  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection2, sim, 3);


  

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());

  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t); */
  /* hull_print_gnuplot (sim->hull, NULL, 3, 0.); */
  /* g_assert_not_reached (); */

  /* calculate_added_mass_matrix (sim, sim->hull->xg); */

  /* gint a; */
  /* for ( a = 0; a < 6; a++) { */
  /*     fprintf (stdout, "A: %e %e %e %e %e %e\n", */
  /* 	       sim->hull->A[a][0], sim->hull->A[a][1], sim->hull->A[a][2], */
  /* 	       sim->hull->A[a][3], sim->hull->A[a][4], sim->hull->A[a][5]); */
  /* } */

  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */
  /* print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t); */
  /* hull_print_gnuplot (sim->hull, NULL, 3, 0.); */
  /* g_assert_not_reached (); */

  //g_assert_not_reached ();

  simulation_calculate_gradients_linear (sim);

  sim->fs_potential_update (sim, sim->time.t, FALSE);


  print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tecplot  (sim->fs->s->patches, &sim->wp, sim->time.t);

  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

   //sphere of radius 1 and density 900
  gdouble radius = 1.;
  gdouble density = 900.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.;
  sim->hull->xg.y = 0.;
  sim->hull->xg.z = 0.;
  
  // Mass of sphere
  sim->hull->mg = 4./3.*M_PI*radius*radius*density;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] = 2./5.*sim->hull->mg*radius*radius;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  

  //initialise_motion (sim);
  hull_initialise_motion (sim->hull);
 
  sim->forces = g_slist_append (sim->forces, add_diffraction_forces_wigley_1);

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    if ( sim->time.itime%10 == 0 ) {
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 18);
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);
      //periodic_fs_filter_variable (sim->fs->s->patches->data, 7);
      /* spline2d_filter_variable (sim->hull->patches->data, 18); */
      /* spline2d_filter_variable (sim->hull->patches->data, 7); */
      /* spline2d_filter_variable (sim->hull->patches->data, 9); */
    }

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);

    /** Equation of motion for the hull **/
    /* Forces * f = g_malloc (sizeof(Forces)); */
    /* forces_set_to_zero (f); */

    /* f = solve_no_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces); */

    //solve_equation_of_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    // Update time
    sim->time.itime++;

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x1[0], sim->hull->m.x1[1], sim->hull->m.x1[2],
	       sim->hull->m.x1[3], sim->hull->m.x1[4], sim->hull->m.x1[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk1[0],
      	       f->forces_fk1[1], f->forces_fk1[2], f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    sim->time.t += sim->time.dt;

    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%100  == 0 ) {
      //spline2d_filter_variable (sim->hull->patches->data, 7);
      //spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
      //g_assert_not_reached ();
    }
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffm);
  fclose (ffext);
}

static void add_initial_damping_1704B (Simulation * sim,
				       Forces * f,
				       gdouble t,
				       Motion m,
				       gboolean prediction)
{
  gdouble period = 2*M_PI/sim->wp.w;
  gdouble t1= 12.*period; // 7 // cylinder 12
  gint i;
  gdouble strength = /* 20 */5; 

  gdouble strength_f = 20.;
  gdouble strength_m = 20;

  t1= 5.*period; //cylinder 18
  strength_f = 100; //cylinder 0.2
  gdouble strength_drift = 5000 /* 500 */;

  f->forces_ext1[0] = t < 50 ? -strength_drift*sim->hull->M1[0][0]/(period*period)*(m.u1[0]*fabs(m.u1[0])) :  -strength_drift*sim->hull->M1[0][0]/(period*period)*(m.u1[0]*fabs(m.u1[0]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[1] = t < 50 ? -strength_f*sim->hull->M1[1][1]/(period*period)*(m.u1[1]*fabs(m.u1[1])) :  -strength_f*sim->hull->M1[1][1]/(period*period)*(m.u1[1]*fabs(m.u1[1]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[2] = t < 50 ? -strength_f*sim->hull->M1[2][2]/(period*period)*(m.u1[2]*fabs(m.u1[2])) :  -strength_f*sim->hull->M1[2][2]/(period*period)*(m.u1[2]*fabs(m.u1[2]))*exp(-pow((t-50)/t1,1.5));

  t1= 5.*period; //cylinder 18
  strength_m = /* 1000 */1.; // cylinder10
  f->forces_ext1[3] = t < 50 ? -strength_m*sim->hull->M1[3][3]/(period*period)*(m.u1[3]*fabs(m.u1[3])) :  -strength_m*sim->hull->M1[3][3]/(period*period)*(m.u1[3]*fabs(m.u1[3]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[4] = t < 50 ? -strength_m*sim->hull->M1[4][4]/(period*period)*(m.u1[4]*fabs(m.u1[4])) :  -strength_m*sim->hull->M1[4][4]/(period*period)*(m.u1[4]*fabs(m.u1[4]))*exp(-pow((t-50)/t1,1.5));
  f->forces_ext1[5] = t < 50 ? -strength_m*sim->hull->M1[5][5]/(period*period)*(m.u1[5]*fabs(m.u1[5])) :  -strength_m*sim->hull->M1[5][5]/(period*period)*(m.u1[5]*fabs(m.u1[5]))*exp(-pow((t-50)/t1,1.5));
}

gdouble bathy_1704B_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  //gdouble * h = (gdouble *) data;
  return -12.2*1.25;
}

// ship.exe 70 45 15 0.1

gdouble test_1704B_rao_1 (Simulation * sim,
			  int argc,
			  char * argv[])
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = /* 20. */1.;

  // gint M = /* 60 *//* 65 *//* 45 *//* 60 */50/* 55 */; // radial resolution
  //gint N = /* 40 *//* 40 *//* 10 *//* 35 */30/* 40 */; // azimuthal resolution
  //gint MM = /* 15 *//* 15 */10; // vertical resolution of cylinder

  gint M = atof(argv[argc-4]);
  gint N = atof(argv[argc-3]);
  gint MM = atof(argv[argc-2]);

  sim->g = 9.80665;
  sim->rho = 1025.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  400.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.025;

  // Deep water dispersion relation !!!

  sim->wp.g = 9.80665;
  sim->wp.A = 1.0;
  
  sim->wp.h = 12.2*1.25; // Draft + 25%
  //gdouble period = /* 20. *//* 16. *//* 25 */3.;
  /* sim->wp.w = /\* 2.*M_PI/period *\/0.7; */
  sim->wp.w = atof(argv[argc-1]);
  sim->wp.k = solve_dispersion_relation (&sim->wp)/* sim->wp.w*sim->wp.w/sim->wp.g */;

  //sim->time.dt = M_PI/(450.*sim->wp.w);
  sim->time.end = 40.*2.*M_PI/sim->wp.w;

  fprintf (flog, "k: %f \n", sim->wp.k);
  fprintf (stdout, "k: %f \n", sim->wp.k);
  //g_assert_not_reached ();

  /* sim->wp.k = /\* M_PI *\/2.0; */
  /* sim->wp.w = sqrt(sim->wp.k*sim->wp.g*tanh(sim->wp.k*sim->wp.h)); */
  /* printf("Wave period: %f \n", 2.*M_PI/sim->wp.w); */
  //sim->wp.w = sqrt(sim->wp.k*sim->wp.g );
  sim->wp.cosb = cos(0./* M_PI/4 */);
  sim->wp.sinb = sin(0./* M_PI/4 */);

  //sim->time.dt = 1./200*2.*M_PI/sim->wp.w;
  //sim->time.end = 10.*2.*M_PI/sim->wp.w;

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;

  /* sim->wp.wave_potential = infinite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = infinite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative; */
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;  

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = 600.;
  sim->wp.r2 = 600.;

  sim->wp.r1 = sim->wp.r2 = MIN(1500.,MAX(500., 4.*2.*M_PI/sim->wp.k));

  sim->wp.r1_inner = /* 95. */98.;
  sim->wp.r2_inner = /* 30. */32;

  

  sim->N = /* 50 *//* 80/2 *//* 40 */ M;
  sim->M = /* 50 *//* 80/2 *//* 90 *//* 65 */ N;

  // Initial fit of half hull (low but sufficient number of panels)
  fp = fopen("1704deck-flat-mesh-12.2.GDF","r");
  hull_read (sim->hull, fp, 20, 10, TRUE, FALSE, TRUE, FALSE);
  fclose (fp);

  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  
  // Regridding of hull to get desired number of panels
  GSList * patches_tmp = sim->hull->patches;
  sim->hull->patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 10 */12, 25/* 20 */);
    sim->hull->patches = g_slist_append (sim->hull->patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Regridding of wet hull to get desired number of panels
  patches_tmp = sim->hull->wet_patches;
  sim->hull->wet_patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 10 */12, 25/* 20 */);
    sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Add other symmetrical hull
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));
  sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches,
					   spline2d_symmetrical_y (sim->hull->wet_patches->data, 0));

  // Translate hulls
  // -86 <=> Midship
  // -16. <=> Half breadth, -2. = initial distance between pier and hull
  spline2d_translate  (sim->hull->patches->data, -86., 0., 0.);
  spline2d_translate  (sim->hull->patches->next->data , -86., 0., 0.);
  
  spline2d_translate  (sim->hull->wet_patches->data, -86., 0., 0.);
  spline2d_translate  (sim->hull->wet_patches->next->data , -86., 0., 0.);


  hull_print (sim->hull, NULL);
  hull_print_mayavi (sim->hull, NULL);

  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  build_free_surface (sim, 3, 4, 3);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  /* sim->hull->wet_patches = sim->hull->patches; */
  /* build_free_surface (sim, 3, 4, 3); */

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  /* g_assert_not_reached (); */
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  // Bathy
  bathy->s->patches = g_slist_append (bathy->s->patches, spline2d_parametric_patch (MM, N,
  										    malenica_bathy_x,
  										    malenica_bathy_y,
  										    bathy_1704B_z,
  										    &sim->wp.r1, 3, 4, 3));

  /* fp = fopen ("norm3.tmp","w"); */
  /* spline2d_print_normals (bathy->s->patches->data, fp); */
  /* fclose(fp); */

  /* fp = fopen ("bathy.tmp", "w"); */
  /* spline2d_surface_print_grid (bathy->s, fp); */
  /* fclose (fp); */
  //g_assert_not_reached ();
  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  hull_print_gnuplot (sim->hull, NULL, 3, sim->time.t);
  // g_assert_not_reached ();


  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 
  //initialise_motion (sim);
  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow_kim (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.; //
  sim->hull->xg.y = 0.; // Symmetry
  sim->hull->xg.z = 11.12-12.2; //KG - Draft
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  // For solid cylinder the matrix of inertia is:
  // 1/12m (3r^2+h^2)
  fprintf (flog, "MASSSSS: %e \n", sim->hull->mg);
  //sim->hull->mg = 10.;
  sim->hull->Ig[0][0] = pow(0.35*32.2,2)*sim->hull->mg;
  sim->hull->Ig[1][1] = sim->hull->Ig[2][2] = pow(0.26*172,2)*sim->hull->mg;
  //sim->hull->Ig[0][0] = sim->hull->Ig[1][1] = sim->hull->mg/* 1./12.*sim->hull->mg*(3.*20.*20.+400.*400.) *//* 3 */;
  // m r^2/2
  //sim->hull->Ig[2][2] = /* 0.5* */sim->hull->mg/* *20.*20. *//* 5. */; // ??
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  hull_initialise_motion (sim->hull);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  fprintf (flog, " XG: %f %f %f \n", sim->hull->xg.x, sim->hull->xg.y, sim->hull->xg.z);

  fprintf (flog, " Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->M[i][0],
	     sim->hull->M[i][1],
	     sim->hull->M[i][2],
	     sim->hull->M[i][3],
	     sim->hull->M[i][4],
	     sim->hull->M[i][5]);
  }
  fflush (flog);

  fprintf (flog, " Restoring coeff matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->R[i][0],
	     sim->hull->R[i][1],
	     sim->hull->R[i][2],
	     sim->hull->R[i][3],
	     sim->hull->R[i][4],
	     sim->hull->R[i][5]);
  }
  fflush (flog);
  //g_assert_not_reached ();

  // Change to the initial position if required
  //sim->hull->m.x[2] = 1.;
  //sim->hull->m.u[2] = sqrt(9.81*5);

  /* sim->hull->m.u[5] = 0.; // Initial spin */
  /* sim->hull->m.x[5] = 0./\* M_PI/4. *\/; */

  //sim->hull->m.x1[4] = 1.;

   motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);
  
  //sim->forces = g_slist_append (sim->forces, add_gravity_force);
   sim->forces = g_slist_append (sim->forces, add_radiation_forces_1);
   // sim->forces = g_slist_append (sim->forces, add_fake_fk);
   sim->forces = g_slist_append (sim->forces, add_initial_damping_1704B);
   sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force_1);
  

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    /* Forces * f = g_malloc (sizeof(Forces)); */
    /* forces_set_to_zero (f); */

    /* f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces); */

    solve_equation_of_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%10 == 0 )
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);

    

    

    if ( sim->time.itime%1 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x1[0], sim->hull->m.x1[1], sim->hull->m.x1[2],
	       sim->hull->m.x1[3], sim->hull->m.x1[4], sim->hull->m.x1[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk1[1], f->forces_fk1[2], f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext1[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%100 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

gdouble test_1704B_radiation (Simulation * sim,
			      int argc,
			      char * argv[])
{
  FILE * flog = fopen ("radiation_1704B.log","w");

  g_assert (argc > 5);

  // Initialising of simulation
  gint M = atof(argv[argc-5]);//atof(argv[1]);
  gint N = atof(argv[argc-4]);
  gint MM = atof(argv[argc-3]);
  sim->d = atof(argv[argc-1]);

  fprintf (flog, "M %i N %i MM %i direction: %i argc: %i \n", M, N, MM, sim->d, argc);

  sim->g = 9.80665;
  sim->rho = 1025.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  400.;
  sim->time.iend = 1e6;
  sim->time.dt = 0.025;

  // Deep water dispersion relation !!!

  sim->wp.g = 9.80665;
  sim->wp.A = 1.0;
  
  sim->wp.h = 12.2*1.25; // Draft + 25%
  /* gdouble period = 12.; */
  /* sim->wp.w = 2.*M_PI/period; */
  sim->wp.w = atof(argv[argc-2]);
  sim->wp.k = solve_dispersion_relation (&sim->wp)/* sim->wp.w*sim->wp.w/sim->wp.g */;
  fprintf (flog, "w: %f period: %f \n", sim->wp.w, 2.*M_PI/sim->wp.w);
  //g_assert_not_reached ();
  sim->time.end = 40.*2.*M_PI/sim->wp.w;

  fprintf (flog, "k: %f \n", sim->wp.k);


  //sim->time.dt = 1./200*2.*M_PI/sim->wp.w;
  //sim->time.end = 10.*2.*M_PI/sim->wp.w;

  // Wave forcing methods
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;  

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = 600.;
  sim->wp.r2 = 600.;

  sim->wp.r1 = sim->wp.r2 = MIN(1500.,MAX(500., 4.*2.*M_PI/sim->wp.k));

  sim->wp.r1_inner = /* 95. */98.;
  sim->wp.r2_inner = /* 30. */32;

  

  sim->N = /* 50 *//* 80/2 *//* 40 */ M;
  sim->M = /* 50 *//* 80/2 *//* 90 *//* 65 */ N;

  // Initial fit of half hull (low but sufficient number of panels)
  fp = fopen("1704deck-flat-mesh-12.2.GDF","r");
  hull_read (sim->hull, fp, 20, 10, TRUE, FALSE, TRUE, FALSE);
  fclose (fp);

  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  
  // Regridding of hull to get desired number of panels
  GSList * patches_tmp = sim->hull->patches;
  sim->hull->patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 10 */12, 25/* 20 */);
    sim->hull->patches = g_slist_append (sim->hull->patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Regridding of wet hull to get desired number of panels
  patches_tmp = sim->hull->wet_patches;
  sim->hull->wet_patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 10 */12, 25/* 20 */);
    sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Add other symmetrical hull
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));
  sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches,
					   spline2d_symmetrical_y (sim->hull->wet_patches->data, 0));

  // Translate hulls
  // -86 <=> Midship
  // -16. <=> Half breadth, -2. = initial distance between pier and hull
  spline2d_translate  (sim->hull->patches->data, -86., 0., 0.);
  spline2d_translate  (sim->hull->patches->next->data , -86., 0., 0.);
  
  spline2d_translate  (sim->hull->wet_patches->data, -86., 0., 0.);
  spline2d_translate  (sim->hull->wet_patches->next->data , -86., 0., 0.);


  hull_print (sim->hull, NULL);
  hull_print_mayavi (sim->hull, NULL);

  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  build_free_surface (sim, 3, 4, 3);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  hull_print_gnuplot (sim->hull, NULL, 3, sim->time.t);
  // g_assert_not_reached ();


  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 
  //initialise_motion (sim);
  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow_kim (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  //Floating half-sphere of radius 5 and density 
  gdouble density = 1000.;

  // Initial position of center of mass
  sim->hull->xg.x = 0.; // Will be derived from centre of buoyancy
  sim->hull->xg.y = 0.; // Symmetry
  sim->hull->xg.z = 11.12-12.2; //KG - Draft
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  // Matrix of inertia is:
  // 1/12m (3r^2+h^2)
  sim->hull->Ig[0][0] = pow(0.35*32.2,2)*sim->hull->mg;
  sim->hull->Ig[1][1] = sim->hull->Ig[2][2] = pow(0.26*172,2)*sim->hull->mg;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  //  calculate_added_mass_matrix (sim, sim->hull->xg);

  /* fprintf (flog, " Added-Mass matrix: \n"); */
  /* for ( i = 0; i < 6; i++) { */
  /*   fprintf (flog,"%e %e %e %e %e %e \n", */
  /* 	     sim->hull->A[i][0], */
  /* 	     sim->hull->A[i][1], */
  /* 	     sim->hull->A[i][2], */
  /* 	     sim->hull->A[i][3], */
  /* 	     sim->hull->A[i][4], */
  /* 	     sim->hull->A[i][5]); */
  /* } */
  /* fflush (flog); */

  hull_initialise_motion (sim->hull);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  fprintf (flog, " XG: %f %f %f \n", sim->hull->xg.x, sim->hull->xg.y, sim->hull->xg.z);

  fprintf (flog, " Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->M[i][0],
	     sim->hull->M[i][1],
	     sim->hull->M[i][2],
	     sim->hull->M[i][3],
	     sim->hull->M[i][4],
	     sim->hull->M[i][5]);
  }
  fflush (flog);

  fprintf (flog, " Restoring coeff matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->R[i][0],
	     sim->hull->R[i][1],
	     sim->hull->R[i][2],
	     sim->hull->R[i][3],
	     sim->hull->R[i][4],
	     sim->hull->R[i][5]);
  }
  fflush (flog);

  motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);
  
  sim->forces = g_slist_append (sim->forces, set_ship_motion_1);
  sim->forces = g_slist_append (sim->forces, integrate_radiation_forces_1);
  

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 10 iterations
    if ( sim->time.itime%10 == 0 )
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);

    

    

    if ( sim->time.itime%15 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x1[0], sim->hull->m.x1[1], sim->hull->m.x1[2],
	       sim->hull->m.x1[3], sim->hull->m.x1[4], sim->hull->m.x1[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk1[1], f->forces_fk1[2], f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext1[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%250 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      //hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}

gdouble bathy_dwt_z (SPPanel * spp, gint m, gint n, gpointer data)
{
  //gdouble * h = (gdouble *) data;
  return -1.2*18.9;
}

gdouble test_dwttanker_rao_1 (Simulation * sim,
			      int argc,
			      char * argv[])
{
  FILE * flog = fopen ("heaving_sphere.log","w");
  // Initialising of simulation
  gdouble Froude = 0.0;
  gdouble L = 1.;

  gdouble radius = /* 20. */1.;

  // gint M = /* 60 *//* 65 *//* 45 *//* 60 */50/* 55 */; // radial resolution
  //gint N = /* 40 *//* 40 *//* 10 *//* 35 */30/* 40 */; // azimuthal resolution
  //gint MM = /* 15 *//* 15 */10; // vertical resolution of cylinder

  gint M = atof(argv[argc-4]);
  gint N = atof(argv[argc-3]);
  gint MM = atof(argv[argc-2]);

  sim->g = 9.80665;
  sim->rho = 1025.;
  sim->U.x = 0.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  400.;
  sim->time.iend = 1e6;
  sim->time.dt = /* 0.025 */0.025;

  // Deep water dispersion relation !!!

  sim->wp.g = 9.80665;
  sim->wp.A = 1.0;
  
  sim->wp.h = 1.2*18.9; // 1.2*Draft
  //gdouble period = /* 20. *//* 16. *//* 25 */3.;
  /* sim->wp.w = /\* 2.*M_PI/period *\/0.7; */
  sim->wp.w = atof(argv[argc-1]);
  sim->wp.k = solve_dispersion_relation (&sim->wp)/* sim->wp.w*sim->wp.w/sim->wp.g */;

  //sim->time.dt = M_PI/(450.*sim->wp.w);
  sim->time.end = 40.*2.*M_PI/sim->wp.w;

  fprintf (flog, "k: %f \n", sim->wp.k);
  fprintf (stdout, "k: %f \n", sim->wp.k);
  //g_assert_not_reached ();

  /* sim->wp.k = /\* M_PI *\/2.0; */
  /* sim->wp.w = sqrt(sim->wp.k*sim->wp.g*tanh(sim->wp.k*sim->wp.h)); */
  /* printf("Wave period: %f \n", 2.*M_PI/sim->wp.w); */
  //sim->wp.w = sqrt(sim->wp.k*sim->wp.g );
  sim->wp.cosb = cos(0./* M_PI/4 */);
  sim->wp.sinb = sin(0./* M_PI/4 */);

  //sim->time.dt = 1./200*2.*M_PI/sim->wp.w;
  //sim->time.end = 10.*2.*M_PI/sim->wp.w;

  // Wave forcing methods
  /* sim->wp.wave_potential = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_potential_dz_dt = zero_scalar_wave_func; */
  /* sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation = zero_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = zero_vector_wave_func; */
  /* sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func; */
  /* sim->wp.wave_normal_time_derivative = zero_vector_wave_func; */

  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;

  /* sim->wp.wave_potential = infinite_depth_wave_potential; */
  /* sim->wp.wave_potential_dt = infinite_depth_wave_potential_dt; */
  /* sim->wp.wave_potential_gradient = infinite_depth_wave_potential_gradient; */
  /* sim->wp.wave_potential_dz_dt = infinite_depth_wave_potential_dz_dt; */
  /* sim->wp.wave_potential_z_derivative_gradient = infinite_depth_wave_potential_z_derivative_gradient; */
  /* sim->wp.wave_elevation = infinite_depth_wave_elevation; */
  /* sim->wp.wave_elevation_gradient = infinite_depth_wave_elevation_gradient; */
  /* sim->wp.wave_elevation_time_derivative = infinite_depth_wave_elevation_time_derivative; */
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
 
  /** Self-influence coefficients integration method **/
  sim->self_influence_function = lachat_watson_self_influence_coefficients;

  /** Numerical beaches method **/
  sim->numerical_beaches = numerical_beaches_radiation;
  sim->wp.Cs = 3.;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_no_speed_elevation_update;
  sim->fs_elevation_rhs_store = abm4_no_speed_elevation_store;

  /** Free-surface potential advection scheme **/
  sim->fs_potential_update = abm4_no_speed_potential_update;
  sim->fs_potential_rhs_store = abm4_no_speed_potential_store;

  /** Continuity condition between hull and free-surface **/
  sim->continuity = FALSE;

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;  

  gdouble r = 20;

  // Radius of domain
  sim->wp.r1 = 800.;
  sim->wp.r2 = 800.;

  sim->wp.r1 = sim->wp.r2 = MIN(2000.,MAX(1000., 4.*2.*M_PI/sim->wp.k));

  sim->wp.r1_inner = /* 95. */230.;
  sim->wp.r2_inner = /* 30. */90;

  

  sim->N = /* 50 *//* 80/2 *//* 40 */ M;
  sim->M = /* 50 *//* 80/2 *//* 90 *//* 65 */ N;

  // Initial fit of half hull (low but sufficient number of panels)
  fp = fopen("hulls/dwttanker.GDF","r");
  hull_read (sim->hull, fp, 20, 10, TRUE, FALSE, TRUE, FALSE);
  fclose (fp);

  //  hull_generate_wet_hull (sim->hull, zero_wave_elevation, 0., &sim->wp);
  
  // Regridding of hull to get desired number of panels
  GSList * patches_tmp = sim->hull->patches;
  sim->hull->patches = NULL;
  while (patches_tmp) {
    Spline2D * old = patches_tmp->data;
    Spline2D * new = spline2d_regrid (old, /* 10 */12, 25/* 20 */);
    sim->hull->patches = g_slist_append (sim->hull->patches, new);
    patches_tmp = g_slist_remove (patches_tmp, old);
    spline2d_destroy (old);
  }

  // Regridding of wet hull to get desired number of panels
  /* patches_tmp = sim->hull->wet_patches; */
  /* sim->hull->wet_patches = NULL; */
  /* while (patches_tmp) { */
  /*   Spline2D * old = patches_tmp->data; */
  /*   Spline2D * new = spline2d_regrid (old, /\* 10 *\/12, 25/\* 20 *\/); */
  /*   sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, new); */
  /*   patches_tmp = g_slist_remove (patches_tmp, old); */
  /*   spline2d_destroy (old); */
  /* } */

  // Add other symmetrical hull
  sim->hull->patches = g_slist_append (sim->hull->patches,
  				       spline2d_symmetrical_y (sim->hull->patches->data, 0));
  /* sim->hull->wet_patches = g_slist_append (sim->hull->wet_patches, */
  /* 					   spline2d_symmetrical_y (sim->hull->wet_patches->data, 0)); */

  // Translate hulls
  // -86 <=> Midship
  // -16. <=> Half breadth, -2. = initial distance between pier and hull
  spline2d_translate  (sim->hull->patches->data, -150., 0., 0.);
  spline2d_translate  (sim->hull->patches->next->data , -150., 0., 0.);
  
  /* spline2d_translate  (sim->hull->wet_patches->data, -86., 0., 0.); */
  /* spline2d_translate  (sim->hull->wet_patches->next->data , -86., 0., 0.); */

  sim->hull->wet_patches = sim->hull->patches;

  hull_print (sim->hull, NULL);
  //hull_print_mayavi (sim->hull, NULL);

  fp = fopen ("hull_wet.out","w");
  hull_print_wet  (sim->hull, fp);
  fclose (fp);

  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  build_free_surface (sim, 3, 4, 3);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  /* sim->hull->wet_patches = sim->hull->patches; */
  /* build_free_surface (sim, 3, 4, 3); */

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  /* g_assert_not_reached (); */
  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

#if 0
  // Bathy
  bathy->s->patches = g_slist_append (bathy->s->patches, spline2d_parametric_patch (MM, N,
    										    malenica_bathy_x,
    										    malenica_bathy_y,
    										    bathy_dwt_z,
    										    &sim->wp.r1, 3, 4, 3));

  fp = fopen ("norm3.tmp","w");
  spline2d_print_normals (bathy->s->patches->data, fp);
  fclose(fp);

  fp = fopen ("bathy.tmp", "w");
  spline2d_surface_print_grid (bathy->s, fp);
  fclose (fp);
#endif
  //g_assert_not_reached ();
  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);


  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());
  
  /* sim->U.x = 1.; */
  /* solve_boundary_problem_for_basis_flow (sim); */

  sim->fs_potential_update (sim, sim->time.t, FALSE);
  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //print_free_surface_tmp (sim->fs->s->patches, &sim->wp, sim->time.t);
  //hull_print_gnuplot (sim->hull, NULL, 3, sim->time.t);
  // g_assert_not_reached ();


  // g_assert_not_reached ();
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
  // Store old value of Phi2
  spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
  // Store old value of Phi2n
  spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);
 
  //initialise_motion (sim);
  /** Solve boundary problem for disturbance potential **/
  //solve_boundary_problem_for_disturbance_flow_kim (sim);
  solve_boundary_problem_for_disturbance_flow_1 (sim);

  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  // Initial position of center of mass
  sim->hull->xg.x = 0.; //
  sim->hull->xg.y = 0.; // Symmetry
  sim->hull->xg.z = 13.32-18.9; //KG - Draft
  
  // Mass of the hull
  calculate_mass_from_position_at_rest_linear (sim->hull, sim);

  // For solid cylinder the matrix of inertia is:
  // 1/12m (3r^2+h^2)
  fprintf (flog, "MASSSSS: %e \n", sim->hull->mg);
  //sim->hull->mg = 10.;
  sim->hull->Ig[0][0] = pow(17.0,2)*sim->hull->mg;
  sim->hull->Ig[1][1] = sim->hull->Ig[2][2] = pow(77.5,2)*sim->hull->mg;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  calculate_added_mass_matrix (sim, sim->hull->xg);

  fprintf (flog, " Added-Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->A[i][0],
	     sim->hull->A[i][1],
	     sim->hull->A[i][2],
	     sim->hull->A[i][3],
	     sim->hull->A[i][4],
	     sim->hull->A[i][5]);
  }
  fflush (flog);

  hull_initialise_motion (sim->hull);

  calculate_hydrostatic_restoring_coeffs (sim->hull, sim, flat_sea, 0., NULL);

  fprintf (flog, " XG: %f %f %f \n", sim->hull->xg.x, sim->hull->xg.y, sim->hull->xg.z);

  fprintf (flog, " Mass matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->M[i][0],
	     sim->hull->M[i][1],
	     sim->hull->M[i][2],
	     sim->hull->M[i][3],
	     sim->hull->M[i][4],
	     sim->hull->M[i][5]);
  }
  fflush (flog);

  fprintf (flog, " Restoring coeff matrix: \n");
  for ( i = 0; i < 6; i++) {
    fprintf (flog,"%e %e %e %e %e %e \n",
	     sim->hull->R[i][0],
	     sim->hull->R[i][1],
	     sim->hull->R[i][2],
	     sim->hull->R[i][3],
	     sim->hull->R[i][4],
	     sim->hull->R[i][5]);
  }
  fflush (flog);

   motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);
  
  //sim->forces = g_slist_append (sim->forces, add_gravity_force);
   sim->forces = g_slist_append (sim->forces, add_radiation_forces_1);
   // sim->forces = g_slist_append (sim->forces, add_fake_fk);
   sim->forces = g_slist_append (sim->forces, add_initial_damping_1704B);
   sim->forces = g_slist_append (sim->forces, add_hydrostatic_restoring_force_1);
  

  FILE * fmotion = fopen ("motion.tmp","w");
  FILE * fu = fopen ("u.tmp","w");
  FILE * ffk = fopen ("fk.tmp","w");
  FILE * ffh = fopen ("fh.tmp","w");
  FILE * ffm = fopen ("fm.tmp","w");
  FILE * ffext = fopen ("fext.tmp","w");

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);


    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);
    // Store old value of Phi2n
    spline2d_list_copy_var (simulation_all_patches_list (sim), 8, 30);


    /** Equation of motion for the hull **/
    /* Forces * f = g_malloc (sizeof(Forces)); */
    /* forces_set_to_zero (f); */

    /* f = solve_equation_of_motion_RK4_ABM4 (sim->hull, &sim->time, sim, f, sim->forces); */

    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);
    Forces * f = g_slist_last (sim->hull->fh->f)->data;

    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    /* simulation_calculate_gradients (sim); */

    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%10 == 0 )
      periodic_fs_filter_variable (sim->fs->s->patches->data, 9);

    

    

    if ( sim->time.itime%1 == 0 ) {
      fprintf (fmotion, "%e %e %e %e %e %e %e\n",
	     sim->time.t+sim->time.dt,
	       sim->hull->m.x1[0], sim->hull->m.x1[1], sim->hull->m.x1[2],
	       sim->hull->m.x1[3], sim->hull->m.x1[4], sim->hull->m.x1[5]);
      fflush (fmotion);
      fprintf (fu, "%e %e %e %e %e %e %e\n",
      	       sim->time.t+sim->time.dt,
      	       sim->hull->m.u1[0], sim->hull->m.u1[1], sim->hull->m.u1[2],
      	       sim->hull->m.u1[3], sim->hull->m.u1[4], sim->hull->m.u1[5]);
      fflush (fu);
      fprintf (ffk, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_fk[0],
      	       f->forces_fk1[1], f->forces_fk1[2], f->forces_fk1[3], f->forces_fk1[4], f->forces_fk1[5]);
      fflush (ffk);
      fprintf (ffh, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_h[0],
      	       f->forces_h1[1], f->forces_h1[2], f->forces_h1[3], f->forces_h1[4], f->forces_h1[5]);
      fflush (ffh);
      fprintf (ffm, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_1[0],
      	       f->forces_1[1], f->forces_1[2], f->forces_1[3], f->forces_1[4], f->forces_1[5]);
      fflush (ffm);
      fprintf (ffext, " %e %e %e %e %e %e %e \n", sim->time.t+sim->time.dt, f->forces_ext1[0],
      	       f->forces_ext1[1], f->forces_ext1[2], f->forces_ext1[3], f->forces_ext1[4], f->forces_ext1[5]);
      fflush (ffext);
    }

    if ( sim->time.itime%500 == 0 ) {
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
      //print_free_surface_tecplot (sim->fs->s->patches, &sim->wp, sim->time.t);
      //hull_print_gnuplot (sim->hull, NULL, 7, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  fclose (fmotion);
  fclose (ffk);
  fclose (ffh);
  fclose (ffm);
  fclose (ffext);
  fclose (flog);
}




static void add_advection_1 (Simulation * sim,
			     Forces * f,
			     gdouble t,
			     Motion m,
			     gboolean prediction)
{
  /** Time integration of free-surface condition
      for wave elevation. **/
  sim->fs_elevation_update (sim, t, prediction);

  // Store elevation RHS (useful for predictor-corrector methods)
  if (sim->fs_elevation_rhs_store)
    sim->fs_elevation_rhs_store (sim, t, prediction);
}

gdouble explicit_advection_rhs_gauss (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;
  

  gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 18);
  Vector grad = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9);

  return zeta - sim->time.dt*vector_scalar_product (&sim->U, &grad);
}

gdouble explicit_advection_rhs_gauss_store (SPPanel * spp, gint m, gint n, gpointer data)
{
  Simulation * sim = (Simulation *) data;
  Spline2D * sp = spp->sp;
  GaussPoints * gp = spp->outer;


  //gdouble zeta = spline2d_eval_gauss_point (sp, gp, m, n, 9);
  Vector grad = potential_gradient_on_surface_gauss_point (sp, gp, m, n, 9);

  return - sim->time.dt*vector_scalar_product (&sim->U, &grad);
}

static void abm4_advection_update (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;
  fs->rhs = fs->rhs_vector (fs, fs->rhs);

  // First 4 time-steps
  if (sim->time.itime < 4) {
    fs->rhs = fs->build_fit_rhs (fs, explicit_advection_rhs_gauss, sim, NULL, NULL, fs->rhs);
    ccs_problem_lu_solve (fs->fit, fs->rhs);
    fs->copy_fit_solution (fs, fs->rhs, 9);
    return;
  }
  
  // Adam-Bashforth-Moulton method
  if (prediction) {
    // dt/24*(55 rhs4 - 59 rhs3 + 37 rhs2 - 9 rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(55.*gsl_vector_get (sim->fseu_rhs4, i)
			    - 59.*gsl_vector_get (sim->fseu_rhs3, i)
			    + 37.*gsl_vector_get (sim->fseu_rhs2, i)
			    -9.*gsl_vector_get (sim->fseu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  else {
    // dt/24*(9 rhs4 + 19 rhs3 - 5 rhs2 + rhs1)
    for ( i = 0; i < fs->rhs->size; i++) {
      gdouble val = 1./24.*(9.*gsl_vector_get (sim->fseu_rhs4, i)
			    + 19.*gsl_vector_get (sim->fseu_rhs3, i)
			    - 5.*gsl_vector_get (sim->fseu_rhs2, i)
			    + gsl_vector_get (sim->fseu_rhs1, i));
      gsl_vector_set (fs->rhs, i, val);
    }
  }
  
  ccs_problem_lu_solve (fs->fit, fs->rhs);
  fs->add_fit_solution (fs, fs->rhs, 9, 18);
}

static void abm4_advection_store (Simulation * sim, gdouble t, gboolean prediction)
{
  Spline2D * fs = sim->fs->s->patches->data;
  gint i;

  // Once prediction done rhs1 is no longer needed and the
  // new rhs should be stored or replaced by the corrected one
  if (prediction) {
    gsl_vector * fse_rhs5 = sim->fseu_rhs1;
    sim->fseu_rhs1 = sim->fseu_rhs2;
    sim->fseu_rhs2 = sim->fseu_rhs3;
    sim->fseu_rhs3 = sim->fseu_rhs4;
    sim->fseu_rhs4 = fse_rhs5;
  }

  sim->fseu_rhs4 = fs->build_fit_rhs (fs, explicit_advection_rhs_gauss_store, sim, NULL, NULL, sim->fseu_rhs4);
}


gdouble test_advection2 (Simulation * sim)
{
  //
  sim->U.x = 1.;
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  1;
  sim->time.iend = 1e6;
  sim->time.dt = 0.005;

  /** Free-surface elevation advection scheme **/
  sim->fs_elevation_update = abm4_advection_update;
  sim->fs_elevation_rhs_store = abm4_advection_store;

  FreeSurface * fs = sim->fs;
  FILE * fp;
  GSList * patches = NULL;

  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (80/* 80 */, /* 80 */80, metrix_test_grid_x, metrix_test_grid_y, NULL));

  fp = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fp);
  fclose (fp);

  fp = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, fp);
  fclose(fp);

  fprintf(stderr,"Grids done\n");

  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape_test_advection, sim, 9);
  
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  
  // Store old value of old zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
  // Store old value of zeta
  spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);

  Spline2D * sp = sim->fs->s->patches->data;

  sp->fit = sp->build_fit_matrix (sp);

  // Mass of half-sphere
  sim->hull->mg = 1;

  // For solid sphere the matrix of inertia is:
  sim->hull->Ig[0][0] = sim->hull->Ig[1][1]
    = sim->hull->Ig[2][2] =1;
  sim->hull->Ig[0][1] = sim->hull->Ig[0][2] = sim->hull->Ig[1][0] = 0.;
  sim->hull->Ig[1][2] = sim->hull->Ig[2][0] = sim->hull->Ig[2][1] = 0.;

  gint i, j;
  // Set all other matrix to zero.
  for ( i = 0; i < 3; i++ ) {
    for ( j = 0; j < 3; j++ ) {
      sim->hull->M[i][j] = sim->hull->A[i][j]
	= sim->hull->D[i][j] = sim->hull->R[i][j] = 0.;
    }
  }

  hull_initialise_motion (sim->hull);

  motion_update_rotation_matrix_1 (&sim->hull->m, sim->hull->m.x1);
  
  // Force terms
  sim->forces = g_slist_append (sim->forces, add_advection_1);

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);

    solve_no_motion_1 (sim->hull, &sim->time, sim, sim->forces);


    // Update time
    sim->time.itime++;

    /* if ( sim->time.itime%10 == 0 ) { */
    /*   print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */
    /* } */
    sim->time.t += sim->time.dt;
  }

  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
}

#if 1
int main (int argc, char * argv[]) 
{
  int c = 0;
  int cuda_dev = 0;
  int cpu_id = -1;
  gboolean verbose;

  while (c != EOF) {
    static struct option long_options[] = {
      {"cpu_id", required_argument, NULL, 'i'},
      {"cud_id", required_argument, NULL, 'c'},
      {"help", no_argument, NULL, 'h'},
      {"verbose", no_argument, NULL, 'v'},
      { NULL }
    };
    int option_index = 0;
    switch ((c = getopt_long (argc, argv, "c:i:hv",
			      long_options, &option_index))) {
    case 'c': /* number */
      cuda_dev = atoi (optarg);
      break;
    case 'i': /* number */
      cpu_id = atoi (optarg);
      break;
    case 'v': /* verbose */
      verbose = TRUE;
      break;
    case 'h': /* help */
      fprintf (stderr,
	       "Usage: ship [OPTIONS] [PARAMS]\n"
	       "Runs ship motion simulations. Options are:\n"
	       "\n"
               "  -i    --cpu_id  N   id of the CPU to use\n"
	       "  -c    --cuda_id N   id of cuda device to use (default 0)\n"
	       "  -h    --help        display this help and exit\n"
	       "\n"
	       "Reports bugs to s.delaux at metocean.co.nz\n");
      return 0; /* success */
      break;
    case '?': /* wrong options */
      fprintf (stderr, "Try `ship --help' for more information.\n");
      return 1; /* failure */
    }
  }

  if (cpu_id != -1) {
    cpu_set_t  mask;
    CPU_ZERO(&mask);
    CPU_SET(cpu_id, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
  }

  int myid, num_procs;
   /* MPI */
  /* MPI_Init (&argc, &argv); */
  /* MPI_Comm_rank(MPI_COMM_WORLD, &myid); */
  /* MPI_Comm_size(MPI_COMM_WORLD, &num_procs); */

  Simulation * sim = simulation_new ();

  /* Set stack size to unlimited */
  struct rlimit rl;
  getrlimit(RLIMIT_STACK, &rl);
  rl.rlim_cur = RLIM_INFINITY;
  int result;
  result = setrlimit(RLIMIT_STACK, &rl);


#if CUDA
  // Start CUDA framework
  g_assert (cudaSetDevice (cuda_dev) == cudaSuccess);
  CUdevice dev;
  CUcontext context;
  //  cuda_init (&dev, &context);
  sim->lu_factorise = (LUFactoriseFunc) cuda_lu_factorise;
  sim->lu_factorised_solve = (LUFactorisedSolveFunc) cuda_solve_factorised_lu;
  sim->lu_destroy = (LUDestroyFunc) cuda_lu_problem_destroy;

  // Place holder
  int * place_holder;
  g_assert ( cudaSuccess == cudaMalloc ( (void **) &place_holder, sizeof (int)));

  /* sim->lu_factorise = (LUFactoriseFunc) cuda_svd_factorise; */
  /* sim->lu_factorised_solve = (LUFactorisedSolveFunc) cuda_solve_factorised_svd; */
  /* sim->lu_destroy = (LUDestroyFunc) cuda_svd_problem_destroy; */
#endif

#if OPENCL
  opencl_init ();
  sim->lu_factorise = (LUFactoriseFunc) opencl_lu_factorise;
  sim->lu_factorised_solve = (LUFactorisedSolveFunc) opencl_solve_factorised_lu;
  sim->lu_destroy = (LUDestroyFunc) opencl_lu_problem_destroy;
#endif

#if PLASMA
  // Start PLASMA framework
  int cores = 1; // 4;
  
  if (cpu_id == -1) {
    PLASMA_Init(cores);
  }
  else {
    int * ctab = g_malloc (cores*sizeof(int));
    
    *(ctab) = cpu_id;
    gint k;
    gint index = 1;

    for (k = 0; k < cores; k++)
      if (k != cpu_id) {
	*(ctab+index) = k;
	index++;
      }

    for (k = 0; k < cores; k++)
      printf ("%i \n", *(ctab+k));

    PLASMA_Init_Affinity (cores, ctab);
  }
  sim->lu_factorise = (LUFactoriseFunc) plasma_lu_factorise;
  sim->lu_factorised_solve = (LUFactorisedSolveFunc) plasma_solve_factorised_lu;
  sim->lu_destroy = (LUDestroyFunc) plasma_lu_problem_destroy;
#endif

  //calculate_nemoh_radiation_matrix (sim, "joined_a.dat", "joined_b.dat");
  //return 0;

#if 1
  // For constant unidirectional flow
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
#endif


  //test_gdf2nemoh (sim);
  //return 0;
  /* nc_test2 (sim); */
  /* g_assert_not_reached (); */

  test_sphere (sim);
  //test_potential_spheroid (sim);
  //test_cylinder (sim);
  //test_square (sim);
  //test_star (sim);
  //test_spheroid (sim);
  //test_spheroid_in_oscillatory_flow (sim);
  //test_motion (sim);
  //test_half_sphere_in_oscillatory_flow (sim);
  
  /* Wave radiation of a hemisphere forced in surge/heave */
  //test_hulme_sphere (sim);
  /* Wave radiation of a half-spheroid forced in
     surge/heave/sway/pitch/roll/yaw */
  
  //test_mousavizadegan_spheroid (sim);
  return 0;
  //test_wigley_diffraction (sim, argv);
  //test_wigley_diffraction_1 (sim, argv);
  //test_wigley_radiation_1 (sim, argv);
  /* */
  //test_spheroid_wu (sim);
  /* Wave diffraction of a bottom mounted cylinder in finite depth */
  
  //test_nemoh_spec_1 (sim, argc, argv);
  //test_pdstrip_1 (sim);
  //test_pdstrip_spec_1 (sim, argc, argv);
  //g_assert_not_reached ();
  //test_torsion_2 (sim);
  //test_heaving_sphere2 (sim);
  //test_floating_cylinder (sim);
  //test_1704B_rao_1 (sim, argc, argv);
  //test_1704B_radiation (sim, argc, argv);
  //test_dwttanker_rao_1 (sim, argc, argv);
  //test_spheroid_2 (sim);
  //test_wigley_flow_2 (sim);
  //  test_maccamy (sim);
  //test_maccamy (sim);
  //test_malenica (sim);
  //test_moses (sim);
  //test_half_sphere (sim);
  //test_motion (sim);
  //test_motion_potential (sim);
  //test_ship_motion_potential (sim);
  /* Test for equation of motion alone */
  //test_gyro (sim);
  /* Test for equation of motion alone */
  //test_torsion (sim);
  //test_hull (sim);
  /* Test for advection scheme alone */
  //test_advection (sim);
  //test_propagation (sim);
  /*  */
  //test_heaving_sphere (sim);
  //test_heaving_sphere_implicit (sim);
  //test_heaving_hull (sim);
  
  //test_advection2 (sim);
  //test_floating_hull (sim, argv);
  //test_oscillating_sphere (sim);
  //test_oscillating_sphere2 (sim);
  //test_radiation (sim);
  //test_radiation_hull (sim);
  //test_time_local_flow (sim);
  //test_seb (sim);
  /* test_wamit (); */
  //test_basis_flow (sim);
  //test_wigley_flow (sim);
  //test_s60_flow (sim);
  //test_rocking_hull (sim);
  //return 0;

  // Initialising of simulation
  gdouble Froude = 0.4;
  gdouble L = 1.;

  sim->g = 9.81;
  sim->rho = 1000.;
  sim->U.x = Froude*sqrt(sim->g*L);
  sim->U.y = sim->U.z = 0.;

  // Time loop
  sim->time.itime = 0;
  sim->time.t = 0;
  sim->time.end =  M_PI/* 2. */;
  sim->time.iend = 1e6;
  sim->time.dt = 0.01/sqrt(sim->g*L);

  sim->wp.g = 9.81;
  sim->wp.A = 1.;
  sim->wp.w = 2.;
  sim->wp.h = 5.;
  sim->wp.k = solve_dispersion_relation (&sim->wp);
  sim->wp.cosb = cos(0.);
  sim->wp.sinb = sin(0.);

  // Wave forcing methods
#if 1
  // For constant unidirectional flow
  sim->wp.wave_potential = zero_scalar_wave_func;
  sim->wp.wave_potential_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_gradient = zero_vector_wave_func;
  sim->wp.wave_potential_dz_dt = zero_scalar_wave_func;
  sim->wp.wave_potential_z_derivative_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation = zero_wave_elevation;
  sim->wp.wave_elevation_gradient = zero_vector_wave_func;
  sim->wp.wave_elevation_time_derivative = zero_scalar_wave_func;
  sim->wp.wave_normal_time_derivative = zero_vector_wave_func;
#endif
#if 0
  // For monochronatic finite-depth forcing
  sim->wp.wave_potential = finite_depth_wave_potential;
  sim->wp.wave_potential_dt = finite_depth_wave_potential_dt;
  sim->wp.wave_potential_gradient = finite_depth_wave_potential_gradient;
  sim->wp.wave_potential_dz_dt = finite_depth_wave_potential_dz_dt;
  sim->wp.wave_potential_z_derivative_gradient = finite_depth_wave_potential_z_derivative_gradient;
  sim->wp.wave_elevation = finite_depth_wave_elevation;
  sim->wp.wave_elevation_gradient = finite_depth_wave_elevation_gradient;
  sim->wp.wave_elevation_time_derivative = finite_depth_wave_elevation_time_derivative;
  sim->wp.wave_normal_time_derivative = finite_depth_wave_normal_time_derivative;
#endif

  // Radius of domain
  /* sim->wp.r = /\* 10. *\/2.5; */
  sim->wp.r1 = /* 10. */3.;
  sim->wp.r2 = /* 10. */3.;
  
  /** Boundary problem method **/
  sim->build_boundary_subproblem = build_boundary_subproblem_galerkin;
  // sim->build_boundary_subproblem = build_boundary_subproblem_collocation;

  /** Self-influence coefficients integration method **/
  sim->self_influence_function = rong_self_influence_coefficients;
  //sim->self_influence_function = lachat_watson_self_influence_coefficients;
  // sim->self_influence_function = wamit_self_influence_coefficients;
  //sim->self_influence_function = wamit_self_influence_coefficients_cauchy;
  // sim->self_influence_function = centered_wamit_self_influence_coefficients;

  /** Numerical beaches method **/
  //sim->numerical_beaches = numerical_beaches_rectangle;
  sim->numerical_beaches = numerical_beaches_circle;
  //sim->numerical_beaches = NULL;
  sim->wp.Cs = 30.; // Overall cooling strength (for numerical beaches)
  sim->wp.Cw = /* sim->wp.r */1./2.; // Width of the damping region

  /** Free-surface elevation advection scheme **/
  //sim->fs_elevation_update = abm4_free_surface_elevation_disturbance_update; // DOES NOT SEEM TO WORK
  sim->fs_elevation_update = leapfrog_free_surface_elevation_disturbance_update;
  //sim->fs_elevation_update = explicit_free_surface_elevation_disturbance_update;
  //sim->fs_elevation_update = explicit_free_surface_elevation_disturbance_update_greville;
  // sim->fs_elevation_update = semi_implicit_free_surface_elevation_disturbance_update_greville;

  /** Free-surface potential advection scheme **/
  // sim->fs_potential_update = abm4_free_surface_disturbance_potential_update; // DOES NOT SEEM TO WORK
  sim->beta = 0.5; // Implicitness of semi-implicit scheme 0.5 = Cranck-Nicholson
  //sim->beta = 1.;  // Implicit scheme
  sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update_periodic;
  // sim->fs_potential_update = semi_implicit_free_surface_disturbance_potential_update;
  //sim->fs_potential_update = explicit_free_surface_disturbance_potential_update;
  //sim->fs_potential_update = explicit_free_surface_disturbance_potential_update_greville;
  

  //test_sphere (sim);
  //test_potential_spheroid (sim);
  //test_cylinder (sim);
  //test_square (sim);
  //test_star (sim);
  //test_spheroid (sim);
  //test_spheroid_in_oscillatory_flow (sim);
  //test_motion (sim);
  //test_half_sphere_in_oscillatory_flow (sim);
  g_assert_not_reached ();

  FreeSurface * fs = sim->fs;
  Bathymetry * bathy = sim->bathy;
  FILE * fp;
  GSList * patches = NULL;
  
  fp = fopen("S60-panel-2.GDF","r");
  /* /\* FILE *  *\/fp = fopen("S60-panel-4.GDF","r"); */
  /* FILE *  *//* fp = fopen("rectangular-hull.GDF","r"); */
  //fp = fopen("cylinder1.GDF","r");
  //fp = fopen("sphere.GDF","r");
  // fp = fopen("square.GDF","r");
  // fp = fopen("plate.GDF","r");
  // fp = fopen("sphere_wall.GDF","r");
  // fp = fopen("spheroid.GDF","r");
  //fp = fopen("spheroid.GDF","r");
  //fp = fopen("wigley.GDF","r");
  //fp = fopen("half_sphere.GDF","r");




  //g_test_timer_start ();
  //hull_read (sim->hull, fp, 3, /* sim->N/2 */3, FALSE, FALSE, FALSE, FALSE);
  // /* sim->hull->patches = g_ptr_array_new (); */
  sim->hull->patches = g_slist_append (sim->hull->patches, periodic_spheroid_surface (15, sim->N));
  //sim->hull->patches = cylinder_surface (20, 20);
  //flat_domain (sim->hull);
  fclose (fp);

  //sim->hull->patches = g_slist_append (sim->hull->patches, parametric_grid (30, 45, wigleyfs_x1, wigleyfs_y1, fs->s));
  //sim->hull->patches = g_slist_append (sim->hull->patches, parametric_grid (30, 45, wigleyfs_x2, wigleyfs_y2, fs->s));

  freesurface_init (fs, &sim->wp);

  hull_print (sim->hull, NULL);

  
  
  fp = fopen ("normals.tmp","w");
  g_assert ( sim->hull->patches);
  patches = sim->hull->patches;
  while (patches) {
    spline2d_print_normals (patches->data, fp);
    patches = patches->next;
  }
  fclose (fp);

  //g_assert_not_reached ();


  fs->s->b->dcb = hull_intersect_with_free_surface (sim->hull, fs->s->hz, sim->time.t, &sim->wp, sim->N);

  bathymetry_init (bathy, fs->s->b->dcb, &sim->wp);
    
  boundaries_init (fs->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  boundaries_init (bathy->s->b, sim->time.t, &sim->wp, sim->N, sim->M);
    
  FILE * fout = fopen ("boundaries.tmp","w");
  boundaries_print (fs->s->b, fout);
  fclose (fout);
    
  fout = fopen ("boundaries2.tmp","w");
  boundaries_print (bathy->s->b, fout);
  fclose (fout);
    
  // surface_generate_grid (fs->s, FALSE);
  //spline2d_discretize_free_surface (fs->s->patches->data, &sim->wp, sim->time.t);

  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid2 (sim->M, sim->N, testfs_x2, testfs_y2, fs->s));
  //spline2d_discretize_free_surface (fs->s->patches->data, &sim->wp, sim->time.t);

  /* fs->s->patches = g_slist_append (fs->s->patches, rectangular_grid (sim->M, sim->N)); */

  //fs->s->patches = g_slist_append (fs->s->patches, rectangular_grid (120, 80));
  // spline2d_build_galerkin_fit_matrix (fs->s->patches->data);
  //fs->s->patches = g_slist_append (fs->s->patches, rectangular_grid (50, 50));
  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (30, 60, circular_x, circular_y, NULL));

  // fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (20, 40, circular_x, circular_y, NULL));

  // fs->s->patches = g_slist_append (fs->s->patches, parametric_grid2 (55, 80, circular_x2, circular_y2, NULL));
  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid2 (30, 50, circular_x2, circular_y2, NULL));
  // fs->s->patches = g_slist_append (fs->s->patches, parametric_grid2 (30, 50, wigley_x2, wigley_y2, NULL));

  //fs->s->patches = g_slist_append (fs->s->patches, parametric_grid3 (sim->M, sim->N, wild_grid_x, wild_grid_y, fs->s));

  //  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (sim->M, sim->N, wigleyfs_x1, wigleyfs_y1, fs->s));
     
  //  fs->s->patches = g_slist_append (fs->s->patches, parametric_grid (sim->M, sim->N, wigleyfs_x2, wigleyfs_y2, fs->s));


  
  /* Spline2D * sptmp = fs->s->patches->data; */
  /* sptmp->noflux = FALSE; */

  //fs->s->patches = g_slist_append (fs->s->patches, rectangular_grid (80, 60));
  //fs->s->patches = g_slist_append (fs->s->patches, rectangular_grid (30, 30));
  //fs->s->patches = g_slist_append (fs->s->patches, rectangular_grid (80, 80));

  fout = fopen ("grid.tmp", "w");
  spline2d_surface_print_grid (fs->s, fout);
  fclose (fout);


  FILE * ff = fopen ("norm2.tmp","w");
  Spline2D * ppp = fs->s->patches->data;
  spline2d_print_normals (ppp, ff);
  fclose(ff);

  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();
  surface_generate_grid (bathy->s, TRUE);

  spline2d_discretize_bathymetry (bathy->s->patches->data, &sim->wp, sim->time.t);
  fout = fopen ("bathy.tmp", "w");
  spline2d_surface_print_grid (bathy->s, fout);
  fclose (fout);

  //g_assert_not_reached ();

  ff = fopen ("norm3.tmp","w");
  spline2d_print_normals (bathy->s->patches->data, ff);
  fclose(ff);

  fprintf(stderr,"Grids done\n");


  simulation_set_to_zero (sim);

  spline_numbering (simulation_all_patches_list (sim));

  simulation_build_galerkin_fit_matrixes (sim);

  g_test_timer_start ();
  simulation_build_problems (sim);
  fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed());


  /* coeff_set_var_to_zero (sim->hull->patches->data, 9); */
  /* coeff_set_var_to_zero (sim->hull->patches->data, 7); */

  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //spline2d_fit_greville_border (fs->s->patches->data, numerical_beaches, &sim->wp, 9);

  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //g_assert_not_reached ();
  // coeff_set_var_to_zero (sim->hull->patches->data, 9);
  

  //  spline2d_fit_greville_border (fs->s->patches->data, gaussian_shape, sim, 9);
  
  /* spline2d_fit_greville (fs->s->patches->data, gaussian_shape2, sim, 7); */
  /* spline2d_fit_greville (fs->s->patches->data, gaussian_shape2, sim, 9); */


  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape3, sim, 7);
  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape3, sim, 9);

  //spline2d_fit_galerkin (fs->s->patches->data, gaussian_shape, sim, 9);
  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  /* g_assert_not_reached (); */


  solve_boundary_problem_for_basis_flow (sim);

  calculate_added_mass_matrix (sim, sim->hull->xg);

  solve_boundary_problem_for_m_terms (sim);



  //print_potential_spheroid (sim->hull->patches);
  //print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  //print_potential_gauss (sim->hull->patches);
  //g_assert_not_reached ();
  //  hull_print_gnuplot (sim->hull, NULL, 3);
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
  print_free_surface_tmp (sim->hull->patches, &sim->wp, sim->time.t);

  g_assert_not_reached ();
  

  while (sim->time.t < sim->time.end && sim->time.itime < sim->time.iend) {

    fprintf (stdout, "Time-step: %i Time: %f \n", sim->time.itime, sim->time.t);

    /* if (sim->time.t < 0.1) */
    /*   sim->time.dt = sim->time.dt = 0.002/sqrt(sim->g*L); */
    /* else */
      sim->time.dt = sim->time.dt = 0.001/sqrt(sim->g*L);

    // New geometry / regrid

    /* Build boundary problem matrixes */
    /* g_test_timer_start (); */
    /* simulation_build_problems (sim); */
    /* fprintf (stdout, "simulation_build_problems: %f \n", g_test_timer_elapsed()); */
    
    // Store old value of phi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 5, 12);
    // Store old value of old zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 18, 22);
    // Store old value of zeta
    spline2d_list_copy_var (simulation_all_patches_list (sim), 9, 18);
    // Store old value of dzPhi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 14, 20);
    // Store old value of dzphi
    spline2d_list_copy_var (simulation_all_patches_list (sim), 16, 21);
    // Store old value of Phi2
    spline2d_list_copy_var (simulation_all_patches_list (sim), 7, 23);

    /** Solve boundary problem for basis flow **/
    //solve_boundary_problem_for_basis_flow (sim);    

    /** Solve boundary problem for basis flow time derivative **/
    //solve_boundary_problem_for_basis_flow_time_derivatives (sim);

    /** Solve boundary problem for local flow **/
    //solve_boundary_problem_for_time_local_flow (sim);

    /** Equation of motion for the hull **/


    /** Calculates important and stores gradient quantity for
        free-surface kinematic and dynamic condition equations. **/
    simulation_calculate_gradients (sim);

    /** Time integration of free-surface condition
        for wave elevation. **/
    sim->fs_elevation_update (sim, sim->time.t, FALSE);

    /** Time integration of free-surface condition
        for disturbance potential **/
    sim->fs_potential_update (sim, sim->time.t, FALSE);

    /** Solve boundary problem for disturbance potential **/
    solve_boundary_problem_for_disturbance_flow (sim);

    /* print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */
    /* g_assert_not_reached (); */
    
    /** Calculate forces **/
    /* Forces f =  wet_hull_pressure_force_integration (sim->hull, sim, fs->s->hz, sim->time.t, &sim->wp); */
    /* Simulation */
      
    // Update ???
    // simulation_destroy_problems (sim);

    // Clear the self-influence coefficients for the free-surface
    // as it will change shape at the next time-step
    /* if (sim->fs->s->patches) { */
    /*   spline2d_clear_self_influence_coefficients (sim->fs->s->patches->data); */
    /* } */

    // Print total free-surface elevation
    /* if ( sim->time.itime%2 == 1 ) { */
    /*   print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t); */
    /*   g_assert_not_reached (); */
    /* } */


    // Update time
    sim->time.itime++;
    // Filters the free-surface every 20 iterations
    if ( sim->time.itime%5/* 200 */ == 0 ) {
      spline2d_filter_variable (sim->hull->patches->data, 7);
      spline2d_filter_variable (sim->hull->patches->data, 9);
      print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);
    }
    sim->time.t += sim->time.dt;
  }
  print_free_surface (sim->fs->s->patches, &sim->wp, sim->time.t);

#if CUDA
  cuda_finalize (&context);
#endif
#if OPENCL
  opencl_finalize ();
#endif
#if PLASMA
  PLASMA_Finalize();
#endif

  /* MPI_Finalize(); */
  return 0;
}
#endif

// gcc `pkg-config --cflags --libs glib-2.0` `pkg-config --cflags --libs gsl`  `pkg-config --cflags --libs gts` -lm -lnetpbm ship.c -o ship.0exe
